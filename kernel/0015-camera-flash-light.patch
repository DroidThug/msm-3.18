From a5f7444f1bee0c116cb5cf04de4af25ee7848469 Mon Sep 17 00:00:00 2001
From: lnxbuild <lnxbuild@localhost>
Date: Thu, 14 Nov 2013 14:33:24 +0800
Subject: [PATCH 15/15] camera flash light

---
 arch/arm/boot/dts/msm8610-qrd.dtsi                 |   15 ++-
 .../platform/msm/camera_v2/sensor/flash/Makefile   |    3 +-
 .../msm/camera_v2/sensor/flash/flash_lm3642.c      |  196 +++++++++++++++++++
 .../msm/camera_v2/sensor/flash/msm_led_flash.h     |    2 +
 .../camera_v2/sensor/flash/msm_led_i2c_trigger.c   |  204 ++++++++++----------
 5 files changed, 319 insertions(+), 101 deletions(-)
 create mode 100644 drivers/media/platform/msm/camera_v2/sensor/flash/flash_lm3642.c

diff --git a/arch/arm/boot/dts/msm8610-qrd.dtsi b/arch/arm/boot/dts/msm8610-qrd.dtsi
index 1bd1de3..7e8a212 100644
--- a/arch/arm/boot/dts/msm8610-qrd.dtsi
+++ b/arch/arm/boot/dts/msm8610-qrd.dtsi
@@ -228,12 +228,23 @@
                        taos,ppcount = <8>;
                        taos,irq_gpio = <80>;
                };
-
+	       
+       led-flash@63 {
+			cell-index = <0>;
+			reg = <0x63>;
+			qcom,slave-id = <0x63 0x00 0x0011>;
+			compatible = "qcom,led-flash";
+			status = "okay";
+			qcom,flash-name = "lm3642";
+			qcom,flash-type = <1>;
+			gpios = <&msmgpio 18 0>;
+			qcom,gpio-flash-en = <0>;
+        	};  
 	};
 
 	flashlight {
 		compatible = "qcom,leds-gpio-flash";
-		status = "okay";
+		status = "disabled";
 		qcom,flash-en = <&msmgpio 18 0>;
 		qcom,flash-now = <&msmgpio 19 0>;
 		linux,name = "flashlight";
diff --git a/drivers/media/platform/msm/camera_v2/sensor/flash/Makefile b/drivers/media/platform/msm/camera_v2/sensor/flash/Makefile
index 9fc3817..fd3fc8e 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/flash/Makefile
+++ b/drivers/media/platform/msm/camera_v2/sensor/flash/Makefile
@@ -3,5 +3,6 @@ ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/io
 obj-$(CONFIG_MSMB_CAMERA) += msm_led_flash.o
 obj-$(CONFIG_MSMB_CAMERA) += msm_led_trigger.o
 obj-$(CONFIG_MSMB_CAMERA) += msm_led_i2c_trigger.o
-obj-$(CONFIG_MSMB_CAMERA) += adp1660.o
+#obj-$(CONFIG_MSMB_CAMERA) += adp1660.o
 obj-$(CONFIG_MSMB_CAMERA) += msm_led_torch.o
+obj-$(CONFIG_MSMB_CAMERA)	+= flash_lm3642.o
diff --git a/drivers/media/platform/msm/camera_v2/sensor/flash/flash_lm3642.c b/drivers/media/platform/msm/camera_v2/sensor/flash/flash_lm3642.c
new file mode 100644
index 0000000..6438356
--- /dev/null
+++ b/drivers/media/platform/msm/camera_v2/sensor/flash/flash_lm3642.c
@@ -0,0 +1,196 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <linux/module.h>
+#include <linux/export.h>
+#include "msm_led_flash.h"
+
+#define FLASH_NAME "qcom,led-flash"
+
+#define CONFIG_MSMB_CAMERA_DEBUG
+#ifdef CONFIG_MSMB_CAMERA_DEBUG
+#define LM3642_DBG(x...) printk(KERN_ERR "[LM3642]" x)
+#else
+#define LM3642_DBG(x...)
+#endif
+
+#define ENABLE_REGISTER 0x0A
+#define MODE_BIT_MASK 0x03
+#define MODE_BIT_STANDBY 0x00
+#define MODE_BIT_INDICATOR 0x01
+#define MODE_BIT_TORCH 0x02
+#define MODE_BIT_FLASH 0x03
+#define ENABLE_BIT_FLASH 0x20
+#define ENABLE_BIT_TORCH 0x10
+
+#define CURRENT_REGISTER 0x09
+#define CURRENT_TORCH_MASK 0x70
+#define CURRENT_TORCH_SHIFT 4
+#define CURRENT_FLASH_MASK 0x0F
+#define CURRENT_FLASH_SHIFT 0
+
+#define FLASH_FEATURE_REGISTER 0x08
+#define FLASH_TIMEOUT_MASK 0x07
+#define FLASH_TIMEOUT_SHIFT 0
+
+#define FLASH_CHIP_ID_MASK 0x07
+#define FLASH_CHIP_ID 0x0
+
+
+static struct msm_led_flash_ctrl_t fctrl;
+static struct i2c_driver lm3642_i2c_driver;
+
+static struct msm_camera_i2c_reg_array lm3642_init_array[] = {
+	{ENABLE_REGISTER, MODE_BIT_STANDBY},
+};
+
+static struct msm_camera_i2c_reg_array lm3642_off_array[] = {
+	{ENABLE_REGISTER, MODE_BIT_STANDBY},
+};
+
+static struct msm_camera_i2c_reg_array lm3642_release_array[] = {
+	{ENABLE_REGISTER, MODE_BIT_STANDBY},
+};
+
+static struct msm_camera_i2c_reg_array lm3642_low_array[] = {
+	{ENABLE_REGISTER, MODE_BIT_TORCH},
+};
+
+static struct msm_camera_i2c_reg_array lm3642_high_array[] = {
+	{ENABLE_REGISTER, MODE_BIT_FLASH | ENABLE_BIT_FLASH},
+};
+
+static void __exit msm_flash_lm3642_i2c_remove(void)
+{
+	i2c_del_driver(&lm3642_i2c_driver);
+	return;
+}
+
+static const struct of_device_id lm3642_i2c_trigger_dt_match[] = {
+	{.compatible = "qcom,led-flash"},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, lm3642_i2c_trigger_dt_match);
+
+static const struct i2c_device_id flash_i2c_id[] = {
+	{"qcom,led-flash", (kernel_ulong_t)&fctrl},
+	{ }
+};
+
+static const struct i2c_device_id lm3642_i2c_id[] = {
+	{FLASH_NAME, (kernel_ulong_t)&fctrl},
+	{ }
+};
+
+static int msm_flash_lm3642_i2c_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	LM3642_DBG("%s entry\n", __func__);
+	if (!id) {
+		pr_err("msm_flash_lm3642_i2c_probe: id is NULL");
+		id = lm3642_i2c_id;
+	}
+
+	return msm_flash_i2c_probe(client, id);
+}
+
+static struct i2c_driver lm3642_i2c_driver = {
+	.id_table = lm3642_i2c_id,
+	.probe  = msm_flash_lm3642_i2c_probe,
+	.remove = __exit_p(msm_flash_lm3642_i2c_remove),
+	.driver = {
+		.name = FLASH_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = lm3642_i2c_trigger_dt_match,
+	},
+};
+
+static int __init msm_flash_lm3642_i2c_add_driver(void)
+{
+	LM3642_DBG("%s entry\n", __func__);
+	return i2c_add_driver(&lm3642_i2c_driver);
+}
+
+static struct msm_camera_i2c_client lm3642_i2c_client = {
+	.addr_type = MSM_CAMERA_I2C_BYTE_ADDR,
+};
+
+static struct msm_camera_i2c_reg_setting lm3642_init_setting = {
+	.reg_setting = lm3642_init_array,
+	.size = ARRAY_SIZE(lm3642_init_array),
+	.addr_type = MSM_CAMERA_I2C_BYTE_ADDR,
+	.data_type = MSM_CAMERA_I2C_BYTE_DATA,
+	.delay = 0,
+};
+
+static struct msm_camera_i2c_reg_setting lm3642_off_setting = {
+	.reg_setting = lm3642_off_array,
+	.size = ARRAY_SIZE(lm3642_off_array),
+	.addr_type = MSM_CAMERA_I2C_BYTE_ADDR,
+	.data_type = MSM_CAMERA_I2C_BYTE_DATA,
+	.delay = 0,
+};
+
+static struct msm_camera_i2c_reg_setting lm3642_release_setting = {
+	.reg_setting = lm3642_release_array,
+	.size = ARRAY_SIZE(lm3642_release_array),
+	.addr_type = MSM_CAMERA_I2C_BYTE_ADDR,
+	.data_type = MSM_CAMERA_I2C_BYTE_DATA,
+	.delay = 0,
+};
+
+static struct msm_camera_i2c_reg_setting lm3642_low_setting = {
+	.reg_setting = lm3642_low_array,
+	.size = ARRAY_SIZE(lm3642_low_array),
+	.addr_type = MSM_CAMERA_I2C_BYTE_ADDR,
+	.data_type = MSM_CAMERA_I2C_BYTE_DATA,
+	.delay = 0,
+};
+
+static struct msm_camera_i2c_reg_setting lm3642_high_setting = {
+	.reg_setting = lm3642_high_array,
+	.size = ARRAY_SIZE(lm3642_high_array),
+	.addr_type = MSM_CAMERA_I2C_BYTE_ADDR,
+	.data_type = MSM_CAMERA_I2C_BYTE_DATA,
+	.delay = 0,
+};
+
+static struct msm_led_flash_reg_t lm3642_regs = {
+	.init_setting = &lm3642_init_setting,
+	.off_setting = &lm3642_off_setting,
+	.low_setting = &lm3642_low_setting,
+	.high_setting = &lm3642_high_setting,
+	.release_setting = &lm3642_release_setting,
+};
+
+static struct msm_flash_fn_t lm3642_func_tbl = {
+	.flash_get_subdev_id = msm_led_i2c_trigger_get_subdev_id,
+	.flash_led_config = msm_led_i2c_trigger_config,
+	.flash_led_init = msm_flash_led_init,
+	.flash_led_release = msm_flash_led_release,
+	.flash_led_off = msm_flash_led_off,
+	.flash_led_low = msm_flash_led_low,
+	.flash_led_high = msm_flash_led_high,
+};
+
+static struct msm_led_flash_ctrl_t fctrl = {
+	.flash_i2c_client = &lm3642_i2c_client,
+	.reg_setting = &lm3642_regs,
+	.func_tbl = &lm3642_func_tbl,
+};
+
+/*subsys_initcall(msm_flash_i2c_add_driver);*/
+module_init(msm_flash_lm3642_i2c_add_driver);
+module_exit(msm_flash_lm3642_i2c_remove);
+MODULE_DESCRIPTION("lm3642 FLASH");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/msm/camera_v2/sensor/flash/msm_led_flash.h b/drivers/media/platform/msm/camera_v2/sensor/flash/msm_led_flash.h
index a4d7f15..0cadfee 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/flash/msm_led_flash.h
+++ b/drivers/media/platform/msm/camera_v2/sensor/flash/msm_led_flash.h
@@ -62,6 +62,8 @@ struct msm_led_flash_ctrl_t {
 	uint32_t num_sources;
 	enum msm_camera_device_type_t flash_device_type;
 	uint32_t subdev_id;
+	uint16_t flash_en;
+	uint16_t flash_now;
 };
 
 int msm_flash_i2c_probe(struct i2c_client *client,
diff --git a/drivers/media/platform/msm/camera_v2/sensor/flash/msm_led_i2c_trigger.c b/drivers/media/platform/msm/camera_v2/sensor/flash/msm_led_i2c_trigger.c
index 9caa270..e9d275d 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/flash/msm_led_i2c_trigger.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/flash/msm_led_i2c_trigger.c
@@ -23,25 +23,27 @@
 
 #define FLASH_NAME "camera-led-flash"
 
-/*#define CONFIG_MSMB_CAMERA_DEBUG*/
-#undef CDBG
+#define CONFIG_MSMB_CAMERA_DEBUG
 #ifdef CONFIG_MSMB_CAMERA_DEBUG
-#define CDBG(fmt, args...) pr_err(fmt, ##args)
+#define LM3642_DBG(x...) printk(KERN_ERR "[LM3642]" x)
 #else
-#define CDBG(fmt, args...) do { } while (0)
+#define LM3642_DBG(x...)
 #endif
 
+struct msm_led_flash_ctrl_t *fctrl = NULL;
+static enum led_brightness torch_state = LED_OFF;
 int32_t msm_led_i2c_trigger_get_subdev_id(struct msm_led_flash_ctrl_t *fctrl,
 	void *arg)
 {
 	uint32_t *subdev_id = (uint32_t *)arg;
+	LM3642_DBG("%s entry\n", __func__);
 	if (!subdev_id) {
 		pr_err("failed\n");
 		return -EINVAL;
 	}
 	*subdev_id = fctrl->subdev_id;
 
-	CDBG("subdev_id %d\n", *subdev_id);
+	LM3642_DBG("subdev_id %d\n", *subdev_id);
 	return 0;
 }
 
@@ -50,7 +52,7 @@ int32_t msm_led_i2c_trigger_config(struct msm_led_flash_ctrl_t *fctrl,
 {
 	int rc = 0;
 	struct msm_camera_led_cfg_t *cfg = (struct msm_camera_led_cfg_t *)data;
-	CDBG("called led_state %d\n", cfg->cfgtype);
+	LM3642_DBG("%s entry,cfg->cfgtype=%d\n", __func__,cfg->cfgtype);
 
 	if (!fctrl->func_tbl) {
 		pr_err("failed\n");
@@ -87,36 +89,16 @@ int32_t msm_led_i2c_trigger_config(struct msm_led_flash_ctrl_t *fctrl,
 		rc = -EFAULT;
 		break;
 	}
-	CDBG("flash_set_led_state: return %d\n", rc);
+	LM3642_DBG("%s leave, rc=%d\n", __func__,rc);
 	return rc;
 }
 
 int msm_flash_led_init(struct msm_led_flash_ctrl_t *fctrl)
 {
 	int rc = 0;
-	struct msm_camera_sensor_board_info *flashdata = NULL;
-	CDBG("%s:%d called\n", __func__, __LINE__);
+	LM3642_DBG("%s entry\n", __func__);
 
-	flashdata = fctrl->flashdata;
-	if (flashdata->gpio_conf->cam_gpiomux_conf_tbl != NULL) {
-		pr_err("%s:%d mux install\n", __func__, __LINE__);
-		msm_gpiomux_install(
-			(struct msm_gpiomux_config *)
-			flashdata->gpio_conf->cam_gpiomux_conf_tbl,
-			flashdata->gpio_conf->cam_gpiomux_conf_tbl_size);
-	}
-
-	rc = msm_camera_request_gpio_table(
-		flashdata->gpio_conf->cam_gpio_req_tbl,
-		flashdata->gpio_conf->cam_gpio_req_tbl_size, 1);
-	if (rc < 0) {
-		pr_err("%s: request gpio failed\n", __func__);
-		return rc;
-	}
-	msleep(20);
-	gpio_set_value_cansleep(
-		flashdata->gpio_conf->gpio_num_info->gpio_num[0],
-		GPIO_OUT_HIGH);
+	#if 0
 
 	if (fctrl->flash_i2c_client && fctrl->reg_setting) {
 		rc = fctrl->flash_i2c_client->i2c_func_tbl->i2c_write_table(
@@ -126,47 +108,30 @@ int msm_flash_led_init(struct msm_led_flash_ctrl_t *fctrl)
 			pr_err("%s:%d failed\n", __func__, __LINE__);
 	}
 
+	gpio_direction_output(fctrl->flash_en, 0);
+	#endif
 	return rc;
 }
 
 int msm_flash_led_release(struct msm_led_flash_ctrl_t *fctrl)
 {
-	int rc = 0;
-	struct msm_camera_sensor_board_info *flashdata = NULL;
 
-	flashdata = fctrl->flashdata;
-	CDBG("%s:%d called\n", __func__, __LINE__);
-	if (!fctrl) {
-		pr_err("%s:%d fctrl NULL\n", __func__, __LINE__);
-		return -EINVAL;
-	}
-	gpio_set_value_cansleep(
-		flashdata->gpio_conf->gpio_num_info->gpio_num[0],
-		GPIO_OUT_LOW);
-	gpio_set_value_cansleep(
-		flashdata->gpio_conf->gpio_num_info->gpio_num[1],
-		GPIO_OUT_LOW);
-	rc = msm_camera_request_gpio_table(
-		flashdata->gpio_conf->cam_gpio_req_tbl,
-		flashdata->gpio_conf->cam_gpio_req_tbl_size, 0);
-	if (rc < 0) {
-		pr_err("%s: request gpio failed\n", __func__);
-		return rc;
-	}
+	LM3642_DBG("%s entry\n", __func__);
+	gpio_direction_output(fctrl->flash_en, 0);
+
 	return 0;
 }
 
 int msm_flash_led_off(struct msm_led_flash_ctrl_t *fctrl)
 {
 	int rc = 0;
-	struct msm_camera_sensor_board_info *flashdata = NULL;
 
-	flashdata = fctrl->flashdata;
-	CDBG("%s:%d called\n", __func__, __LINE__);
+	LM3642_DBG("%s entry\n", __func__);
 	if (!fctrl) {
 		pr_err("%s:%d fctrl NULL\n", __func__, __LINE__);
 		return -EINVAL;
 	}
+	LM3642_DBG("sensor_slave_addr=%x\n", fctrl->flash_i2c_client->client->addr);
 	if (fctrl->flash_i2c_client && fctrl->reg_setting) {
 		rc = fctrl->flash_i2c_client->i2c_func_tbl->i2c_write_table(
 			fctrl->flash_i2c_client,
@@ -174,9 +139,8 @@ int msm_flash_led_off(struct msm_led_flash_ctrl_t *fctrl)
 		if (rc < 0)
 			pr_err("%s:%d failed\n", __func__, __LINE__);
 	}
-	gpio_set_value_cansleep(
-		flashdata->gpio_conf->gpio_num_info->gpio_num[1],
-		GPIO_OUT_LOW);
+	LM3642_DBG("fctrl->flash_en=%d\n", fctrl->flash_en);
+	gpio_direction_output(fctrl->flash_en, 0);
 
 	return rc;
 }
@@ -184,19 +148,13 @@ int msm_flash_led_off(struct msm_led_flash_ctrl_t *fctrl)
 int msm_flash_led_low(struct msm_led_flash_ctrl_t *fctrl)
 {
 	int rc = 0;
-	struct msm_camera_sensor_board_info *flashdata = NULL;
-	CDBG("%s:%d called\n", __func__, __LINE__);
-
-	flashdata = fctrl->flashdata;
-	gpio_set_value_cansleep(
-		flashdata->gpio_conf->gpio_num_info->gpio_num[0],
-		GPIO_OUT_HIGH);
+	
+	LM3642_DBG("%s entry,fctrl->flash_en=%d\n", __func__,fctrl->flash_en);
 
-	gpio_set_value_cansleep(
-		flashdata->gpio_conf->gpio_num_info->gpio_num[1],
-		GPIO_OUT_HIGH);
 
+	gpio_direction_output(fctrl->flash_en, 1);
 
+	LM3642_DBG("sensor_slave_addr=%x\n", fctrl->flash_i2c_client->client->addr);
 	if (fctrl->flash_i2c_client && fctrl->reg_setting) {
 		rc = fctrl->flash_i2c_client->i2c_func_tbl->i2c_write_table(
 			fctrl->flash_i2c_client,
@@ -211,18 +169,13 @@ int msm_flash_led_low(struct msm_led_flash_ctrl_t *fctrl)
 int msm_flash_led_high(struct msm_led_flash_ctrl_t *fctrl)
 {
 	int rc = 0;
-	struct msm_camera_sensor_board_info *flashdata = NULL;
-	CDBG("%s:%d called\n", __func__, __LINE__);
+	
+	LM3642_DBG("%s entry,fctrl->flash_en=%d\n", __func__,fctrl->flash_en);
 
-	flashdata = fctrl->flashdata;
-	gpio_set_value_cansleep(
-		flashdata->gpio_conf->gpio_num_info->gpio_num[0],
-		GPIO_OUT_HIGH);
 
-	gpio_set_value_cansleep(
-		flashdata->gpio_conf->gpio_num_info->gpio_num[1],
-		GPIO_OUT_HIGH);
+	gpio_direction_output(fctrl->flash_en, 1);
 
+	LM3642_DBG("sensor_slave_addr=%x\n", fctrl->flash_i2c_client->client->addr);
 	if (fctrl->flash_i2c_client && fctrl->reg_setting) {
 		rc = fctrl->flash_i2c_client->i2c_func_tbl->i2c_write_table(
 			fctrl->flash_i2c_client,
@@ -234,12 +187,14 @@ int msm_flash_led_high(struct msm_led_flash_ctrl_t *fctrl)
 	return rc;
 }
 
+#if 0
 static int32_t msm_flash_init_gpio_pin_tbl(struct device_node *of_node,
 	struct msm_camera_gpio_conf *gconf, uint16_t *gpio_array,
 	uint16_t gpio_array_size)
 {
 	int32_t rc = 0;
 	int32_t val = 0;
+	LM3642_DBG("%s entry\n", __func__);
 
 	gconf->gpio_num_info = kzalloc(sizeof(struct msm_camera_gpio_num_info),
 		GFP_KERNEL);
@@ -262,7 +217,7 @@ static int32_t msm_flash_init_gpio_pin_tbl(struct device_node *of_node,
 	/*index 0 is for qcom,gpio-flash-en */
 	gconf->gpio_num_info->gpio_num[0] =
 		gpio_array[val];
-	CDBG("%s qcom,gpio-flash-en %d\n", __func__,
+	LM3642_DBG("%s qcom,gpio-flash-en %d\n", __func__,
 		gconf->gpio_num_info->gpio_num[0]);
 
 	rc = of_property_read_u32(of_node, "qcom,gpio-flash-now", &val);
@@ -278,7 +233,7 @@ static int32_t msm_flash_init_gpio_pin_tbl(struct device_node *of_node,
 	/*index 1 is for qcom,gpio-flash-now */
 	gconf->gpio_num_info->gpio_num[1] =
 		gpio_array[val];
-	CDBG("%s qcom,gpio-flash-now %d\n", __func__,
+	LM3642_DBG("%s qcom,gpio-flash-now %d\n", __func__,
 		gconf->gpio_num_info->gpio_num[1]);
 
 	return rc;
@@ -288,6 +243,7 @@ ERROR:
 	gconf->gpio_num_info = NULL;
 	return rc;
 }
+#endif
 
 static int32_t msm_led_get_dt_data(struct device_node *of_node,
 		struct msm_led_flash_ctrl_t *fctrl)
@@ -301,7 +257,7 @@ static int32_t msm_led_get_dt_data(struct device_node *of_node,
 	uint16_t gpio_array_size = 0;
 	uint32_t id_info[3];
 
-	CDBG("called\n");
+	LM3642_DBG("%s entry\n", __func__);
 
 	if (!of_node) {
 		pr_err("of_node NULL\n");
@@ -331,12 +287,11 @@ static int32_t msm_led_get_dt_data(struct device_node *of_node,
 		return -EINVAL;
 	}
 
-	CDBG("subdev id %d\n", fctrl->subdev_id);
+	LM3642_DBG("subdev id %d\n", fctrl->subdev_id);
 
 	rc = of_property_read_string(of_node, "qcom,flash-name",
 		&flashdata->sensor_name);
-	CDBG("%s qcom,flash-name %s, rc %d\n", __func__,
-		flashdata->sensor_name, rc);
+	LM3642_DBG("%s qcom,flash-name %s, rc %d\n", __func__,flashdata->sensor_name, rc);
 	if (rc < 0) {
 		pr_err("%s failed %d\n", __func__, __LINE__);
 		goto ERROR1;
@@ -344,7 +299,7 @@ static int32_t msm_led_get_dt_data(struct device_node *of_node,
 
 	if (of_get_property(of_node, "qcom,flash-source", &count)) {
 		count /= sizeof(uint32_t);
-		CDBG("count %d\n", count);
+		LM3642_DBG("count %d\n", count);
 		if (count > MAX_LED_TRIGGERS) {
 			pr_err("failed\n");
 			return -EINVAL;
@@ -366,7 +321,7 @@ static int32_t msm_led_get_dt_data(struct device_node *of_node,
 				continue;
 			}
 
-			CDBG("default trigger %s\n",
+			LM3642_DBG("default trigger %s\n",
 				 fctrl->flash_trigger_name[i]);
 
 			rc = of_property_read_u32(flash_src_node,
@@ -380,7 +335,7 @@ static int32_t msm_led_get_dt_data(struct device_node *of_node,
 
 			of_node_put(flash_src_node);
 
-			CDBG("max_current[%d] %d\n",
+			LM3642_DBG("max_current[%d] %d\n",
 				i, fctrl->flash_op_current[i]);
 
 			led_trigger_register_simple(
@@ -400,7 +355,7 @@ static int32_t msm_led_get_dt_data(struct device_node *of_node,
 		gconf = flashdata->gpio_conf;
 
 		gpio_array_size = of_gpio_count(of_node);
-		CDBG("%s gpio count %d\n", __func__, gpio_array_size);
+		LM3642_DBG("%s gpio count %d\n", __func__, gpio_array_size);
 
 		if (gpio_array_size) {
 			gpio_array = kzalloc(sizeof(uint16_t) * gpio_array_size,
@@ -408,16 +363,24 @@ static int32_t msm_led_get_dt_data(struct device_node *of_node,
 			if (!gpio_array) {
 				pr_err("%s failed %d\n", __func__, __LINE__);
 				rc = -ENOMEM;
-				goto ERROR4;
+				goto ERROR1;
 			}
 			for (i = 0; i < gpio_array_size; i++) {
 				gpio_array[i] = of_get_gpio(of_node, i);
-				CDBG("%s gpio_array[%d] = %d\n", __func__, i,
+				LM3642_DBG("%s gpio_array[%d] = %d\n", __func__, i,
 					gpio_array[i]);
 			}
 
+			fctrl->flash_en = gpio_array[0];
+			gpio_request(fctrl->flash_en, "FLASH_EN");
+			gpio_tlmm_config(GPIO_CFG(fctrl->flash_en, 0,
+				  GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL,
+				  GPIO_CFG_2MA), GPIO_CFG_ENABLE);
+			gpio_direction_output(fctrl->flash_en, 0);
+			#if 0
 			rc = msm_sensor_get_dt_gpio_req_tbl(of_node, gconf,
 				gpio_array, gpio_array_size);
+			LM3642_DBG("msm_sensor_get_dt_gpio_req_tbl rc =%d\n",rc);
 			if (rc < 0) {
 				pr_err("%s failed %d\n", __func__, __LINE__);
 				goto ERROR4;
@@ -425,6 +388,7 @@ static int32_t msm_led_get_dt_data(struct device_node *of_node,
 
 			rc = msm_sensor_get_dt_gpio_set_tbl(of_node, gconf,
 				gpio_array, gpio_array_size);
+			LM3642_DBG("msm_sensor_get_dt_gpio_set_tbl rc=%d\n",rc);
 			if (rc < 0) {
 				pr_err("%s failed %d\n", __func__, __LINE__);
 				goto ERROR5;
@@ -432,21 +396,24 @@ static int32_t msm_led_get_dt_data(struct device_node *of_node,
 
 			rc = msm_flash_init_gpio_pin_tbl(of_node, gconf,
 				gpio_array, gpio_array_size);
+			LM3642_DBG("msm_flash_init_gpio_pin_tbl rc=%d\n",rc);
 			if (rc < 0) {
 				pr_err("%s failed %d\n", __func__, __LINE__);
 				goto ERROR6;
 			}
+			#endif
 		}
 
 		flashdata->slave_info =
 			kzalloc(sizeof(struct msm_camera_slave_info),
 				GFP_KERNEL);
 		if (!flashdata->slave_info) {
-			pr_err("%s failed %d\n", __func__, __LINE__);
+			LM3642_DBG("%s failed %d\n", __func__, __LINE__);
 			rc = -ENOMEM;
 			goto ERROR8;
 		}
 
+		LM3642_DBG("%s slave_info get\n", __func__);
 		rc = of_property_read_u32_array(of_node, "qcom,slave-id",
 			id_info, 3);
 		if (rc < 0) {
@@ -457,18 +424,13 @@ static int32_t msm_led_get_dt_data(struct device_node *of_node,
 		fctrl->flashdata->slave_info->sensor_id_reg_addr = id_info[1];
 		fctrl->flashdata->slave_info->sensor_id = id_info[2];
 
+		LM3642_DBG("sensor_slave_addr=%x,sensor_id_reg_addr=%x,sensor_id=%x\n", id_info[0],id_info[1],id_info[2]);
 		kfree(gpio_array);
 		return rc;
 ERROR9:
 		kfree(fctrl->flashdata->slave_info);
 ERROR8:
 		kfree(fctrl->flashdata->gpio_conf->gpio_num_info);
-ERROR6:
-		kfree(gconf->cam_gpio_set_tbl);
-ERROR5:
-		kfree(gconf->cam_gpio_req_tbl);
-ERROR4:
-		kfree(gconf);
 ERROR1:
 		kfree(fctrl->flashdata);
 		kfree(gpio_array);
@@ -476,6 +438,38 @@ ERROR1:
 	return rc;
 }
 
+static void msm_led_torch_brightness_set(struct led_classdev *led_cdev,
+				enum led_brightness value)
+{
+	LM3642_DBG("%s entry value=%d\n", __func__,value);
+	if (value == LED_OFF)
+	{
+		msm_flash_led_off(fctrl);
+		torch_state = LED_OFF;
+	}
+	else if (value >= LED_OFF)
+	{
+		msm_flash_led_low(fctrl);
+		torch_state = LED_HALF;
+	}
+	else
+	{
+		msm_flash_led_off(fctrl);
+		torch_state = LED_OFF;	
+	}
+}
+static enum led_brightness msm_led_torch_brightness_get(struct led_classdev *led_cdev)
+{
+	return torch_state;
+}
+static struct led_classdev msm_torch_led = {
+	.name			= "led:flash_torch",
+	.max_brightness = LED_FULL,
+	.brightness_set		= msm_led_torch_brightness_set,
+	.brightness_get		= msm_led_torch_brightness_get,
+	.brightness		= LED_OFF,
+	.default_trigger = "torch-trigger",
+};
 static struct msm_camera_i2c_fn_t msm_sensor_qup_func_tbl = {
 	.i2c_read = msm_camera_qup_i2c_read,
 	.i2c_read_seq = msm_camera_qup_i2c_read_seq,
@@ -520,12 +514,18 @@ int msm_flash_i2c_probe(struct i2c_client *client,
 		const struct i2c_device_id *id)
 {
 	int rc = 0;
-	struct msm_led_flash_ctrl_t *fctrl = NULL;
 #ifdef CONFIG_DEBUG_FS
 	struct dentry *dentry;
 #endif
+	LM3642_DBG("%s entry\n", __func__);
+	
 	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
-		pr_err("i2c_check_functionality failed\n");
+		pr_err("i2c_check_functionality failed I2C_FUNC_I2C\n");
+		goto probe_failure;
+	}
+    if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_I2C_BLOCK))
+	{
+	    pr_err("i2c_check_functionality failed I2C_FUNC_SMBUS_I2C_BLOCK\n");
 		goto probe_failure;
 	}
 
@@ -557,21 +557,29 @@ int msm_flash_i2c_probe(struct i2c_client *client,
 		return rc;
 	}
 
+	fctrl->flash_i2c_client->client->addr = fctrl->flash_i2c_client->client->addr<<1;
 	if (!fctrl->flash_i2c_client->i2c_func_tbl)
 		fctrl->flash_i2c_client->i2c_func_tbl =
 			&msm_sensor_qup_func_tbl;
+	msm_led_torch_brightness_set(&msm_torch_led, LED_OFF);		
+	rc = led_classdev_register(&client->dev, &msm_torch_led);	
+	if (rc) {
+		pr_err("Failed to register led dev. rc = %d\n", rc);
+		return rc;
+	}
 
 	rc = msm_led_i2c_flash_create_v4lsubdev(fctrl);
+	LM3642_DBG("sensor_slave_addr=%x\n", fctrl->flash_i2c_client->client->addr);
 #ifdef CONFIG_DEBUG_FS
 	dentry = debugfs_create_file("ledflash", S_IRUGO, NULL, (void *)fctrl,
 		&ledflashdbg_fops);
 	if (!dentry)
 		pr_err("Failed to create the debugfs ledflash file");
 #endif
-	CDBG("%s:%d probe success\n", __func__, __LINE__);
+	LM3642_DBG("%s:%d probe success\n", __func__, __LINE__);
 	return 0;
 
 probe_failure:
-	CDBG("%s:%d probe failed\n", __func__, __LINE__);
+	LM3642_DBG("%s:%d probe failed\n", __func__, __LINE__);
 	return rc;
 }
-- 
1.7.8.3

