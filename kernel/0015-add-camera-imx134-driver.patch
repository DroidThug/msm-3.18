From 65d84d34c06e7c80e6ecddc5c02df8ffd9478fd5 Mon Sep 17 00:00:00 2001
From: lnxbuild <lnxbuild@localhost>
Date: Tue, 10 Sep 2013 17:56:52 +0800
Subject: [PATCH 15/16] add camera imx134 driver

Change-Id: I249e84ccfa11a7acc7bbfa23b705b806c45e2a8c
---
 arch/arm/boot/dts/msm8610-qrd-camera-sensor.dtsi   |   36 ++
 arch/arm/configs/msm8610_defconfig                 |    1 +
 arch/arm/mach-msm/clock-8610.c                     |    4 +-
 drivers/media/platform/msm/camera_v2/Kconfig       |    8 +
 .../media/platform/msm/camera_v2/sensor/Makefile   |    1 +
 .../msm/camera_v2/sensor/imx134_sunny_p8n09c.c     |  459 ++++++++++++++++++++
 6 files changed, 508 insertions(+), 1 deletions(-)
 create mode 100644 drivers/media/platform/msm/camera_v2/sensor/imx134_sunny_p8n09c.c

diff --git a/arch/arm/boot/dts/msm8610-qrd-camera-sensor.dtsi b/arch/arm/boot/dts/msm8610-qrd-camera-sensor.dtsi
index f7a475af..c523c74 100644
--- a/arch/arm/boot/dts/msm8610-qrd-camera-sensor.dtsi
+++ b/arch/arm/boot/dts/msm8610-qrd-camera-sensor.dtsi
@@ -333,5 +333,41 @@
 		qcom,sensor-mode = <1>;
 		qcom,cci-master = <0>;
 	};
+	qcom,camera@28 {
+                               compatible = "qcom,imx134_sunny_p8n09c";
+                               reg = <0x28>;
+                               qcom,slave-id = <0x20 0x0016 0x0134>;
+                               qcom,csiphy-sd-index = <0>;
+                               qcom,csid-sd-index = <0>;
+                               qcom,actuator-src = <&actuator0>;
+                               qcom,led-flash-src = <&led_flash0>;
+                               qcom,mount-angle = <90>;
+                               qcom,sensor-name = "imx134_sunny_p8n09c";
+                               cam_vdig-supply = <&pm8110_l2>;
+                               cam_vio-supply = <&pm8110_l7>;
+                               cam_vana-supply = <&pm8110_l22>;
+                               qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana";
+                               qcom,cam-vreg-type = <0 0 0>;
+                               qcom,cam-vreg-min-voltage = <0 1800000 2850000>;
+                               qcom,cam-vreg-max-voltage = <0 1800000 2850000>;
+                               qcom,cam-vreg-op-mode = <0 200000 100000>;
+                               qcom,gpio-no-mux = <0>;
+                               gpios = <&msmgpio 13 0>,
+                                       <&msmgpio 21 0>,//reset
+                                       <&msmgpio 101 0>, //dvdd_en
+                                       <&msmgpio 79 0>; //vcm_pwdn
+                               qcom,gpio-reset = <1>;
+                               qcom,gpio-req-tbl-num = <0 1 2 3>;
+                               qcom,gpio-req-tbl-flags = <1 0 0 0>;
+                               qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+                                       "CAM_RESET1",
+                                       "CAM_DVDDEN",
+                                       "CAM_VCMPWDN";
+                               qcom,csi-lane-assign = <0xe4>;
+                              qcom,csi-lane-mask = <0x7>;
+                               qcom,sensor-position = <0>;
+                               qcom,sensor-mode = <1>;
+				qcom,cci-master = <0>;
+                       };
 };
 
diff --git a/arch/arm/configs/msm8610_defconfig b/arch/arm/configs/msm8610_defconfig
index 3300010..e444ea1 100644
--- a/arch/arm/configs/msm8610_defconfig
+++ b/arch/arm/configs/msm8610_defconfig
@@ -313,6 +313,7 @@ CONFIG_OV5648_SUNNY_P5V18G=y
 CONFIG_S5K4H5_LITEON_12P1BA855D=y
 CONFIG_S5K4E1_LITEON_13P1BA535D=y
 CONFIG_MT9V113_SUNNY_P0M01K=y
+CONFIG_IMX134_SUNNY_P8N09C=y
 CONFIG_MSM_CAMERA_SENSOR=y
 CONFIG_MSM_CCI=y
 CONFIG_MSM_CSIPHY=y
diff --git a/arch/arm/mach-msm/clock-8610.c b/arch/arm/mach-msm/clock-8610.c
index 8922fd0..a6e04ee 100644
--- a/arch/arm/mach-msm/clock-8610.c
+++ b/arch/arm/mach-msm/clock-8610.c
@@ -3030,16 +3030,18 @@ static struct clk_lookup msm_clocks_8610[] = {
 	CLK_LOOKUP("cam_src_clk", mclk0_clk_src.c, "6-0068"),	
 	CLK_LOOKUP("cam_src_clk", mclk0_clk_src.c, "6-006a"),		
 	CLK_LOOKUP("cam_src_clk", mclk0_clk_src.c, "6-007a"),
+	CLK_LOOKUP("cam_src_clk", mclk0_clk_src.c, "6-0028"),
 	CLK_LOOKUP("cam_clk", mclk0_clk.c, "6-006f"),
 	CLK_LOOKUP("cam_clk", mclk0_clk.c, "6-007d"),
 	CLK_LOOKUP("cam_clk", mclk0_clk.c, "6-006d"),
 	CLK_LOOKUP("cam_clk", mclk1_clk.c, "6-0078"),
 	CLK_LOOKUP("cam_clk", mclk0_clk.c, "6-0020"),
 	CLK_LOOKUP("cam_clk", mclk0_clk.c, "6-006c"),
-  CLK_LOOKUP("cam_clk", mclk0_clk.c, "6-0022"),	
+	CLK_LOOKUP("cam_clk", mclk0_clk.c, "6-0022"),
 	CLK_LOOKUP("cam_clk", mclk0_clk.c, "6-0068"),  	
 	CLK_LOOKUP("cam_clk", mclk0_clk.c, "6-006a"),  	
 	CLK_LOOKUP("cam_clk", mclk0_clk.c, "6-007a"),
+	CLK_LOOKUP("cam_clk", mclk0_clk.c, "6-0028"),
  
 	/* CSIPHY clocks */
 	CLK_LOOKUP("csiphy_timer_src_clk", csi0phytimer_clk_src.c,
diff --git a/drivers/media/platform/msm/camera_v2/Kconfig b/drivers/media/platform/msm/camera_v2/Kconfig
index 9bd8c4d..0ce40f0 100644
--- a/drivers/media/platform/msm/camera_v2/Kconfig
+++ b/drivers/media/platform/msm/camera_v2/Kconfig
@@ -250,6 +250,14 @@ config s5k4e1
 		supports 720P preview at 30 fps
 		and QSXGA snapshot at 15 fps.
 		This sensor driver does not support auto focus.
+		
+config IMX134_SUNNY_P8N09C
+	bool "Sony IMX134_SUNNY_P8N09C (BAYER 8MP)"
+	depends on MSMB_CAMERA
+	---help---
+		Sony 8 MP Bayer Sensor with auto focus.uses
+		2 mipi lanes, preview config = 1632*1224 30 fps,
+		snapshot config = 3264 * 2448 at 15 fps.		
 
 config OV12830
 	bool "OmniVision OV12830 (BAYER 12MP)"
diff --git a/drivers/media/platform/msm/camera_v2/sensor/Makefile b/drivers/media/platform/msm/camera_v2/sensor/Makefile
index f135688..77e1448 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/Makefile
+++ b/drivers/media/platform/msm/camera_v2/sensor/Makefile
@@ -14,6 +14,7 @@ obj-$(CONFIG_OV8850_FOXCONN_DC0901B) += ov8850_foxconn_dc0901b.o
 obj-$(CONFIG_OV5648_SUNNY_P5V18G) += ov5648_sunny_p5v18g.o
 obj-$(CONFIG_S5K4H5_LITEON_12P1BA855D) += s5k4h5_liteon_12p1ba855d.o
 obj-$(CONFIG_S5K4E1_LITEON_13P1BA535D) += s5k4e1_liteon_13p1ba535d.o
+obj-$(CONFIG_IMX134_SUNNY_P8N09C) += imx134_sunny_p8n09c.o
 obj-$(CONFIG_OV2720) += ov2720.o
 obj-$(CONFIG_OV9724) += ov9724.o
 obj-$(CONFIG_HI256) += hi256.o
diff --git a/drivers/media/platform/msm/camera_v2/sensor/imx134_sunny_p8n09c.c b/drivers/media/platform/msm/camera_v2/sensor/imx134_sunny_p8n09c.c
new file mode 100644
index 0000000..43a5bb6
--- /dev/null
+++ b/drivers/media/platform/msm/camera_v2/sensor/imx134_sunny_p8n09c.c
@@ -0,0 +1,459 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <mach/gpiomux.h>
+#include "msm_sensor.h"
+#include "msm_sd.h"
+#include "camera.h"
+#include "msm_cci.h"
+#include "msm_camera_io_util.h"
+#include "msm_camera_i2c_mux.h"
+#include <mach/rpm-regulator.h>
+#include <mach/rpm-regulator-smd.h>
+#include <linux/regulator/consumer.h>
+
+#define IMX134_SUNNY_P8N09C_SENSOR_NAME "imx134_sunny_p8n09c"
+DEFINE_MSM_MUTEX(imx134_sunny_p8n09c_mut);
+
+#define GPIO_CAM_DVDD_EN 101
+
+#undef CDBG
+#define IMX134_SUNNY_P8N09C_DEBUG
+#ifdef IMX134_SUNNY_P8N09C_DEBUG
+#define CDBG(fmt, args...) pr_err(fmt, ##args)
+#else
+#define CDBG(fmt, args...) do { } while (0)
+#endif
+
+static struct msm_sensor_ctrl_t imx134_sunny_p8n09c_s_ctrl;
+
+static struct msm_sensor_power_setting imx134_sunny_p8n09c_power_setting[] = {
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 40,
+	},
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VANA,
+		.config_val = 0,
+		.delay = 5,
+	},	
+	{
+		.seq_type = SENSOR_VREG,
+		.seq_val = CAM_VIO,
+		.config_val = 0,
+		.delay = 5,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_LOW,
+		.delay = 40,
+	},
+	{
+		.seq_type = SENSOR_GPIO,
+		.seq_val = SENSOR_GPIO_RESET,
+		.config_val = GPIO_OUT_HIGH,
+		.delay = 40,
+	},
+	{
+		.seq_type = SENSOR_CLK,
+		.seq_val = SENSOR_CAM_MCLK,
+		.config_val = 24000000,
+		.delay = 5,
+	},
+	{
+		.seq_type = SENSOR_I2C_MUX,
+		.seq_val = 0,
+		.config_val = 0,
+		.delay = 0,
+	},
+};
+
+static struct v4l2_subdev_info imx134_sunny_p8n09c_subdev_info[] = {
+	{
+		.code   = V4L2_MBUS_FMT_SGRBG10_1X10,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.fmt    = 1,
+		.order    = 0,
+	},
+};
+
+static const struct i2c_device_id imx134_sunny_p8n09c_i2c_id[] = {
+	{IMX134_SUNNY_P8N09C_SENSOR_NAME, (kernel_ulong_t)&imx134_sunny_p8n09c_s_ctrl},
+	{ }
+};
+
+static int32_t msm_imx134_sunny_p8n09c_i2c_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	return msm_sensor_i2c_probe(client, id, &imx134_sunny_p8n09c_s_ctrl);
+}
+
+static struct i2c_driver imx134_sunny_p8n09c_i2c_driver = {
+	.id_table = imx134_sunny_p8n09c_i2c_id,
+	.probe  = msm_imx134_sunny_p8n09c_i2c_probe,
+	.driver = {
+		.name = IMX134_SUNNY_P8N09C_SENSOR_NAME,
+	},
+};
+
+static struct msm_camera_i2c_client imx134_sunny_p8n09c_sensor_i2c_client = {
+	.addr_type = MSM_CAMERA_I2C_WORD_ADDR,
+};
+
+static const struct of_device_id imx134_sunny_p8n09c_dt_match[] = {
+	{.compatible = "qcom,imx134_sunny_p8n09c", .data = &imx134_sunny_p8n09c_s_ctrl},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, imx134_sunny_p8n09c_dt_match);
+
+static struct platform_driver imx134_sunny_p8n09c_platform_driver = {
+	.driver = {
+		.name = "qcom,imx134_sunny_p8n09c",
+		.owner = THIS_MODULE,
+		.of_match_table = imx134_sunny_p8n09c_dt_match,
+	},
+};
+
+static int32_t imx134_sunny_p8n09c_platform_probe(struct platform_device *pdev)
+{
+	int32_t rc = 0;
+	const struct of_device_id *match;
+	match = of_match_device(imx134_sunny_p8n09c_dt_match, &pdev->dev);
+	rc = msm_sensor_platform_probe(pdev, match->data);
+	return rc;
+}
+
+static int __init imx134_sunny_p8n09c_init_module(void)
+{
+	int32_t rc = 0;
+	pr_info("%s:%d\n", __func__, __LINE__);
+	rc = platform_driver_probe(&imx134_sunny_p8n09c_platform_driver,
+		imx134_sunny_p8n09c_platform_probe);
+	if (!rc)
+		return rc;
+	pr_err("%s:%d rc %d\n", __func__, __LINE__, rc);
+	return i2c_add_driver(&imx134_sunny_p8n09c_i2c_driver);
+}
+
+static void __exit imx134_sunny_p8n09c_exit_module(void)
+{
+	pr_info("%s:%d\n", __func__, __LINE__);
+	if (imx134_sunny_p8n09c_s_ctrl.pdev) {
+		msm_sensor_free_sensor_data(&imx134_sunny_p8n09c_s_ctrl);
+		platform_driver_unregister(&imx134_sunny_p8n09c_platform_driver);
+	} else
+		i2c_del_driver(&imx134_sunny_p8n09c_i2c_driver);
+	return;
+}
+
+static int32_t imx134_sunny_p8n09c_sensor_enable_i2c_mux(struct msm_camera_i2c_conf *i2c_conf)
+{
+	struct v4l2_subdev *i2c_mux_sd =
+		dev_get_drvdata(&i2c_conf->mux_dev->dev);
+	v4l2_subdev_call(i2c_mux_sd, core, ioctl,
+		VIDIOC_MSM_I2C_MUX_INIT, NULL);
+	v4l2_subdev_call(i2c_mux_sd, core, ioctl,
+		VIDIOC_MSM_I2C_MUX_CFG, (void *)&i2c_conf->i2c_mux_mode);
+	return 0;
+}
+
+static int32_t imx134_sunny_p8n09c_sensor_disable_i2c_mux(struct msm_camera_i2c_conf *i2c_conf)
+{
+	struct v4l2_subdev *i2c_mux_sd =
+		dev_get_drvdata(&i2c_conf->mux_dev->dev);
+	v4l2_subdev_call(i2c_mux_sd, core, ioctl,
+				VIDIOC_MSM_I2C_MUX_RELEASE, NULL);
+	return 0;
+}
+
+int32_t imx134_sunny_p8n09c_sensor_power_up(struct msm_sensor_ctrl_t *s_ctrl)
+{
+	int32_t rc = 0, index = 0;
+	struct msm_sensor_power_setting_array *power_setting_array = NULL;
+	struct msm_sensor_power_setting *power_setting = NULL;
+	struct msm_camera_sensor_board_info *data = s_ctrl->sensordata;
+
+	CDBG("%s:%d\n", __func__, __LINE__);
+	power_setting_array = &s_ctrl->power_setting_array;
+
+	if (data->gpio_conf->cam_gpiomux_conf_tbl != NULL) {
+		pr_err("%s:%d mux install\n", __func__, __LINE__);
+		msm_gpiomux_install(
+			(struct msm_gpiomux_config *)
+			data->gpio_conf->cam_gpiomux_conf_tbl,
+			data->gpio_conf->cam_gpiomux_conf_tbl_size);
+	}
+
+	rc = msm_camera_request_gpio_table(
+		data->gpio_conf->cam_gpio_req_tbl,
+		data->gpio_conf->cam_gpio_req_tbl_size, 1);
+	if (rc < 0) {
+		pr_err("%s: request gpio failed\n", __func__);
+		return rc;
+	}
+	for (index = 0; index < power_setting_array->size; index++) {
+		CDBG("%s index %d\n", __func__, index);
+		power_setting = &power_setting_array->power_setting[index];
+		CDBG("%s type %d\n", __func__, power_setting->seq_type);
+		switch (power_setting->seq_type) {
+		case SENSOR_CLK:
+			if (power_setting->seq_val >= s_ctrl->clk_info_size) {
+				pr_err("%s clk index %d >= max %d\n", __func__,
+					power_setting->seq_val,
+					s_ctrl->clk_info_size);
+				goto power_up_failed;
+			}
+			if (power_setting->config_val)
+				s_ctrl->clk_info[power_setting->seq_val].
+					clk_rate = power_setting->config_val;
+
+			rc = msm_cam_clk_enable(s_ctrl->dev,
+				&s_ctrl->clk_info[0],
+				(struct clk **)&power_setting->data[0],
+				s_ctrl->clk_info_size,
+				1);
+			if (rc < 0) {
+				pr_err("%s: clk enable failed\n",
+					__func__);
+				goto power_up_failed;
+			}
+			break;
+		case SENSOR_GPIO:
+			if (power_setting->seq_val >= SENSOR_GPIO_MAX ||
+				!data->gpio_conf->gpio_num_info) {
+				pr_err("%s gpio index %d >= max %d\n", __func__,
+					power_setting->seq_val,
+					SENSOR_GPIO_MAX);
+				goto power_up_failed;
+			}
+			pr_debug("%s:%d gpio set val %d\n", __func__, __LINE__,
+				data->gpio_conf->gpio_num_info->gpio_num
+				[power_setting->seq_val]);
+			gpio_set_value_cansleep(
+				data->gpio_conf->gpio_num_info->gpio_num
+				[power_setting->seq_val],
+				power_setting->config_val);		
+			break;
+		case SENSOR_VREG:
+			if (power_setting->seq_val >= CAM_VREG_MAX) {
+				pr_err("%s vreg index %d >= max %d\n", __func__,
+					power_setting->seq_val,
+					SENSOR_GPIO_MAX);
+				goto power_up_failed;
+			}
+
+			gpio_set_value_cansleep(GPIO_CAM_DVDD_EN,1); //enable dvdd_en	
+			
+			msm_camera_config_single_vreg(s_ctrl->dev,
+				&data->cam_vreg[power_setting->seq_val],
+				(struct regulator **)&power_setting->data[0],
+				1);
+
+			gpio_set_value_cansleep(79,1); //enable vcm
+			
+			break;
+		case SENSOR_I2C_MUX:
+			if (data->i2c_conf && data->i2c_conf->use_i2c_mux)
+				imx134_sunny_p8n09c_sensor_enable_i2c_mux(data->i2c_conf);
+			break;
+		default:
+			pr_err("%s error power seq type %d\n", __func__,
+				power_setting->seq_type);
+			break;
+		}
+		if (power_setting->delay > 20) {
+			msleep(power_setting->delay);
+		} else if (power_setting->delay) {
+			usleep_range(power_setting->delay * 1000,
+				(power_setting->delay * 1000) + 1000);
+		}
+	}
+
+	if (s_ctrl->sensor_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+		rc = s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_util(
+			s_ctrl->sensor_i2c_client, MSM_CCI_INIT);
+		if (rc < 0) {
+			pr_err("%s cci_init failed\n", __func__);
+			goto power_up_failed;
+		}
+	}
+
+	if (s_ctrl->func_tbl->sensor_match_id)
+		rc = s_ctrl->func_tbl->sensor_match_id(s_ctrl);
+	else
+		rc = msm_sensor_match_id(s_ctrl);
+	if (rc < 0) {
+		pr_err("%s:%d match id failed rc %d\n", __func__, __LINE__, rc);
+		goto power_up_failed;
+	}
+
+	CDBG("%s exit\n", __func__);
+	return 0;
+power_up_failed:
+	pr_err("%s:%d failed\n", __func__, __LINE__);
+	if (s_ctrl->sensor_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+		s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_util(
+			s_ctrl->sensor_i2c_client, MSM_CCI_RELEASE);
+	}
+
+	for (index--; index >= 0; index--) {
+		CDBG("%s index %d\n", __func__, index);
+		power_setting = &power_setting_array->power_setting[index];
+		CDBG("%s type %d\n", __func__, power_setting->seq_type);
+		switch (power_setting->seq_type) {
+		case SENSOR_CLK:
+			msm_cam_clk_enable(s_ctrl->dev,
+				&s_ctrl->clk_info[0],
+				(struct clk **)&power_setting->data[0],
+				s_ctrl->clk_info_size,
+				0);
+			break;
+		case SENSOR_GPIO:
+			gpio_set_value_cansleep(
+				data->gpio_conf->gpio_num_info->gpio_num
+				[power_setting->seq_val], GPIOF_OUT_INIT_LOW);
+			break;
+		case SENSOR_VREG:
+			msm_camera_config_single_vreg(s_ctrl->dev,
+				&data->cam_vreg[power_setting->seq_val],
+				(struct regulator **)&power_setting->data[0],
+				0);
+			break;
+		case SENSOR_I2C_MUX:
+			if (data->i2c_conf && data->i2c_conf->use_i2c_mux)
+				imx134_sunny_p8n09c_sensor_disable_i2c_mux(data->i2c_conf);
+			break;
+		default:
+			pr_err("%s error power seq type %d\n", __func__,
+				power_setting->seq_type);
+			break;
+		}
+		if (power_setting->delay > 20) {
+			msleep(power_setting->delay);
+		} else if (power_setting->delay) {
+			usleep_range(power_setting->delay * 1000,
+				(power_setting->delay * 1000) + 1000);
+		}
+	}
+	msm_camera_request_gpio_table(
+		data->gpio_conf->cam_gpio_req_tbl,
+		data->gpio_conf->cam_gpio_req_tbl_size, 0);
+	return rc;
+}
+
+int32_t imx134_sunny_p8n09c_sensor_power_down(struct msm_sensor_ctrl_t *s_ctrl)
+{
+#if 1
+	int32_t index = 0;
+	struct msm_sensor_power_setting_array *power_setting_array = NULL;
+	struct msm_sensor_power_setting *power_setting = NULL;
+	struct msm_camera_sensor_board_info *data = s_ctrl->sensordata;
+	s_ctrl->stop_setting_valid = 0;
+
+	CDBG("%s:%d\n", __func__, __LINE__);
+	power_setting_array = &s_ctrl->power_setting_array;
+
+	if (s_ctrl->sensor_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+		s_ctrl->sensor_i2c_client->i2c_func_tbl->i2c_util(
+			s_ctrl->sensor_i2c_client, MSM_CCI_RELEASE);
+	}
+
+	for (index = (power_setting_array->size - 1); index >= 0; index--) {
+		CDBG("%s index %d\n", __func__, index);
+		power_setting = &power_setting_array->power_setting[index];
+		CDBG("%s type %d\n", __func__, power_setting->seq_type);
+		switch (power_setting->seq_type) {
+		case SENSOR_CLK:
+			msm_cam_clk_enable(s_ctrl->dev,
+				&s_ctrl->clk_info[0],
+				(struct clk **)&power_setting->data[0],
+				s_ctrl->clk_info_size,
+				0);
+			break;
+		case SENSOR_GPIO:
+			if (power_setting->seq_val >= SENSOR_GPIO_MAX ||
+				!data->gpio_conf->gpio_num_info) {
+				pr_err("%s gpio index %d >= max %d\n", __func__,
+					power_setting->seq_val,
+					SENSOR_GPIO_MAX);
+				continue;
+			}
+			gpio_set_value_cansleep(
+				data->gpio_conf->gpio_num_info->gpio_num
+				[power_setting->seq_val], GPIOF_OUT_INIT_LOW);
+			break;
+		case SENSOR_VREG:
+			if (power_setting->seq_val >= CAM_VREG_MAX) {
+				pr_err("%s vreg index %d >= max %d\n", __func__,
+					power_setting->seq_val,
+					SENSOR_GPIO_MAX);
+				continue;
+			}
+			msm_camera_config_single_vreg(s_ctrl->dev,
+				&data->cam_vreg[power_setting->seq_val],
+				(struct regulator **)&power_setting->data[0],
+				0);
+
+			gpio_set_value_cansleep(GPIO_CAM_DVDD_EN,0); //disable dvdd_en
+			gpio_set_value_cansleep(79,0); //disable vcm
+
+			break;
+		case SENSOR_I2C_MUX:
+			if (data->i2c_conf && data->i2c_conf->use_i2c_mux)
+				imx134_sunny_p8n09c_sensor_disable_i2c_mux(data->i2c_conf);
+			break;
+		default:
+			pr_err("%s error power seq type %d\n", __func__,
+				power_setting->seq_type);
+			break;
+		}
+		if (power_setting->delay > 20) {
+			msleep(power_setting->delay);
+		} else if (power_setting->delay) {
+			usleep_range(power_setting->delay * 1000,
+				(power_setting->delay * 1000) + 1000);
+		}
+	}
+	msm_camera_request_gpio_table(
+		data->gpio_conf->cam_gpio_req_tbl,
+		data->gpio_conf->cam_gpio_req_tbl_size, 0);
+	CDBG("%s exit\n", __func__);
+#endif
+	return 0;
+}
+
+static struct msm_sensor_fn_t imx134_sunny_p8n09c_sensor_func_tbl = {
+	.sensor_config = msm_sensor_config,
+	.sensor_power_up = imx134_sunny_p8n09c_sensor_power_up,
+	.sensor_power_down = imx134_sunny_p8n09c_sensor_power_down,
+	.sensor_match_id = msm_sensor_match_id,
+};
+
+static struct msm_sensor_ctrl_t imx134_sunny_p8n09c_s_ctrl = {
+	.sensor_i2c_client = &imx134_sunny_p8n09c_sensor_i2c_client,
+	.power_setting_array.power_setting = imx134_sunny_p8n09c_power_setting,
+	.power_setting_array.size = ARRAY_SIZE(imx134_sunny_p8n09c_power_setting),
+	.msm_sensor_mutex = &imx134_sunny_p8n09c_mut,
+	.sensor_v4l2_subdev_info = imx134_sunny_p8n09c_subdev_info,
+	.sensor_v4l2_subdev_info_size = ARRAY_SIZE(imx134_sunny_p8n09c_subdev_info),
+	.func_tbl = &imx134_sunny_p8n09c_sensor_func_tbl,
+};
+
+module_init(imx134_sunny_p8n09c_init_module);
+module_exit(imx134_sunny_p8n09c_exit_module);
+MODULE_DESCRIPTION("imx134_sunny_p8n09c");
+MODULE_LICENSE("GPL v2");
-- 
1.7.8.3

