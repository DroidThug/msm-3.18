From 43503df675ab7f622f2eb1c44859df9b3839921f Mon Sep 17 00:00:00 2001
From: lnxbuild <lnxbuild@localhost>
Date: Mon, 4 Nov 2013 16:38:53 +0800
Subject: [PATCH 05/15] FC1: Add LP-sensor intersil isl29044 driver support
 Add als+ps sensor tmd27713&apds9900 driver support
 Support LP-sensor tmd27723 and tmd27713 coexist

Change-Id: I208c9f026427a77bb2e7611d142029ab3a08df6c

Signed-off-by: fsheng <fsheng@codeaurora.org>
---
 arch/arm/boot/dts/msm8610-qrd.dtsi |   35 +-
 arch/arm/configs/msm8610_defconfig |    3 +
 drivers/input/misc/Kconfig         |   23 +
 drivers/input/misc/Makefile        |    3 +
 drivers/input/misc/isl29044.c      | 1149 +++++++++++++++++++++
 drivers/input/misc/tmd27713.c      | 1933 ++++++++++++++++++++++++++++++++++++
 drivers/input/misc/tmd277x.c       | 1527 ++++++++++++++++++++++++++++
 include/linux/i2c/tmd277x.h        |  100 ++
 include/linux/taos_common.h        |   92 ++
 9 files changed, 4864 insertions(+), 1 deletions(-)
 create mode 100644 drivers/input/misc/isl29044.c
 create mode 100644 drivers/input/misc/tmd27713.c
 create mode 100644 drivers/input/misc/tmd277x.c
 create mode 100644 include/linux/i2c/tmd277x.h
 create mode 100644 include/linux/taos_common.h

diff --git a/arch/arm/boot/dts/msm8610-qrd.dtsi b/arch/arm/boot/dts/msm8610-qrd.dtsi
index eae6936..92fbdf8 100644
--- a/arch/arm/boot/dts/msm8610-qrd.dtsi
+++ b/arch/arm/boot/dts/msm8610-qrd.dtsi
@@ -134,6 +134,7 @@
 
 		};
  		};
+
 	};
 
 	gen-vkeys {
@@ -195,7 +196,39 @@
 			lis3dh,negate_x = <0>;
 			lis3dh,negate_y = <0>;
 			lis3dh,negate_z = <1>;
-        };
+		};
+	intersil@44 {
+                       compatible = "intersil,isl29044";
+                       reg = <0x44>;
+                       vdd-supply = <&pm8110_l19>;
+                       vddio-supply = <&pm8110_l6>;
+		};
+
+        tmd2772@39 {
+                       compatible = "tmd2772,tmd2772";
+                       reg = <0x39>;
+                       interrupt-parent = <&msmgpio>;
+                       interrupts = <80 0x2>;
+                       tmd2772,int_gpio = <80>;
+                       tmd2772,proximity_can_wake;
+                       tmd2772,prox_th_min = <900>;
+                       tmd2772,prox_th_max = <1000>;
+                       tmd2772,als_gate = <10>;
+               };
+
+       taos@3A {
+                       compatible = "taos,tmd27713";
+                       reg = <0x3A>;
+                       interrupt-parent = <&msmgpio>;
+                       interrupts = <80 0x2>;
+                       vdd-supply = <&pm8110_l19>;
+                       vddio-supply = <&pm8110_l6>;
+                       taos,real_i2c_addr = <0x39>;
+                       taos,pdrive = <3>;
+                       taos,ppcount = <8>;
+                       taos,irq_gpio = <80>;
+               };
+
 	};
 
 	flashlight {
diff --git a/arch/arm/configs/msm8610_defconfig b/arch/arm/configs/msm8610_defconfig
index 9c32762..ed5332b 100644
--- a/arch/arm/configs/msm8610_defconfig
+++ b/arch/arm/configs/msm8610_defconfig
@@ -278,6 +278,8 @@ CONFIG_MSM_ADSPRPC=y
 CONFIG_I2C=y
 CONFIG_I2C_CHARDEV=y
 CONFIG_I2C_QUP=y
+CONFIG_SENSORS_TMD27723=y
+CONFIG_INTERSIL_ISL29044=y
 CONFIG_INPUT_MPU3050=y
 CONFIG_BMP18X=y
 CONFIG_BMP18X_I2C=y
@@ -500,6 +502,7 @@ CONFIG_PPP_MPPE=y
 CONFIG_N_HDLC=y
 CONFIG_UNIX98_PTYS=y
 # CONFIG_INPUT_KXTJ9 is not set
+CONFIG_TMD27713_PLSENSOR=y
 CONFIG_INPUT_KIONIX_ACCEL=y
 CONFIG_MSM_RPM_RBCPR_STATS_V2_LOG=y
 CONFIG_SENSORS_STK3X1X=y
diff --git a/drivers/input/misc/Kconfig b/drivers/input/misc/Kconfig
index 9168007..d81e057 100644
--- a/drivers/input/misc/Kconfig
+++ b/drivers/input/misc/Kconfig
@@ -712,6 +712,12 @@ config SENSORS_STK3X1X
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called stk3x1x.
+config TMD27713_PLSENSOR
+   tristate "TAOS tmd27713 P/L senosr"
+   depends on I2C=y
+
+   help
+       This option enables support for the TAOS tmd27713 P/L sensor.
 
 config SENSORS_CAPELLA_CM36283
 	tristate "CM36283 proximity and light sensor"
@@ -723,4 +729,21 @@ config SENSORS_CAPELLA_CM36283
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called CM36283.
+
+config SENSORS_TMD27723
+       tristate "TAOS TMD27723 proximity and ambient light sensor"
+       depends on I2C
+       default n
+       help
+         If you say yes here you get support for the TAOS tmd27723,
+         proximity and ambient light sensors.
+         This driver can also be built as a module.  If so, the module
+         will be called tmd277x.
+
+config INTERSIL_ISL29044
+       tristate "INTERSIL P/L sensor"
+       depends on I2C
+       help
+         This option enables support for the INTERSIL ISL29044 P/L sensor.
+
 endif
diff --git a/drivers/input/misc/Makefile b/drivers/input/misc/Makefile
index 34de441..80b6a1d 100644
--- a/drivers/input/misc/Makefile
+++ b/drivers/input/misc/Makefile
@@ -66,4 +66,7 @@ obj-$(CONFIG_BMP18X_I2C)		+= bmp18x-i2c.o
 obj-$(CONFIG_SENSORS_MMA8X5X)	  	+= mma8x5x.o
 obj-$(CONFIG_SENSORS_STK3X1X)		+= stk3x1x.o
 obj-$(CONFIG_SENSORS_CAPELLA_CM36283)	+= cm36283.o
+obj-$(CONFIG_TMD27713_PLSENSOR)         += tmd27713.o
+obj-$(CONFIG_SENSORS_TMD27723)          += tmd277x.o
+obj-$(CONFIG_INTERSIL_ISL29044)         += isl29044.o
 obj-$(CONFIG_INPUT_KIONIX_ACCEL)       += kionix_accel.o
diff --git a/drivers/input/misc/isl29044.c b/drivers/input/misc/isl29044.c
new file mode 100644
index 0000000..0885b9e
--- /dev/null
+++ b/drivers/input/misc/isl29044.c
@@ -0,0 +1,1149 @@
+/******************************************************************************
+ * isl29044.h - Linux kernel module for Intersil isl29044 ambient light sensor
+ *				and proximity sensor
+ *
+ * Copyright 2008-2012 Intersil Inc..
+ *
+ * DESCRIPTION:
+ *	- This is the linux driver for isl29044.
+ *		Kernel version 3.0.8
+ *
+ * modification history
+ * --------------------
+ * v1.0   2010/04/06, Shouxian Chen(Simon Chen) create this file
+ * v1.1   2012/06/05, Shouxian Chen(Simon Chen) modified for Android 4.0 and
+ *			linux 3.0.8
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ ******************************************************************************/
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/idr.h>
+#include <linux/fs.h>
+#include <linux/timer.h>
+#include <linux/sched.h>
+#include <linux/seq_file.h>
+#include <asm/io.h>
+#include <linux/ioctl.h>
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <asm/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/pm.h>
+#include <linux/regulator/consumer.h>
+
+#define ISL29044_ADDR	0x44
+#define	DEVICE_NAME		"isl29044"
+#define	DRIVER_VERSION	"1.1"
+
+#define ALS_EN_MSK		(1 << 0)
+#define PS_EN_MSK		(1 << 1)
+
+#define PS_POLL_TIME	100	 	/* unit is ms */
+
+/* Each client has this additional data */
+struct isl29044_data_t {
+	struct i2c_client* client;
+	u8 als_pwr_status;
+	u8 ps_pwr_status;
+	u8 ps_led_drv_cur;	/* led driver current, 0: 110mA, 1: 220mA */
+	u8 als_range;		/* als range, 0: 125 Lux, 1: 2000Lux */
+	u8 als_mode;		/* als mode, 0: Visible light, 1: IR light */
+	u8 ps_lt;			/* ps low limit */
+	u8 ps_ht;			/* ps high limit */
+	int poll_delay;		/* poll delay set by hal */
+	u8 show_als_raw;	/* show als raw data flag, used for debug */
+	u8 show_ps_raw;	/* show als raw data flag, used for debug */
+	struct timer_list als_timer;	/* als poll timer */
+	struct timer_list ps_timer;	/* ps poll timer */
+	spinlock_t als_timer_lock;
+	spinlock_t ps_timer_lock;
+	struct work_struct als_work;
+	struct work_struct ps_work;
+	struct input_dev *als_input_dev;
+	struct input_dev *ps_input_dev;
+	int last_ps;
+	u8 als_range_using;		/* the als range using now */
+	u8 als_pwr_before_suspend;
+	u8 ps_pwr_before_suspend;
+};
+
+/* Do not scan isl29028 automatic */
+static const unsigned short normal_i2c[] = {ISL29044_ADDR, I2C_CLIENT_END };
+
+/* data struct for isl29044 device */
+struct isl29044_data_t	isl29044_data = {
+	.client = NULL,
+	.als_pwr_status = 0,
+	.ps_pwr_status = 0,
+	.als_input_dev = NULL,
+	.ps_input_dev = NULL
+};
+
+static void do_als_timer(unsigned long arg)
+{
+	struct isl29044_data_t *dev_dat;
+
+	dev_dat = (struct isl29044_data_t *)arg;
+
+	/* timer handler is atomic context, so don't need sinp_lock() */
+	//spin_lock(&dev_dat->als_timer);
+	if(dev_dat->als_pwr_status == 0)
+	{
+		//spin_unlock(&dev_dat->als_timer);
+		return ;
+	}
+	//spin_unlock(&dev_dat->als_timer);
+
+	/* start a work queue, I cannot do i2c oepration in timer context for
+	   this context is atomic and i2c function maybe sleep. */
+	schedule_work(&dev_dat->als_work);
+}
+
+static void do_ps_timer(unsigned long arg)
+{
+	struct isl29044_data_t *dev_dat;
+
+	dev_dat = (struct isl29044_data_t *)arg;
+
+	if(dev_dat->ps_pwr_status == 0)
+	{
+		return ;
+	}
+
+	/* start a work queue, I cannot do i2c oepration in timer context for
+	   this context is atomic and i2c function maybe sleep. */
+	schedule_work(&dev_dat->ps_work);
+}
+
+static void do_als_work(struct work_struct *work)
+{
+	struct isl29044_data_t *dev_dat;
+	int ret;
+	static int als_dat;
+	u8 show_raw_dat;
+	int lux;
+	u8 als_range;
+
+	dev_dat = container_of(work, struct isl29044_data_t, als_work);
+
+	spin_lock(&dev_dat->ps_timer_lock);
+	show_raw_dat = dev_dat->show_als_raw;
+	spin_unlock(&dev_dat->ps_timer_lock);
+
+	als_range = dev_dat->als_range_using;
+
+	ret = i2c_smbus_read_byte_data(dev_dat->client, 0x09);
+	if(ret < 0) goto err_rd;
+	als_dat = (u8)ret;
+
+	ret = i2c_smbus_read_byte_data(dev_dat->client, 0x0a);
+	if(ret < 0) goto err_rd;
+	als_dat = als_dat + ( ((u8)ret & 0x0f) << 8 );
+	if(als_range)
+	{
+		lux = (als_dat * 2000) / 4096;
+	}
+	else
+	{
+		lux = (als_dat * 125) / 4096;
+	}
+
+	input_report_abs(dev_dat->als_input_dev, ABS_MISC, lux);
+	input_sync(dev_dat->als_input_dev);
+	if(show_raw_dat)
+	{
+		printk(KERN_INFO "now als raw data is = %d, LUX = %d\n", als_dat, lux);
+	}
+
+	/* restart timer */
+	spin_lock(&dev_dat->als_timer_lock);
+	if(dev_dat->als_pwr_status == 0)
+	{
+		spin_unlock(&dev_dat->als_timer_lock);
+		return ;
+	}
+	dev_dat->als_timer.expires = jiffies + (HZ * dev_dat->poll_delay) / 1000;
+	spin_unlock(&dev_dat->als_timer_lock);
+	add_timer(&dev_dat->als_timer);
+
+	return ;
+
+err_rd:
+	printk(KERN_ERR "Read ps sensor error, ret = %d\n", ret);
+	return ;
+}
+
+static void do_ps_work(struct work_struct *work)
+{
+	struct isl29044_data_t *dev_dat;
+	int last_ps;
+	int ret;
+	u8 show_raw_dat;
+
+	dev_dat = container_of(work, struct isl29044_data_t, ps_work);
+
+	spin_lock(&dev_dat->ps_timer_lock);
+	show_raw_dat = dev_dat->show_ps_raw;
+	spin_unlock(&dev_dat->ps_timer_lock);
+
+	ret = i2c_smbus_read_byte_data(dev_dat->client, 0x02);
+	if(ret < 0) goto err_rd;
+
+	last_ps = dev_dat->last_ps;
+	dev_dat->last_ps = (ret & 0x80) ? 0 : 1;
+
+	if(show_raw_dat)
+	{
+		ret = i2c_smbus_read_byte_data(dev_dat->client, 0x08);
+		if(ret < 0) goto err_rd;
+		printk(KERN_INFO "ps raw data = %d\n", ret);
+	}
+
+	if(last_ps != dev_dat->last_ps)
+	{
+		input_report_abs(dev_dat->ps_input_dev, ABS_DISTANCE, dev_dat->last_ps);
+		input_sync(dev_dat->ps_input_dev);
+		if(show_raw_dat)
+		{
+			printk(KERN_INFO "ps status changed, now = %d\n",dev_dat->last_ps);
+		}
+	}
+
+	/* restart timer */
+	spin_lock(&dev_dat->ps_timer_lock);
+	if(dev_dat->ps_pwr_status == 0)
+	{
+		spin_unlock(&dev_dat->ps_timer_lock);
+		return ;
+	}
+	dev_dat->ps_timer.expires = jiffies + (HZ * PS_POLL_TIME) / 1000;
+	spin_unlock(&dev_dat->ps_timer_lock);
+	add_timer(&dev_dat->ps_timer);
+
+	return ;
+
+err_rd:
+	printk(KERN_ERR "Read als sensor error, ret = %d\n", ret);
+	return ;
+}
+
+/* enable to run als */
+static int set_sensor_reg(struct isl29044_data_t *dev_dat)
+{
+	u8 reg_dat[5];
+	int i, ret;
+
+	reg_dat[2] = 0x22;
+	reg_dat[3] = dev_dat->ps_lt;
+	reg_dat[4] = dev_dat->ps_ht;
+
+	reg_dat[1] = 0x50;	/* set ps sleep time to 50ms */
+	spin_lock(&dev_dat->als_timer_lock);
+	if(dev_dat->als_pwr_status) reg_dat[1] |= 0x04;
+	spin_unlock(&dev_dat->als_timer_lock);
+
+	spin_lock(&dev_dat->ps_timer_lock);
+	if(dev_dat->ps_pwr_status) reg_dat[1] |= 0x80;
+	spin_unlock(&dev_dat->ps_timer_lock);
+
+	if(dev_dat->als_mode) reg_dat[1] |= 0x01;
+	if(dev_dat->als_range) reg_dat[1] |= 0x02;
+	if(dev_dat->ps_led_drv_cur) reg_dat[1] |= 0x08;
+
+	for(i = 2 ; i <= 4; i++)
+	{
+		ret = i2c_smbus_write_byte_data(dev_dat->client, i, reg_dat[i]);
+		if(ret < 0) return ret;
+	}
+
+	ret = i2c_smbus_write_byte_data(dev_dat->client, 0x01, reg_dat[1]);
+	if(ret < 0) return ret;
+
+	return 0;
+}
+
+/* set power status */
+static int set_als_pwr_st(u8 state, struct isl29044_data_t *dat)
+{
+	int ret = 0;
+
+	if(state)
+	{
+		spin_lock(&dat->als_timer_lock);
+		if(dat->als_pwr_status)
+		{
+			spin_unlock(&dat->als_timer_lock);
+			return ret;
+		}
+		dat->als_pwr_status = 1;
+		spin_unlock(&dat->als_timer_lock);
+		ret = set_sensor_reg(dat);
+		if(ret < 0)
+		{
+			printk(KERN_ERR "set light sensor reg error, ret = %d\n", ret);
+			return ret;
+		}
+
+		/* start timer */
+		dat->als_timer.function = &do_als_timer;
+		dat->als_timer.data = (unsigned long)dat;
+		spin_lock(&dat->als_timer_lock);
+		dat->als_timer.expires = jiffies + (HZ * dat->poll_delay) / 1000;
+		spin_unlock(&dat->als_timer_lock);
+
+		dat->als_range_using = dat->als_range;
+		add_timer(&dat->als_timer);
+	}
+	else
+	{
+		spin_lock(&dat->als_timer_lock);
+		if(dat->als_pwr_status == 0)
+		{
+			spin_unlock(&dat->als_timer_lock);
+			return ret;
+		}
+		dat->als_pwr_status = 0;
+		spin_unlock(&dat->als_timer_lock);
+		ret = set_sensor_reg(dat);
+
+		/* delete timer */
+		del_timer_sync(&dat->als_timer);
+	}
+
+	return ret;
+}
+
+static int set_ps_pwr_st(u8 state, struct isl29044_data_t *dat)
+{
+	int ret = 0;
+
+	if(state)
+	{
+		spin_lock(&dat->ps_timer_lock);
+		if(dat->ps_pwr_status)
+		{
+			spin_unlock(&dat->ps_timer_lock);
+			return ret;
+		}
+		dat->ps_pwr_status = 1;
+		spin_unlock(&dat->ps_timer_lock);
+
+		dat->last_ps = -1;
+		ret = set_sensor_reg(dat);
+		if(ret < 0)
+		{
+			printk(KERN_ERR "set proximity sensor reg error, ret = %d\n", ret);
+			return ret;
+		}
+
+		/* start timer */
+		dat->ps_timer.function = &do_ps_timer;
+		dat->ps_timer.data = (unsigned long)dat;
+		dat->ps_timer.expires = jiffies + (HZ * PS_POLL_TIME) / 1000;
+		add_timer(&dat->ps_timer);
+	}
+	else
+	{
+		spin_lock(&dat->ps_timer_lock);
+		if(dat->ps_pwr_status == 0)
+		{
+			spin_unlock(&dat->ps_timer_lock);
+			return ret;
+		}
+		dat->ps_pwr_status = 0;
+		spin_unlock(&dat->ps_timer_lock);
+
+		ret = set_sensor_reg(dat);
+
+		/* delete timer */
+		del_timer_sync(&dat->ps_timer);
+	}
+
+	return ret;
+}
+
+/* device attribute */
+/* enable als attribute */
+static ssize_t show_enable_als_sensor(struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	struct isl29044_data_t *dat;
+	u8 pwr_status;
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+	spin_lock(&dat->als_timer_lock);
+	pwr_status = dat->als_pwr_status;
+	spin_unlock(&dat->als_timer_lock);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", pwr_status);
+}
+static ssize_t store_enable_als_sensor(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct isl29044_data_t *dat;
+	ssize_t ret;
+	unsigned long val;
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+
+	val = simple_strtoul(buf, NULL, 10);
+	ret = set_als_pwr_st(val, dat);
+
+	if(ret == 0) ret = count;
+	return ret;
+}
+static DEVICE_ATTR(enable_als_sensor, S_IWUGO|S_IRUGO, show_enable_als_sensor,
+	store_enable_als_sensor);
+
+/* enable ps attribute */
+static ssize_t show_enable_ps_sensor(struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	struct isl29044_data_t *dat;
+	u8 pwr_status;
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+	spin_lock(&dat->ps_timer_lock);
+	pwr_status = dat->ps_pwr_status;
+	spin_unlock(&dat->ps_timer_lock);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", pwr_status);
+}
+static ssize_t store_enable_ps_sensor(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct isl29044_data_t *dat;
+	ssize_t ret;
+	unsigned long val;
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+
+	val = simple_strtoul(buf, NULL, 10);
+	ret = set_ps_pwr_st(val, dat);
+
+	if(ret == 0) ret = count;
+	return ret;
+}
+static DEVICE_ATTR(enable_ps_sensor, S_IWUGO|S_IRUGO, show_enable_ps_sensor,
+	store_enable_ps_sensor);
+
+/* ps led driver current attribute */
+static ssize_t show_ps_led_drv(struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	struct isl29044_data_t *dat;
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+	return snprintf(buf, PAGE_SIZE, "%d\n", dat->ps_led_drv_cur);
+}
+static ssize_t store_ps_led_drv(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct isl29044_data_t *dat;
+	int val;
+
+	if(sscanf(buf, "%d", &val) != 1)
+	{
+		return -EINVAL;
+	}
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+	if(val) dat->ps_led_drv_cur = 1;
+	else dat->ps_led_drv_cur = 0;
+
+	return count;
+}
+static DEVICE_ATTR(ps_led_driver_current, S_IWUGO|S_IRUGO, show_ps_led_drv,
+	store_ps_led_drv);
+
+/* als range attribute */
+static ssize_t show_als_range(struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	struct isl29044_data_t *dat;
+	u8 range;
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+	spin_lock(&dat->als_timer_lock);
+	range = dat->als_range;
+	spin_unlock(&dat->als_timer_lock);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", range);
+}
+static ssize_t store_als_range(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct isl29044_data_t *dat;
+	int val;
+
+	if(sscanf(buf, "%d", &val) != 1)
+	{
+		return -EINVAL;
+	}
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+
+	spin_lock(&dat->als_timer_lock);
+	if(val) dat->als_range = 1;
+	else dat->als_range = 0;
+	spin_unlock(&dat->als_timer_lock);
+
+	return count;
+}
+static DEVICE_ATTR(als_range, S_IWUGO|S_IRUGO, show_als_range, store_als_range);
+
+/* als mode attribute */
+static ssize_t show_als_mode(struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	struct isl29044_data_t *dat;
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+	return snprintf(buf, PAGE_SIZE, "%d\n", dat->als_mode);
+}
+static ssize_t store_als_mode(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct isl29044_data_t *dat;
+	int val;
+
+	if(sscanf(buf, "%d", &val) != 1)
+	{
+		return -EINVAL;
+	}
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+	if(val) dat->als_mode = 1;
+	else dat->als_mode = 0;
+
+	return count;
+}
+static DEVICE_ATTR(als_mode, S_IWUGO|S_IRUGO, show_als_mode, store_als_mode);
+
+/* ps limit range attribute */
+static ssize_t show_ps_limit(struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	struct isl29044_data_t *dat;
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+	return snprintf(buf, PAGE_SIZE, "%d %d\n", dat->ps_lt, dat->ps_ht);
+}
+static ssize_t store_ps_limit(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct isl29044_data_t *dat;
+	int lt, ht;
+
+	if(sscanf(buf, "%d %d", &lt, &ht) != 2)
+	{
+		return -EINVAL;
+	}
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+
+	if(lt > 255) dat->ps_lt = 255;
+	else if(lt < 0) dat->ps_lt = 0;
+	else  dat->ps_lt = lt;
+
+	if(ht > 255) dat->ps_ht = 255;
+	else if(ht < 0) dat->ps_ht = 0;
+	else  dat->ps_ht = ht;
+
+	return count;
+}
+static DEVICE_ATTR(ps_limit, S_IWUGO|S_IRUGO, show_ps_limit, store_ps_limit);
+
+/* poll delay attribute */
+static ssize_t show_poll_delay (struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	struct isl29044_data_t *dat;
+	int delay;
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+	spin_lock(&dat->als_timer_lock);
+	delay = dat->poll_delay;
+	spin_unlock(&dat->als_timer_lock);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", delay);
+}
+static ssize_t store_poll_delay (struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct isl29044_data_t *dat;
+	unsigned long ns;
+	int delay;
+
+	if(sscanf(buf, "%ld", &ns) != 1)
+	{
+		return -EINVAL;
+	}
+	//printk("ns=%ld\n",ns);
+	delay = ns / 1000 / 1000;
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+
+	spin_lock(&dat->als_timer_lock);
+	if(delay  < 120) dat->poll_delay = 120;
+	else if(delay > 65535) dat->poll_delay = 65535;
+	else dat->poll_delay = delay;
+	spin_unlock(&dat->als_timer_lock);
+
+	return count;
+}
+static DEVICE_ATTR(poll_delay, S_IWUGO|S_IRUGO, show_poll_delay,
+	store_poll_delay);
+
+/* show als raw data attribute */
+static ssize_t show_als_show_raw (struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	struct isl29044_data_t *dat;
+	u8 flag;
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+	spin_lock(&dat->als_timer_lock);
+	flag = dat->show_als_raw;
+	spin_unlock(&dat->als_timer_lock);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", flag);
+}
+static ssize_t store_als_show_raw (struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct isl29044_data_t *dat;
+	int flag;
+
+	if(sscanf(buf, "%d", &flag) != 1)
+	{
+		return -EINVAL;
+	}
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+
+	spin_lock(&dat->als_timer_lock);
+	if(flag == 0) dat->show_als_raw = 0;
+	else dat->show_als_raw = 1;
+	spin_unlock(&dat->als_timer_lock);
+
+	return count;
+}
+static DEVICE_ATTR(als_show_raw, S_IWUGO|S_IRUGO, show_als_show_raw,
+	store_als_show_raw);
+
+
+/* show ps raw data attribute */
+static ssize_t show_ps_show_raw (struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	struct isl29044_data_t *dat;
+	u8 flag;
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+	spin_lock(&dat->als_timer_lock);
+	flag = dat->show_ps_raw;
+	spin_unlock(&dat->als_timer_lock);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", flag);
+}
+static ssize_t store_ps_show_raw (struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct isl29044_data_t *dat;
+	int flag;
+
+	if(sscanf(buf, "%d", &flag) != 1)
+	{
+		return -EINVAL;
+	}
+
+	dat = (struct isl29044_data_t *)dev->platform_data;
+
+	spin_lock(&dat->als_timer_lock);
+	if(flag == 0) dat->show_ps_raw = 0;
+	else dat->show_ps_raw = 1;
+	spin_unlock(&dat->als_timer_lock);
+
+	return count;
+}
+static DEVICE_ATTR(ps_show_raw, S_IWUGO|S_IRUGO, show_ps_show_raw,
+	store_ps_show_raw);
+
+static struct attribute *als_attr[] = {
+	&dev_attr_enable_als_sensor.attr,
+	&dev_attr_als_range.attr,
+	&dev_attr_als_mode.attr,
+	&dev_attr_poll_delay.attr,
+	&dev_attr_als_show_raw.attr,
+	NULL
+};
+
+static struct attribute_group als_attr_grp = {
+//	.name = "light sensor",
+	.attrs = als_attr
+};
+
+static struct attribute *ps_attr[] = {
+	&dev_attr_enable_ps_sensor.attr,
+	&dev_attr_ps_led_driver_current.attr,
+	&dev_attr_ps_limit.attr,
+	&dev_attr_ps_show_raw.attr,
+	NULL
+};
+
+static struct attribute_group ps_attr_grp = {
+//	.name = "proximity sensor",
+	.attrs = ps_attr
+};
+
+
+/* initial and register a input device for sensor */
+static int init_input_dev(struct isl29044_data_t *dev_dat)
+{
+	int err;
+	struct input_dev *als_dev;
+	struct input_dev *ps_dev;
+
+	als_dev = input_allocate_device();
+	if (!als_dev)
+	{
+		return -ENOMEM;
+	}
+
+	ps_dev = input_allocate_device();
+	if (!ps_dev)
+	{
+		err = -ENOMEM;
+		goto err_free_als;
+	}
+
+	als_dev->name = "lightsensor-level";
+	als_dev->id.bustype = BUS_I2C;
+	als_dev->id.vendor  = 0x0001;
+	als_dev->id.product = 0x0001;
+	als_dev->id.version = 0x0100;
+	als_dev->evbit[0] = BIT_MASK(EV_ABS);
+	als_dev->absbit[BIT_WORD(ABS_MISC)] |= BIT_MASK(ABS_MISC);
+	als_dev->dev.platform_data = &isl29044_data;
+	input_set_abs_params(als_dev, ABS_MISC, 0, 2000, 0, 0);
+
+	ps_dev->name = "proximity";
+	ps_dev->id.bustype = BUS_I2C;
+	ps_dev->id.vendor  = 0x0001;
+	ps_dev->id.product = 0x0002;
+	ps_dev->id.version = 0x0100;
+	ps_dev->evbit[0] = BIT_MASK(EV_ABS);
+	ps_dev->absbit[BIT_WORD(ABS_DISTANCE)] |= BIT_MASK(ABS_DISTANCE);
+	ps_dev->dev.platform_data = &isl29044_data;
+	input_set_abs_params(ps_dev, ABS_DISTANCE, 0, 1, 0, 0);
+
+	err = input_register_device(als_dev);
+	if (err)
+	{
+		goto err_free_ps;
+	}
+
+	err = input_register_device(ps_dev);
+	if (err)
+	{
+		goto err_free_ps;
+	}
+
+#if 0
+	/* register device attribute */
+	err = device_create_file(&als_dev->dev, &dev_attr_enable_als_sensor);
+	if (err) goto err_free_ps;
+
+	err = device_create_file(&ps_dev->dev, &dev_attr_enable_ps_sensor);
+	if (err) goto err_rm_als_en_attr;
+
+	err = device_create_file(&ps_dev->dev, &dev_attr_ps_led_driver_current);
+	if (err) goto err_rm_ps_en_attr;
+
+	err = device_create_file(&als_dev->dev, &dev_attr_als_range);
+	if (err) goto err_rm_ps_led_attr;
+
+	err = device_create_file(&als_dev->dev, &dev_attr_als_mode);
+	if (err) goto err_rm_als_range_attr;
+
+	err = device_create_file(&ps_dev->dev, &dev_attr_ps_limit);
+	if (err) goto err_rm_als_mode_attr;
+
+	err = device_create_file(&als_dev->dev, &dev_attr_poll_delay);
+	if (err) goto err_rm_ps_limit_attr;
+
+	err = device_create_file(&als_dev->dev, &dev_attr_als_show_raw);
+	if (err) goto err_rm_poll_delay_attr;
+
+	err = device_create_file(&ps_dev->dev, &dev_attr_ps_show_raw);
+	if (err) goto err_rm_als_show_raw_attr;
+#endif
+
+	err = sysfs_create_group(&als_dev->dev.kobj, &als_attr_grp);
+	if (err) {
+		dev_err(&als_dev->dev, "isl29044: device create als file failed\n");
+		goto err_free_ps;
+	}
+
+	err = sysfs_create_group(&ps_dev->dev.kobj, &ps_attr_grp);
+	if (err) {
+		dev_err(&ps_dev->dev, "isl29044: device create ps file failed\n");
+		goto err_free_ps;
+	}
+
+	dev_dat->als_input_dev = als_dev;
+	dev_dat->ps_input_dev = ps_dev;
+
+	return 0;
+
+#if 0
+err_rm_als_show_raw_attr:
+	device_remove_file(&als_dev->dev, &dev_attr_als_show_raw);
+err_rm_poll_delay_attr:
+	device_remove_file(&als_dev->dev, &dev_attr_poll_delay);
+err_rm_ps_limit_attr:
+	device_remove_file(&ps_dev->dev, &dev_attr_ps_limit);
+err_rm_als_mode_attr:
+	device_remove_file(&als_dev->dev, &dev_attr_als_mode);
+err_rm_als_range_attr:
+	device_remove_file(&als_dev->dev, &dev_attr_als_range);
+err_rm_ps_led_attr:
+	device_remove_file(&ps_dev->dev, &dev_attr_ps_led_driver_current);
+err_rm_ps_en_attr:
+	device_remove_file(&ps_dev->dev, &dev_attr_enable_ps_sensor);
+err_rm_als_en_attr:
+	device_remove_file(&als_dev->dev, &dev_attr_enable_als_sensor);
+#endif
+
+err_free_ps:
+	input_free_device(ps_dev);
+err_free_als:
+	input_free_device(als_dev);
+
+	return err;
+}
+
+struct sensor_regulator {
+	struct regulator *vreg;
+	const char *name;
+	u32	min_uV;
+	u32	max_uV;
+};
+
+struct sensor_regulator isl29044_acc_vreg[] = {
+	{NULL, "vdd", 1700000, 3600000},
+	{NULL, "vddio", 1700000, 3600000},
+};
+
+static int isl29044_acc_config_regulator(struct isl29044_data_t *acc, bool on)
+{
+	int rc = 0, i;
+	int num_reg = sizeof(isl29044_acc_vreg) / sizeof(struct sensor_regulator);
+
+	if (on) {
+		for (i = 0; i < num_reg; i++) {
+			isl29044_acc_vreg[i].vreg =
+				regulator_get(&acc->client->dev,
+				isl29044_acc_vreg[i].name);
+			if (IS_ERR(isl29044_acc_vreg[i].vreg)) {
+				rc = PTR_ERR(isl29044_acc_vreg[i].vreg);
+				pr_err("%s:regulator get failed rc=%d\n",
+								__func__, rc);
+				isl29044_acc_vreg[i].vreg = NULL;
+				goto error_vdd;
+			}
+
+			if (regulator_count_voltages(
+				isl29044_acc_vreg[i].vreg) > 0) {
+				rc = regulator_set_voltage(
+					isl29044_acc_vreg[i].vreg,
+					isl29044_acc_vreg[i].min_uV,
+					isl29044_acc_vreg[i].max_uV);
+				if (rc) {
+					pr_err("%s: set voltage failed rc=%d\n",
+					__func__, rc);
+					regulator_put(isl29044_acc_vreg[i].vreg);
+					isl29044_acc_vreg[i].vreg = NULL;
+					goto error_vdd;
+				}
+			}
+
+			rc = regulator_enable(isl29044_acc_vreg[i].vreg);
+			if (rc) {
+				pr_err("%s: regulator_enable failed rc =%d\n",
+					__func__, rc);
+				if (regulator_count_voltages(
+					isl29044_acc_vreg[i].vreg) > 0) {
+					regulator_set_voltage(
+						isl29044_acc_vreg[i].vreg, 0,
+						isl29044_acc_vreg[i].max_uV);
+				}
+				regulator_put(isl29044_acc_vreg[i].vreg);
+				isl29044_acc_vreg[i].vreg = NULL;
+				goto error_vdd;
+			}
+		}
+		return rc;
+	} else {
+		i = num_reg;
+	}
+
+error_vdd:
+	while (--i >= 0) {
+		if (!IS_ERR_OR_NULL(isl29044_acc_vreg[i].vreg)) {
+			if (regulator_count_voltages(
+			isl29044_acc_vreg[i].vreg) > 0) {
+				regulator_set_voltage(isl29044_acc_vreg[i].vreg,
+						0, isl29044_acc_vreg[i].max_uV);
+			}
+			regulator_disable(isl29044_acc_vreg[i].vreg);
+			regulator_put(isl29044_acc_vreg[i].vreg);
+			isl29044_acc_vreg[i].vreg = NULL;
+		}
+	}
+	return rc;
+}
+
+/* Return 0 if detection is successful, -ENODEV otherwise */
+static int isl29044_detect(struct i2c_client *client,
+	struct i2c_board_info *info)
+{
+	struct i2c_adapter *adapter = client->adapter;
+
+	printk(KERN_DEBUG "In isl29044_detect()\n");
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WRITE_BYTE_DATA
+				     | I2C_FUNC_SMBUS_READ_BYTE))
+	{
+		printk("I2c adapter don't support ISL29044\n");
+		return -ENODEV;
+	}
+
+	/* probe that if isl29044 is at the i2 address */
+	if (i2c_smbus_xfer(adapter, client->addr, 0,I2C_SMBUS_WRITE,
+		0,I2C_SMBUS_QUICK,NULL) < 0)
+		{
+		printk("I2c smbus don't support ISL29044\n");
+		return -ENODEV;
+}
+	strlcpy(info->type, "isl29044", I2C_NAME_SIZE);
+	printk("%s is found at i2c device address %d\n",
+		info->type, client->addr);
+
+	return 0;
+}
+
+/* isl29044 probed */
+static int isl29044_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	int err, i;
+	u8 reg_dat[8];
+
+	printk(KERN_DEBUG "In isl29044_probe()\n");
+
+	/* initial device data struct */
+	isl29044_data.client = client;
+	isl29044_data.als_pwr_status = 0;
+	isl29044_data.ps_pwr_status = 0;
+	isl29044_data.ps_led_drv_cur = 0;
+	isl29044_data.als_range = 1;
+	isl29044_data.als_mode = 0;
+	isl29044_data.ps_lt = 120;
+	isl29044_data.ps_ht = 150;
+	isl29044_data.poll_delay = 200;
+	isl29044_data.show_als_raw = 0;
+	isl29044_data.show_ps_raw = 0;
+
+	spin_lock_init(&isl29044_data.als_timer_lock);
+	spin_lock_init(&isl29044_data.ps_timer_lock);
+	INIT_WORK(&isl29044_data.als_work, &do_als_work);
+	INIT_WORK(&isl29044_data.ps_work, &do_ps_work);
+	init_timer(&isl29044_data.als_timer);
+	init_timer(&isl29044_data.ps_timer);
+
+	i2c_set_clientdata(client,&isl29044_data);
+	isl29044_acc_config_regulator(&isl29044_data, true);
+	/* initial isl29044 */
+	err = set_sensor_reg(&isl29044_data);
+	if(err < 0) return err;
+
+	/* initial als interrupt limit to low = 0, high = 4095, so als cannot
+	   trigger a interrupt. We use ps interrupt only */
+	reg_dat[5] = 0x00;
+	reg_dat[6] = 0xf0;
+	reg_dat[7] = 0xff;
+	for(i = 5; i <= 7; i++)
+	{
+		err = i2c_smbus_write_byte_data(client, i, reg_dat[i]);
+		if(err < 0) return err;
+	}
+
+	/* Add input device register here */
+	err = init_input_dev(&isl29044_data);
+	if(err < 0)
+	{
+		return err;
+	}
+
+	return err;
+}
+
+static int isl29044_remove(struct i2c_client *client)
+{
+	struct input_dev *als_dev;
+	struct input_dev *ps_dev;
+
+	printk(KERN_INFO "%s at address %d is removed\n",client->name,client->addr);
+
+	/* clean the isl29044 data struct when isl29044 device remove */
+	isl29044_data.client = NULL;
+	isl29044_data.als_pwr_status = 0;
+	isl29044_data.ps_pwr_status = 0;
+
+	als_dev = isl29044_data.als_input_dev;
+	ps_dev = isl29044_data.ps_input_dev;
+
+#if 0
+	device_remove_file(&ps_dev->dev, &dev_attr_ps_show_raw);
+	device_remove_file(&als_dev->dev, &dev_attr_als_show_raw);
+	device_remove_file(&als_dev->dev, &dev_attr_poll_delay);
+	device_remove_file(&ps_dev->dev, &dev_attr_ps_limit);
+	device_remove_file(&als_dev->dev, &dev_attr_als_mode);
+	device_remove_file(&als_dev->dev, &dev_attr_als_range);
+	device_remove_file(&ps_dev->dev, &dev_attr_ps_led_driver_current);
+	device_remove_file(&als_dev->dev, &dev_attr_enable_als_sensor);
+	device_remove_file(&ps_dev->dev, &dev_attr_enable_ps_sensor);
+#endif
+
+	sysfs_remove_group(&als_dev->dev.kobj, &als_attr_grp);
+	sysfs_remove_group(&ps_dev->dev.kobj, &ps_attr_grp);
+	isl29044_acc_config_regulator(&isl29044_data, false);
+	input_unregister_device(als_dev);
+	input_unregister_device(ps_dev);
+
+	isl29044_data.als_input_dev = NULL;
+	isl29044_data.ps_input_dev = NULL;
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+/* if define power manager, define suspend and resume function */
+static int isl29044_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	struct isl29044_data_t *dat;
+	int ret;
+
+	dat = i2c_get_clientdata(client);
+
+	spin_lock(&dat->als_timer_lock);
+	dat->als_pwr_before_suspend = dat->als_pwr_status;
+	spin_unlock(&dat->als_timer_lock);
+	ret = set_als_pwr_st(0, dat);
+	if(ret < 0) return ret;
+
+	spin_lock(&dat->ps_timer_lock);
+	dat->ps_pwr_before_suspend = dat->ps_pwr_status;
+	spin_unlock(&dat->ps_timer_lock);
+	ret = set_ps_pwr_st(0, dat);
+	if(ret < 0) return ret;
+
+	return 0;
+}
+
+static int isl29044_resume(struct i2c_client *client)
+{
+	struct isl29044_data_t *dat;
+	int ret;
+
+	dat = i2c_get_clientdata(client);
+
+	ret = set_als_pwr_st(dat->als_pwr_before_suspend, dat);
+	if(ret < 0) return ret;
+
+	ret = set_ps_pwr_st(dat->ps_pwr_before_suspend, dat);
+	if(ret < 0) return ret;
+
+	return 0;
+}
+#else
+#define	isl29044_suspend 	NULL
+#define isl29044_resume		NULL
+#endif		/*ifdef CONFIG_PM end*/
+
+static const struct i2c_device_id isl29044_id[] = {
+	{ "isl29044", 0 },
+	{ }
+};
+
+#ifdef CONFIG_OF
+static struct of_device_id intersil_match_table[] = {
+            { .compatible = "intersil,isl29044",},
+            { },
+    };
+#else
+#define intersil_match_table NULL
+#endif
+
+static struct i2c_driver isl29044_driver = {
+	.driver = {
+		.name	= "isl29044",
+		.of_match_table = intersil_match_table,
+	},
+	.probe			= isl29044_probe,
+	.remove			= isl29044_remove,
+	.id_table		= isl29044_id,
+	.detect			= isl29044_detect,
+	.address_list	= normal_i2c,
+	.suspend		= isl29044_suspend,
+	.resume			= isl29044_resume
+};
+
+struct i2c_client *isl29044_client;
+
+static int __init isl29044_init(void)
+{
+	int ret;
+
+	/* register the i2c driver for isl29044 */
+	ret = i2c_add_driver(&isl29044_driver);
+	if(ret < 0) printk(KERN_ERR "Add isl29044 driver error, ret = %d\n", ret);
+	printk(KERN_DEBUG "init isl29044 module\n");
+
+	return ret;
+}
+
+static void __exit isl29044_exit(void)
+{
+	printk(KERN_DEBUG "exit isl29044 module\n");
+	i2c_del_driver(&isl29044_driver);
+}
+
+
+MODULE_AUTHOR("Chen Shouxian");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("isl29044 ambient light sensor driver");
+MODULE_VERSION(DRIVER_VERSION);
+
+module_init(isl29044_init);
+module_exit(isl29044_exit);
diff --git a/drivers/input/misc/tmd27713.c b/drivers/input/misc/tmd27713.c
new file mode 100644
index 0000000..b8fabbc
--- /dev/null
+++ b/drivers/input/misc/tmd27713.c
@@ -0,0 +1,1933 @@
+/********************************************************************************
+* Device driver for monitoring ambient light intensity (lux) and proximity
+* detection for the TAOS TSL2x7x and TMD2x7x family of devices.
+*
+* Copyright (c) 2012, TAOS Corporation.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later vers ion.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA      02110-1301, USA.
+********************************************************************************/
+
+/********************************************************************************
+*										*
+*   File Name:    tmd27713.c							*
+*   Description:   Linux device driver for Taos ambient light and		*
+*   proximity sensors.								*
+   Author:         John Koshi							*
+*   History:	09/16/2009 - Initial creation					*
+*				10/09/2009 - Triton version			*
+*				12/21/2009 - Probe/remove mode			*
+*				02/07/2010 - Add proximity			*
+*										*
+********************************************************************************/
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/hwmon.h>
+#include <linux/timer.h>
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <asm/delay.h>
+#include <linux/taos_common.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <mach/gpio.h>
+#include <linux/poll.h>
+#include <linux/wakelock.h>
+#include <linux/input.h>
+#include <linux/workqueue.h>
+#include <linux/earlysuspend.h>
+#include	<linux/regulator/consumer.h>
+
+// device name/id/address/counts
+#define TAOS_SENSOR_TMD2771_NAME	"tmd27713"
+#define TAOS_DEVICE_NAME                TAOS_SENSOR_TMD2771_NAME
+#define TAOS_DEVICE_ID                  TAOS_SENSOR_TMD2771_NAME
+#define TAOS_INPUT_NAME			TAOS_SENSOR_TMD2771_NAME
+#define TAOS_SENSOR_INFO		"1.0"
+
+#define TAOS_ID_NAME_SIZE               10
+#define TAOS_MAX_NUM_DEVICES            1
+#define TAOS_MAX_DEVICE_REGS            32
+#define I2C_MAX_ADAPTERS                9
+
+// TRITON register offsets
+#define TAOS_TRITON_CNTRL               0x00
+#define TAOS_TRITON_ALS_TIME            0X01
+#define TAOS_TRITON_PRX_TIME            0x02
+#define TAOS_TRITON_WAIT_TIME           0x03
+#define TAOS_TRITON_ALS_MINTHRESHLO     0X04
+#define TAOS_TRITON_ALS_MINTHRESHHI     0X05
+#define TAOS_TRITON_ALS_MAXTHRESHLO     0X06
+#define TAOS_TRITON_ALS_MAXTHRESHHI     0X07
+#define TAOS_TRITON_PRX_MINTHRESHLO     0X08
+#define TAOS_TRITON_PRX_MINTHRESHHI     0X09
+#define TAOS_TRITON_PRX_MAXTHRESHLO     0X0A
+#define TAOS_TRITON_PRX_MAXTHRESHHI     0X0B
+#define TAOS_TRITON_INTERRUPT           0x0C
+#define TAOS_TRITON_PRX_CFG             0x0D
+#define TAOS_TRITON_PRX_COUNT           0x0E
+#define TAOS_TRITON_GAIN                0x0F
+#define TAOS_TRITON_REVID               0x11
+#define TAOS_TRITON_CHIPID              0x12
+#define TAOS_TRITON_STATUS              0x13
+#define TAOS_TRITON_ALS_CHAN0LO         0x14
+#define TAOS_TRITON_ALS_CHAN0HI         0x15
+#define TAOS_TRITON_ALS_CHAN1LO         0x16
+#define TAOS_TRITON_ALS_CHAN1HI         0x17
+#define TAOS_TRITON_PRX_LO              0x18
+#define TAOS_TRITON_PRX_HI              0x19
+#define TAOS_TRITON_TEST_STATUS         0x1F
+
+// Triton cmd reg masks
+#define TAOS_TRITON_CMD_REG		0X80
+#define TAOS_TRITON_CMD_AUTO		0x10
+#define TAOS_TRITON_CMD_BYTE_RW		0x00
+#define TAOS_TRITON_CMD_SPL_FN		0x60
+#define TAOS_TRITON_CMD_PROX_INTCLR	0X05
+#define TAOS_TRITON_CMD_ALS_INTCLR	0X06
+#define TAOS_TRITON_CMD_INTCLR		0X07
+
+// Triton cntrl reg masks
+#define TAOS_TRITON_CNTL_PROX_INT_ENBL	0X20
+#define TAOS_TRITON_CNTL_ALS_INT_ENBL	0X10
+#define TAOS_TRITON_CNTL_WAIT_TMR_ENBL	0X08
+#define TAOS_TRITON_CNTL_PROX_DET_ENBL	0X04
+#define TAOS_TRITON_CNTL_SENS_ENBL	0x0F
+#define TAOS_TRITON_CNTL_ADC_ENBL	0x02
+#define TAOS_TRITON_CNTL_PWRON		0x01
+
+// Triton status reg masks
+#define TAOS_TRITON_STATUS_ADCVALID	0x01
+
+// lux constants
+#define TAOS_MAX_LUX			10000
+#define TAOS_FILTER_DEPTH		3
+
+// forward declarations
+struct taos_data;
+
+static int taos_probe(struct i2c_client *clientp,
+		      const struct i2c_device_id *idp);
+static int taos_remove(struct i2c_client *client);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void taos_early_suspend(struct early_suspend *h);
+static void taos_late_resume(struct early_suspend *h);
+#endif
+static int taos_open(struct inode *inode, struct file *file);
+static int taos_release(struct inode *inode, struct file *file);
+static long taos_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+static int taos_read(struct file *file, char *buf, size_t count, loff_t * ppos);
+static int taos_write(struct file *file, const char *buf, size_t count,
+		loff_t * ppos);
+static loff_t taos_llseek(struct file *file, loff_t offset, int orig);
+static int taos_get_lux(void);
+static int taos_device_name(unsigned char *bufp, char **device_name);
+static int taos_prox_poll(struct taos_prox_info *prxp);
+
+static int taos_als_threshold_set(void);
+static int taos_prox_threshold_set(void);
+static int taos_als_get_data(void);
+
+#define PS_INT_CLR	0
+#define ALS_INT_CLR	1
+static int taos_ps_als_int_clear(int type);
+static int sensor_on(void);
+static int sensor_off(void);
+static int taos_als_calibrate(void);
+static int taos_ps_calibrate(void);
+static int taos_als_power_on(struct taos_data *taos_datap);
+static int taos_als_power_off(struct taos_data *taos_datap);
+static int taos_ps_power_on(struct taos_data *taos_datap);
+static int taos_ps_power_off(struct taos_data *taos_datap);
+
+DECLARE_WAIT_QUEUE_HEAD(waitqueue_read);
+
+static unsigned int ReadEnable = 0;
+struct ReadData {
+	unsigned int data;
+	unsigned int interrupt;
+};
+struct ReadData readdata[2];
+
+// first device number
+static dev_t taos_dev_number;
+
+// class structure for this device
+struct class *taos_class;
+
+// module device table
+static struct i2c_device_id taos_idtable[] = {
+	{TAOS_DEVICE_ID, 0},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, taos_idtable);
+
+// client and device
+struct i2c_client *my_clientp;
+static char pro_buf[4];
+static int mcount = 0;
+static char als_buf[4];
+u16 status = 0;
+static int ALS_ON = 0;
+static int PS_ON = 0;
+
+#ifdef CONFIG_OF
+static struct of_device_id goodix_match_table[] = {
+                { .compatible = "taos,tmd27713",},
+                { },
+        };
+#else
+#define goodix_match_table NULL
+#endif
+// driver definition
+static struct i2c_driver taos_driver = {
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = TAOS_DEVICE_NAME,
+		.of_match_table = goodix_match_table,
+	},
+	.id_table = taos_idtable,
+	.probe = taos_probe,
+	.remove = __devexit_p(taos_remove),
+};
+
+// per-device data
+struct taos_data {
+	struct i2c_client *client;
+	struct cdev cdev;
+	struct input_dev *als_input_dev;
+	struct input_dev *ps_input_dev;
+	struct work_struct work;
+	struct mutex date_lock;
+	char taos_name[TAOS_ID_NAME_SIZE];
+	struct semaphore update_lock;
+	struct wake_lock taos_wake_lock;
+	struct early_suspend early_suspend;
+	int working;
+};
+
+static struct taos_data *taos_datap;
+
+// file operations
+static struct file_operations taos_fops = {
+	.owner = THIS_MODULE,
+	.open = taos_open,
+	.release = taos_release,
+	.read = taos_read,
+	.write = taos_write,
+	.llseek = taos_llseek,
+	.unlocked_ioctl = taos_ioctl,
+};
+
+// device configuration
+struct taos_cfg *taos_cfgp;
+static u32 calibrate_target_param = 300000;
+static u16 als_time_param = 200;
+static u16 scale_factor_param = 1;
+static u16 gain_trim_param = 512;
+static u8 filter_history_param = 3;
+static u8 gain_param = 0;
+
+//static u16 prox_threshold_hi_param = 820;
+//static u16 prox_threshold_lo_param = 550;
+
+static u16 prox_threshold_hi_param = 500;
+static u16 prox_threshold_lo_param = 400;
+
+static u16 als_threshold_hi_param = 3000;
+static u16 als_threshold_lo_param = 10;
+static u8 prox_int_time_param = 0xEE;		//50ms
+static u8 prox_adc_time_param = 0xFF;
+static u8 prox_wait_time_param = 0xEE;
+static u8 prox_intr_filter_param = 0x13;
+static u8 prox_config_param = 0x00;
+static u8 prox_pulse_cnt_param = 0x02;	//set led pulse count
+static u8 prox_gain_param = 0x20;
+
+// prox info
+struct taos_prox_info prox_cal_info[20];
+struct taos_prox_info prox_cur_info;
+struct taos_prox_info *prox_cur_infop = &prox_cur_info;
+static u8 prox_history_hi = 0;
+static u8 prox_history_lo = 0;
+static int prox_on = 0;
+static int device_released = 0;
+static u16 sat_als = 0;
+static u16 sat_prox = 0;
+
+// device reg init values
+u8 taos_triton_reg_init[16] = { 0x00, 0xFF, 0XFF, 0XFF, 0X00, 0X00, 0XFF, 0XFF,
+	0X00, 0X00, 0XFF, 0XFF, 0X00, 0X00, 0X00, 0X00
+};
+
+// lux time scale
+struct time_scale_factor {
+	u16 numerator;
+	u16 denominator;
+	u16 saturation;
+};
+struct time_scale_factor TritonTime = { 1, 0, 0 };
+
+struct time_scale_factor *lux_timep = &TritonTime;
+
+// gain table
+u8 taos_triton_gain_table[] = { 1, 8, 16, 120 };
+
+// lux data
+struct lux_data {
+	u16 ratio;
+	u16 clear;
+	u16 ir;
+};
+
+struct lux_data TritonFN_lux_data[] = {
+	{9830, 8320, 15360},
+	{12452, 10554, 22797},
+	{14746, 6234, 11430},
+	{17695, 3968, 6400},
+	{0, 0, 0}
+};
+
+struct lux_data *lux_tablep = TritonFN_lux_data;
+
+static int lux_history[TAOS_FILTER_DEPTH] = { -ENODATA, -ENODATA, -ENODATA };
+
+
+struct sensor_regulator {
+	struct regulator *vreg;
+	const char *name;
+	u32	min_uV;
+	u32	max_uV;
+};
+
+struct sensor_regulator taos_vreg[] = {
+	{NULL, "vdd", 1700000, 3600000},
+	{NULL, "vddio", 1700000, 3600000},
+};
+
+static int taos_config_regulator(struct taos_data *datap, bool on)
+{
+	int rc = 0, i;
+	int num_reg = sizeof(taos_vreg) / sizeof(struct sensor_regulator);
+
+	if (on) {
+		for (i = 0; i < num_reg; i++) {
+			taos_vreg[i].vreg =
+				regulator_get(&taos_datap->client->dev,
+				taos_vreg[i].name);
+			if (IS_ERR(taos_vreg[i].vreg)) {
+				rc = PTR_ERR(taos_vreg[i].vreg);
+				pr_err("%s:regulator get failed rc=%d\n",
+								__func__, rc);
+				taos_vreg[i].vreg = NULL;
+				goto error_vdd;
+			}
+
+			if (regulator_count_voltages(
+				taos_vreg[i].vreg) > 0) {
+				rc = regulator_set_voltage(
+					taos_vreg[i].vreg,
+					taos_vreg[i].min_uV,
+					taos_vreg[i].max_uV);
+				if (rc) {
+					pr_err("%s: set voltage failed rc=%d\n",
+					__func__, rc);
+					regulator_put(taos_vreg[i].vreg);
+					taos_vreg[i].vreg = NULL;
+					goto error_vdd;
+				}
+			}
+
+			rc = regulator_enable(taos_vreg[i].vreg);
+			if (rc) {
+				pr_err("%s: regulator_enable failed rc =%d\n",
+					__func__, rc);
+				if (regulator_count_voltages(
+					taos_vreg[i].vreg) > 0) {
+					regulator_set_voltage(
+						taos_vreg[i].vreg, 0,
+						taos_vreg[i].max_uV);
+				}
+				regulator_put(taos_vreg[i].vreg);
+				taos_vreg[i].vreg = NULL;
+				goto error_vdd;
+			}
+		}
+		return rc;
+	} else {
+		i = num_reg;
+	}
+
+error_vdd:
+	while (--i >= 0) {
+		if (!IS_ERR_OR_NULL(taos_vreg[i].vreg)) {
+			if (regulator_count_voltages(
+			taos_vreg[i].vreg) > 0) {
+				regulator_set_voltage(taos_vreg[i].vreg,
+						0, taos_vreg[i].max_uV);
+			}
+			regulator_disable(taos_vreg[i].vreg);
+			regulator_put(taos_vreg[i].vreg);
+			taos_vreg[i].vreg = NULL;
+		}
+	}
+	return rc;
+}
+
+
+static int taos_read_byte(struct i2c_client *client, u8 reg)
+{
+	s32 ret;
+
+	reg &= ~TAOS_TRITON_CMD_SPL_FN;
+	reg |= TAOS_TRITON_CMD_REG | TAOS_TRITON_CMD_BYTE_RW;
+
+	ret = i2c_smbus_read_byte_data(client, reg);
+	return ret;
+}
+
+static int taos_write_byte(struct i2c_client *client, u8 reg, u8 data)
+{
+	s32 ret;
+
+	reg &= ~TAOS_TRITON_CMD_SPL_FN;
+	reg |= TAOS_TRITON_CMD_REG | TAOS_TRITON_CMD_BYTE_RW;
+
+	ret = i2c_smbus_write_byte_data(client, reg, data);
+	return (int)ret;
+}
+
+static irqreturn_t taos_irq_handler(int irq, void *dev_id)
+{
+	schedule_work(&taos_datap->work);
+
+	return IRQ_HANDLED;
+}
+
+static int taos_ps_als_int_clear(int type)
+{
+	int ret = 0;
+	u8 cl_irq = 0;
+
+	if (type == PS_INT_CLR)
+		cl_irq = 0x05;
+	else
+		cl_irq = 0x06;
+
+	if ((ret = (i2c_smbus_write_byte(taos_datap->client,
+			(TAOS_TRITON_CMD_REG | TAOS_TRITON_CMD_SPL_FN | cl_irq)))) < 0) {
+				printk(KERN_ERR "TAOS: clear interrupt failed in %s\n",
+		       __func__);
+		return (ret);
+	}
+
+	return ret;
+}
+
+static int taos_get_data(void)
+{
+	int ret = 0;
+
+	if ((status = taos_read_byte(taos_datap->client, TAOS_TRITON_STATUS)) < 0) {
+		printk(KERN_ERR "%s: read the chip status is failed\n",
+		       __func__);
+		return ret;
+	}
+
+	if ((status & 0x01) == 0x01) {
+		ReadEnable = 1;
+		taos_als_threshold_set();
+		taos_als_get_data();
+		taos_ps_als_int_clear(ALS_INT_CLR);
+	}
+	if ((status & 0x20) == 0x20) {
+		ret = taos_prox_threshold_set();
+		if (ret >= 0)
+			ReadEnable = 1;
+		taos_ps_als_int_clear(PS_INT_CLR);
+	}
+
+	return ret;
+}
+
+static void taos_work_func(struct work_struct *work)
+{
+	mutex_lock(&taos_datap->date_lock);
+	taos_get_data();
+	mutex_unlock(&taos_datap->date_lock);
+}
+
+static int taos_als_get_data(void)
+{
+	int ret = 0;
+	u8 reg_val;
+	int lux_val = 0;
+
+	if ((reg_val = taos_read_byte(taos_datap->client, TAOS_TRITON_CNTRL)) < 0) {
+		printk(KERN_ERR "%s: read TAOS_TRITON_CNTRL is failed\n",
+		       __func__);
+		return reg_val;
+	}
+	if ((reg_val & (TAOS_TRITON_CNTL_ADC_ENBL | TAOS_TRITON_CNTL_PWRON)) !=
+	    (TAOS_TRITON_CNTL_ADC_ENBL | TAOS_TRITON_CNTL_PWRON)) {
+		printk("%s:adc and power is disenable\n", __func__);
+		return ret;
+	}
+
+	if ((reg_val = taos_read_byte(taos_datap->client, TAOS_TRITON_STATUS)) < 0) {
+		printk(KERN_ERR "%s: read TAOS_TRITON_STATUS is failed\n",
+		       __func__);
+		return reg_val;
+	}
+	if ((reg_val & TAOS_TRITON_STATUS_ADCVALID) !=
+	    TAOS_TRITON_STATUS_ADCVALID) {
+		printk("%s:read the chip status value is failed\n", __func__);
+		return ret;
+	}
+
+	if ((lux_val = taos_get_lux()) < 0)
+		printk(KERN_ERR
+		       "TAOS: call to taos_get_lux() returned error %d in ioctl als_data\n",
+		       lux_val);
+	input_report_abs(taos_datap->als_input_dev, ABS_MISC, lux_val);
+	input_sync(taos_datap->als_input_dev);
+
+	return ret;
+}
+
+static int taos_als_threshold_set(void)
+{
+	int i, ret = 0;
+	u8 chdata[2];
+	u16 ch0;
+
+	for (i = 0; i < 2; i++) {
+		chdata[i] = taos_read_byte(taos_datap->client,
+				   TAOS_TRITON_ALS_CHAN0LO + i);
+	}
+
+	ch0 = chdata[0] + chdata[1] * 256;
+	als_threshold_hi_param = (12 * ch0) / 10;
+	if (als_threshold_hi_param >= 65535)
+		als_threshold_hi_param = 65535;
+	als_threshold_lo_param = (8 * ch0) / 10;
+	als_buf[0] = als_threshold_lo_param & 0x0ff;
+	als_buf[1] = als_threshold_lo_param >> 8;
+	als_buf[2] = als_threshold_hi_param & 0x0ff;
+	als_buf[3] = als_threshold_hi_param >> 8;
+
+	for (mcount = 0; mcount < 4; mcount++) {
+		if ((ret = taos_write_byte(taos_datap->client,
+				     TAOS_TRITON_ALS_MINTHRESHLO + mcount, als_buf[mcount])) < 0) {
+			printk(KERN_ERR
+			       "TAOS: write als failed in taos als threshold set\n");
+			return (ret);
+		}
+	}
+	return ret;
+}
+
+static int taos_prox_threshold_set(void)
+{
+	int i, ret = 0;
+	u8 chdata[6];
+	u16 proxdata = 0;
+	int data = 0;
+	for (i = 0; i < 6; i++) {
+		chdata[i] = taos_read_byte(taos_datap->client,
+				   TAOS_TRITON_ALS_CHAN0LO + i);
+	}
+	proxdata = chdata[4] | (chdata[5] << 8);
+	if (prox_on || proxdata < taos_cfgp->prox_threshold_lo) {
+/*set prox_threshold_hi = 500*/
+		pro_buf[0] = 0x00;
+		pro_buf[1] = 0x00;
+		pro_buf[2] = 0xF4;
+		pro_buf[3] = 0x01;
+		data = 1;
+		input_report_abs(taos_datap->ps_input_dev, ABS_DISTANCE, data);
+		input_sync(taos_datap->ps_input_dev);
+	} else if (proxdata > taos_cfgp->prox_threshold_hi) {
+/*set prox_threshold_lo = 400*/
+		pro_buf[0] = 0x90;
+		pro_buf[1] = 0x01;
+		pro_buf[2] = 0xff;
+		pro_buf[3] = 0xff;
+		data = 0;
+		input_report_abs(taos_datap->ps_input_dev, ABS_DISTANCE, data);
+		input_sync(taos_datap->ps_input_dev);
+	}
+
+	for (mcount = 0; mcount < 4; mcount++) {
+		if ((ret = taos_write_byte(taos_datap->client,
+				     TAOS_TRITON_PRX_MINTHRESHLO + mcount, pro_buf[mcount])) < 0) {
+			printk(KERN_ERR"%s: wirte the proximity threshold is faild\n",
+			       __func__);
+			return (ret);
+		}
+	}
+
+	prox_on = 0;
+	return ret;
+}
+
+/* ATTR  */
+static ssize_t info_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "Chip: TAOS %s\nVersion: %s\n",
+		       TAOS_SENSOR_TMD2771_NAME, TAOS_SENSOR_INFO);
+}
+
+static DEVICE_ATTR(info, S_IRUGO | S_IWUSR | S_IWGRP | S_IWOTH,
+		   info_show, NULL);
+
+static int fl = 0;
+
+static ssize_t enable_als_store(struct device *dev,
+		 struct device_attribute *attr, const char *buf, size_t count)
+{
+	if (strncmp(buf, "1", 1) == 0) {
+		if (fl == 0) {
+			enable_irq(taos_datap->client->irq);
+			fl = 1;
+		}
+		taos_als_power_on(taos_datap);
+	} else {
+		if (fl == 1) {
+			disable_irq(taos_datap->client->irq);
+			fl = 0;
+		}
+		taos_als_power_off(taos_datap);
+	}
+
+	return count;
+}
+
+static ssize_t enable_als_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", ! !(ALS_ON));
+}
+
+static DEVICE_ATTR(enable_als_sensor, S_IRUGO | S_IWUSR | S_IWGRP | S_IWOTH,
+		   enable_als_show, enable_als_store);
+
+static ssize_t enable_ps_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	if (strncmp(buf, "1", 1) == 0) {
+		if (fl == 0) {
+			enable_irq(taos_datap->client->irq);
+			fl = 1;
+		}
+		sensor_on();
+		taos_ps_calibrate();
+		taos_ps_power_on(taos_datap);
+	} else {
+		if (fl == 1) {
+			disable_irq(taos_datap->client->irq);
+			fl = 0;
+		}
+		taos_ps_power_off(taos_datap);
+		sensor_off();
+	}
+	return count;
+}
+
+static ssize_t enable_ps_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", ! !(PS_ON));
+}
+
+static DEVICE_ATTR(enable_ps_sensor, S_IRUGO | S_IWUSR | S_IWGRP | S_IWOTH,
+		   enable_ps_show, enable_ps_store);
+
+static ssize_t ps_adc_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct taos_prox_info prxp;
+
+	memset(&prxp, 0, sizeof(prxp));
+	taos_prox_poll(&prxp);
+
+	return sprintf(buf, "%d\n", prxp.prox_data);
+}
+
+static DEVICE_ATTR(raw_adc, S_IRUGO, ps_adc_show, NULL);
+
+static ssize_t als_lux_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int lux;
+
+	lux = taos_get_lux();
+
+	return sprintf(buf, "%d\n", lux);
+}
+
+static DEVICE_ATTR(lux_adc, S_IRUGO, als_lux_show, NULL);
+
+static struct attribute *tmd2771_als_attributes[] = {
+	&dev_attr_info.attr,
+	&dev_attr_enable_als_sensor.attr,
+	&dev_attr_lux_adc.attr,
+	NULL
+};
+
+static struct attribute_group tmd2771_als_attribute_group = {
+	.attrs = tmd2771_als_attributes,
+};
+
+static struct attribute *tmd2771_ps_attributes[] = {
+	&dev_attr_info.attr,
+	&dev_attr_enable_ps_sensor.attr,
+	&dev_attr_raw_adc.attr,
+	NULL
+};
+
+static struct attribute_group tmd2771_ps_attribute_group = {
+	.attrs = tmd2771_ps_attributes,
+};
+
+/* ATTR end */
+// driver init
+static int __init taos_init(void)
+{
+	int ret = 0;
+
+	if ((ret = (alloc_chrdev_region(&taos_dev_number, 0,
+			TAOS_MAX_NUM_DEVICES, TAOS_DEVICE_NAME))) < 0) {
+		printk(KERN_ERR
+		       "TAOS: alloc_chrdev_region() failed in taos_init()\n");
+		goto exit_init;
+	}
+	taos_class = class_create(THIS_MODULE, TAOS_DEVICE_NAME);
+	taos_datap = kmalloc(sizeof(struct taos_data), GFP_KERNEL);
+	if (!taos_datap) {
+		printk(KERN_ERR
+		       "TAOS: kmalloc for struct taos_data failed in taos_init()\n");
+		ret = -ENOMEM;
+		goto exit_init;
+	}
+	memset(taos_datap, 0, sizeof(struct taos_data));
+	cdev_init(&taos_datap->cdev, &taos_fops);
+	taos_datap->cdev.owner = THIS_MODULE;
+	if ((ret = (cdev_add(&taos_datap->cdev, taos_dev_number, 1))) < 0) {
+		printk(KERN_ERR "TAOS: cdev_add() failed in taos_init()\n");
+		goto err_taos_datap_kfree;
+	}
+	device_create(taos_class, NULL, MKDEV(MAJOR(taos_dev_number), 0),
+		      &taos_driver, "tmd27713");
+	if ((ret = (i2c_add_driver(&taos_driver))) < 0) {
+		printk(KERN_ERR
+		       "TAOS: i2c_add_driver() failed in taos_init()\n");
+		goto err_taos_datap_kfree;
+	}
+	wake_lock_init(&taos_datap->taos_wake_lock, WAKE_LOCK_SUSPEND,
+		       "taos_wake_lock");
+
+	goto exit_init;
+
+ err_taos_datap_kfree:
+	kfree(taos_datap);
+ exit_init:
+	return ret;
+}
+
+// driver exit
+static void __exit taos_exit(void)
+{
+	if (my_clientp)
+		i2c_unregister_device(my_clientp);
+	i2c_del_driver(&taos_driver);
+	unregister_chrdev_region(taos_dev_number, TAOS_MAX_NUM_DEVICES);
+	device_destroy(taos_class, MKDEV(MAJOR(taos_dev_number), 0));
+	cdev_del(&taos_datap->cdev);
+	class_destroy(taos_class);
+	disable_irq(taos_datap->client->irq);
+	kfree(taos_datap);
+}
+
+static int tmd_parse_dt(struct device *dev,
+				struct tmd2771x_platform_data *tmd_pdata)
+{
+	struct device_node *np = dev->of_node;
+	u32 temp_val;
+	int rc;
+	rc = of_property_read_u32(np, "taos,pdrive", &temp_val);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read min-interval\n");
+		return rc;
+	} else {
+		tmd_pdata->pdrive = (u8)temp_val;
+        printk("wxl pdrive = %d\n",tmd_pdata->pdrive);
+	}
+
+	rc = of_property_read_u32(np, "taos,ppcount", &temp_val);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read init-interval\n");
+		return rc;
+	} else {
+		tmd_pdata->ppcount = (u8)temp_val;
+	}
+
+	rc = of_property_read_u32(np, "taos,irq_gpio", &temp_val);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read axis-map_x\n");
+		return rc;
+	} else {
+		tmd_pdata->irq_gpio = temp_val;
+	}
+
+	rc = of_property_read_u32(np, "taos,real_i2c_addr", &temp_val);
+	if (rc && (rc != -EINVAL)) {
+		tmd_pdata->real_i2c_addr = 0;
+	} else {
+		tmd_pdata->real_i2c_addr = (u16)temp_val;
+	}
+
+	return 0;
+}
+/*
+struct tmd2771x_platform_data tmd_pdata = {
+	.pdrive = 0x03,
+	.ppcount = 0x08,
+	.irq_gpio = 80,
+	.setup_resources = NULL,
+	.release_resources = NULL,
+};
+*/
+// client probe
+static int taos_probe(struct i2c_client *clientp,
+		      const struct i2c_device_id *idp)
+{
+	int ret = 0;
+	int i = 0;
+	unsigned char buf[TAOS_MAX_DEVICE_REGS];
+	char *device_name;
+	struct tmd2771x_platform_data *pdata;
+		unsigned short backup_org_i2c_adr = clientp->addr;
+		printk("==Jensen %s %d\n", __FUNCTION__, __LINE__);
+
+	if (!i2c_check_functionality
+	    (clientp->adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+		printk(KERN_ERR
+		       "TAOS: taos_probe() - i2c smbus byte data functions unsupported\n");
+		return -EOPNOTSUPP;
+	}
+	if (!i2c_check_functionality
+	    (clientp->adapter, I2C_FUNC_SMBUS_WORD_DATA)) {
+		printk(KERN_ERR
+		       "TAOS: taos_probe() - i2c smbus word data functions unsupported\n");
+	}
+	if (!i2c_check_functionality
+	    (clientp->adapter, I2C_FUNC_SMBUS_BLOCK_DATA)) {
+		printk(KERN_ERR
+		       "TAOS: taos_probe() - i2c smbus block data functions unsupported\n");
+	}
+	taos_datap->client = clientp;
+	i2c_set_clientdata(clientp, taos_datap);
+
+
+    pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+        if (!pdata) {
+                    dev_err(&clientp->dev,
+                                        "failed to allocate memory for module data\n");
+                            return -ENOMEM;
+                                }
+
+    if (clientp->dev.of_node) {
+		memset(pdata, 0 , sizeof(*pdata));
+		ret = tmd_parse_dt(&clientp->dev, pdata);
+		if (ret) {
+			dev_err(&clientp->dev,
+				"Unable to parse platfrom data err=%d\n", ret);
+			return ret;
+		}
+    }
+
+	ret = taos_config_regulator(taos_datap, true);
+	if (ret < 0) {
+		dev_err(&taos_datap->client->dev,
+				"power_on failed: %d\n", ret);
+		printk("==Jensen %s %d\n", __FUNCTION__, __LINE__);
+		return ret;
+	}
+
+	
+	INIT_WORK(&(taos_datap->work), taos_work_func);
+	sema_init(&taos_datap->update_lock, 1);
+	mutex_init(&taos_datap->date_lock);
+	taos_datap->als_input_dev = input_allocate_device();
+	if (taos_datap->als_input_dev == NULL) {
+		printk("[tmd27713 als_input_dev] probe error\n");
+		return -ENOMEM;
+	}
+	taos_datap->ps_input_dev = input_allocate_device();
+	if (taos_datap->ps_input_dev == NULL) {
+		printk("[tmd27713 ps_input_dev] probe error\n");
+		return -ENOMEM;
+	}
+
+	taos_datap->als_input_dev->name = "lightsensor-level";
+	taos_datap->ps_input_dev->name = "proximity";
+	taos_datap->als_input_dev->id.bustype = BUS_I2C;
+	set_bit(EV_ABS, taos_datap->als_input_dev->evbit);
+	taos_datap->ps_input_dev->id.bustype = BUS_I2C;
+	set_bit(EV_ABS, taos_datap->ps_input_dev->evbit);
+	input_set_capability(taos_datap->ps_input_dev, EV_ABS, ABS_DISTANCE);
+	input_set_capability(taos_datap->als_input_dev, EV_ABS, ABS_MISC);
+	input_set_abs_params(taos_datap->als_input_dev, ABS_MISC, 0, 10000, 0, 0);
+	input_set_abs_params(taos_datap->ps_input_dev, ABS_DISTANCE, 0, 1, 0, 0);
+
+	//check i2c addr
+    if((pdata->real_i2c_addr != 0) && pdata->real_i2c_addr != clientp->addr)
+    {   
+        pr_info("%s: change i2c addr from 0x%02x to 0x%02x\n", __func__, clientp->addr, pdata->real_i2c_addr);  
+        //we change the addr to the slave's real addr. if probe fail, we don't change the clientp->addr.    
+        clientp->addr = pdata->real_i2c_addr;
+    }
+	
+	for (i = 0; i < TAOS_MAX_DEVICE_REGS; i++) {
+		if ((buf[i] = taos_read_byte(clientp, TAOS_TRITON_CNTRL + i)) < 0) {
+			printk("%s: read the every reg is faild\n", __func__);
+			goto err_unregister_input_dev;
+		}
+	}
+	
+/*compare chip-id*/
+	if ((ret = taos_device_name(buf, &device_name)) == 0) {
+		printk(KERN_ERR
+		       "TAOS: chip id that was read found mismatched by taos_device_name(), in taos_probe()\n");
+		ret = -ENODEV;
+		goto err_chip_id;
+	}
+
+	if (strcmp(device_name, TAOS_DEVICE_ID)) {
+		printk(KERN_ERR
+		       "TAOS: chip id that was read does not match expected id in taos_probe()\n");
+		ret = -ENODEV;
+		goto err_chip_id;
+	} else {
+		pr_debug("TAOS: chip id of %s that was read matches expected id in taos_probe()\n",
+		     device_name);
+	}
+
+	strlcpy(clientp->name, TAOS_DEVICE_ID, I2C_NAME_SIZE);
+	strlcpy(taos_datap->taos_name, TAOS_DEVICE_ID, TAOS_ID_NAME_SIZE);
+
+	ret = input_register_device(taos_datap->als_input_dev);
+	ret = input_register_device(taos_datap->ps_input_dev);
+
+	if (!(taos_cfgp = kmalloc(sizeof(struct taos_cfg), GFP_KERNEL))) {
+		printk(KERN_ERR
+		       "TAOS: kmalloc for struct taos_cfg failed in taos_probe()\n");
+		ret = -ENOMEM;
+		goto err_unregister_input_dev;
+	}
+
+	taos_cfgp->calibrate_target = calibrate_target_param;
+	taos_cfgp->als_time = als_time_param;
+	taos_cfgp->scale_factor = scale_factor_param;
+	taos_cfgp->gain_trim = gain_trim_param;
+	taos_cfgp->filter_history = filter_history_param;
+	taos_cfgp->gain = gain_param;
+	taos_cfgp->als_threshold_hi = als_threshold_hi_param;
+	taos_cfgp->als_threshold_lo = als_threshold_lo_param;
+	taos_cfgp->prox_threshold_hi = prox_threshold_hi_param;
+	taos_cfgp->prox_threshold_lo = prox_threshold_lo_param;
+	taos_cfgp->prox_int_time = prox_int_time_param;
+	taos_cfgp->prox_adc_time = prox_adc_time_param;
+	taos_cfgp->prox_wait_time = prox_wait_time_param;
+	taos_cfgp->prox_intr_filter = prox_intr_filter_param;
+	taos_cfgp->prox_config = prox_config_param;
+	taos_cfgp->prox_pulse_cnt = prox_pulse_cnt_param;
+	taos_cfgp->prox_gain = prox_gain_param;
+	sat_als = (256 - taos_cfgp->prox_int_time) << 10;
+	sat_prox = (256 - taos_cfgp->prox_adc_time) << 10;
+
+	if ((ret = taos_write_byte(taos_datap->client, TAOS_TRITON_CNTRL,
+			     0x00)) < 0) {
+		printk(KERN_ERR "%s: write the chip power down is failed\n",
+		       __func__);
+		goto err_taos_cfgp_kfree;
+	}
+
+	printk("[ tmd27713]clientp->irq = %d\n", clientp->irq);
+
+	ret = gpio_request(pdata->irq_gpio, "taos_irq");
+	if (ret) {
+		printk(KERN_ALERT "%s: gp2ap request gpio failed.\n",
+		       __func__);
+		return ret;
+	}
+	gpio_tlmm_config(GPIO_CFG(pdata->irq_gpio, 0, GPIO_CFG_INPUT,
+				GPIO_CFG_PULL_UP, GPIO_CFG_8MA),
+			GPIO_CFG_ENABLE);
+	ret = request_irq(clientp->irq, taos_irq_handler, IRQ_TYPE_EDGE_FALLING,
+			"taos_irq", taos_datap);
+	printk("[ tmd27713]request_irq ret = %d\n", ret);
+
+	if (ret != 0) {
+		printk("\nrequest tmd27713 irq : %d failed\n", clientp->irq);
+		goto err_taos_cfgp_kfree;
+	}
+
+	printk("request tmd27713 irq : %d succeed\n", clientp->irq);
+	disable_irq(clientp->irq);
+
+	if (taos_datap == NULL) {
+		printk("[tmd27713] taos_datap == NULL\n");
+	}
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	taos_datap->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	taos_datap->early_suspend.suspend = taos_early_suspend;
+	taos_datap->early_suspend.resume = taos_late_resume;
+	register_early_suspend(&taos_datap->early_suspend);
+#endif
+
+	ret = sysfs_create_group(&taos_datap->als_input_dev->dev.kobj,
+			       &tmd2771_als_attribute_group);
+	ret = sysfs_create_group(&taos_datap->ps_input_dev->dev.kobj,
+			       &tmd2771_ps_attribute_group);
+	if (!ret)
+		goto exit;
+
+ err_taos_cfgp_kfree:
+	kfree(taos_cfgp);
+ err_unregister_input_dev:
+	input_unregister_device(taos_datap->als_input_dev);
+	input_unregister_device(taos_datap->ps_input_dev);
+ err_chip_id:
+    clientp->addr = backup_org_i2c_adr;
+ exit:
+	return ret;
+}
+
+// client remove
+static int __devexit taos_remove(struct i2c_client *client)
+{
+	int ret = 0;
+	
+	kfree(taos_cfgp);
+	unregister_early_suspend(&taos_datap->early_suspend);
+	input_unregister_device(taos_datap->als_input_dev);
+	sysfs_remove_group(&taos_datap->als_input_dev->dev.kobj,
+			   &tmd2771_als_attribute_group);
+	input_unregister_device(taos_datap->ps_input_dev);
+	sysfs_remove_group(&taos_datap->ps_input_dev->dev.kobj,
+			   &tmd2771_ps_attribute_group);
+	ret = taos_config_regulator(taos_datap, false);
+	if (ret < 0) {
+		dev_err(&taos_datap->client->dev,
+				"power_on failed: %d\n", ret);
+		printk("==Jensen %s %d\n", __FUNCTION__, __LINE__);
+		return ret;
+	}
+	return 0;
+}
+
+//resume
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static u8 reg_store = 0;
+static void taos_late_resume(struct early_suspend *h)
+{
+	u8 reg_val = 0, reg_cntrl = 0;
+	int ret = -1;
+
+	if ((reg_val = taos_read_byte(taos_datap->client, TAOS_TRITON_CNTRL)) < 0) {
+		printk("TAOS: read byte is failed in resume\n");
+		return;
+	}
+	if (taos_datap->working == 1) {
+		taos_datap->working = 0;
+		reg_cntrl = reg_val | TAOS_TRITON_CNTL_PWRON;
+		if ((ret = taos_write_byte(taos_datap->client, TAOS_TRITON_CNTRL, reg_store)) < 0) {	//reg_cntrl)) < 0) {
+			printk(KERN_ERR
+			       "TAOS: write byte_data failed in ioctl als_off\n");
+			return;
+		}
+	}
+	enable_irq(taos_datap->client->irq);
+}
+
+//suspend
+static void taos_early_suspend(struct early_suspend *h)
+{
+	u8 reg_val = 0;
+	int ret = -1;
+
+	disable_irq(taos_datap->client->irq);
+	taos_datap->working = 1;
+	if ((reg_store = taos_read_byte(taos_datap->client, TAOS_TRITON_CNTRL)) < 0) {
+		printk("TAOS: read byte is failed in suspend\n");
+		return;
+	}
+	if ((ret = taos_write_byte(taos_datap->client, TAOS_TRITON_CNTRL,
+			     reg_val)) < 0) {
+		printk(KERN_ERR "TAOS: write byte failed in taos_suspend\n");
+		return;
+	}
+}
+#endif
+// open
+static int taos_open(struct inode *inode, struct file *file)
+{
+	struct taos_data *taos_datap;
+	int ret = 0;
+
+	device_released = 0;
+	taos_datap = container_of(inode->i_cdev, struct taos_data, cdev);
+	if (strcmp(taos_datap->taos_name, TAOS_DEVICE_ID) != 0) {
+		printk(KERN_ERR
+		       "TAOS: device name incorrect during taos_open(), get %s\n",
+		       taos_datap->taos_name);
+		ret = -ENODEV;
+	}
+	memset(readdata, 0, sizeof(struct ReadData) * 2);
+	enable_irq(taos_datap->client->irq);
+	return (ret);
+}
+
+// release
+static int taos_release(struct inode *inode, struct file *file)
+{
+	struct taos_data *taos_datap;
+	int ret = 0;
+
+	device_released = 1;
+	prox_on = 0;
+	prox_history_hi = 0;
+	prox_history_lo = 0;
+	taos_datap = container_of(inode->i_cdev, struct taos_data, cdev);
+	if (strcmp(taos_datap->taos_name, TAOS_DEVICE_ID) != 0) {
+		printk(KERN_ERR
+		       "TAOS: device name incorrect during taos_release(), get %s\n",
+		       taos_datap->taos_name);
+		ret = -ENODEV;
+	}
+	return (ret);
+}
+
+// read
+static int taos_read(struct file *file, char *buf, size_t count, loff_t * ppos)
+{
+	unsigned long flags;
+	int realmax;
+	int err;
+	if ((!ReadEnable) && (file->f_flags & O_NONBLOCK))
+		return -EAGAIN;
+	local_save_flags(flags);
+	local_irq_disable();
+
+	realmax = 0;
+	if (down_interruptible(&taos_datap->update_lock))
+		return -ERESTARTSYS;
+	if (ReadEnable > 0) {
+		if (sizeof(struct ReadData) * 2 < count)
+			realmax = sizeof(struct ReadData) * 2;
+		else
+			realmax = count;
+		err = copy_to_user(buf, readdata, realmax);
+		if (err)
+			return -EAGAIN;
+		ReadEnable = 0;
+	}
+	up(&taos_datap->update_lock);
+	memset(readdata, 0, sizeof(struct ReadData) * 2);
+	local_irq_restore(flags);
+	return realmax;
+}
+
+// write
+static int taos_write(struct file *file, const char *buf, size_t count,
+		      loff_t * ppos)
+{
+	struct taos_data *taos_datap;
+	u8 i = 0, xfrd = 0, reg = 0;
+	u8 my_buf[TAOS_MAX_DEVICE_REGS];
+	int ret = 0;
+
+	if ((*ppos < 0) || (*ppos >= TAOS_MAX_DEVICE_REGS)
+	    || ((*ppos + count) > TAOS_MAX_DEVICE_REGS)) {
+		printk(KERN_ERR
+		       "TAOS: reg limit check failed in taos_write()\n");
+		return -EINVAL;
+	}
+	reg = (u8) * ppos;
+	if ((ret = copy_from_user(my_buf, buf, count))) {
+		printk(KERN_ERR "TAOS: copy_to_user failed in taos_write()\n");
+		return -ENODATA;
+	}
+	taos_datap =  container_of(file->f_dentry->d_inode->i_cdev,
+					struct taos_data, cdev);
+	while (xfrd < count) {
+		if ((ret = taos_write_byte(taos_datap->client, reg,
+				     my_buf[i++])) < 0) {
+			printk(KERN_ERR
+			       "TAOS: write reg failed in taos_write()\n");
+			return (ret);
+		}
+		reg++;
+		xfrd++;
+	}
+	return ((int)xfrd);
+}
+
+// llseek
+static loff_t taos_llseek(struct file *file, loff_t offset, int orig)
+{
+	int ret = 0;
+	loff_t new_pos = 0;
+
+	if ((offset >= TAOS_MAX_DEVICE_REGS) || (orig < 0) || (orig > 1)) {
+		printk(KERN_ERR
+		       "TAOS: offset param limit or origin limit check failed in taos_llseek()\n");
+		return -EINVAL;
+	}
+	switch (orig) {
+	case 0:
+		new_pos = offset;
+		break;
+	case 1:
+		new_pos = file->f_pos + offset;
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+	if ((new_pos < 0) || (new_pos >= TAOS_MAX_DEVICE_REGS) || (ret < 0)) {
+		printk(KERN_ERR
+		       "TAOS: new offset limit or origin limit check failed in taos_llseek()\n");
+		return -EINVAL;
+	}
+	file->f_pos = new_pos;
+	return new_pos;
+}
+
+static int sensor_on(void)
+{
+	int ret = 0;
+	int i = 0;
+
+	printk("[ tmd27713] < %s >\n", __func__);
+	for (i = 0; i < TAOS_FILTER_DEPTH; i++) {
+		lux_history[i] = -ENODATA;
+	}
+	/*ALS interrupt clear */
+	if ((ret = (i2c_smbus_write_byte
+	      (taos_datap->client,
+	       (TAOS_TRITON_CMD_REG | TAOS_TRITON_CMD_SPL_FN |
+		TAOS_TRITON_CMD_ALS_INTCLR)))) < 0) {
+		printk(KERN_ERR
+		       "TAOS: i2c_smbus_write_byte failed in ioctl als_on\n");
+		return (ret);
+	}
+	if ((ret = taos_write_byte(taos_datap->client,
+			     TAOS_TRITON_ALS_TIME,
+			     taos_cfgp->prox_int_time)) < 0) {
+		printk(KERN_ERR
+		       "TAOS: write als_time failed in ioctl prox_on\n");
+		return (ret);
+	}
+	if ((ret = taos_write_byte(taos_datap->client,
+			     TAOS_TRITON_PRX_TIME,
+			     taos_cfgp->prox_adc_time)) < 0) {
+		printk(KERN_ERR
+		       "TAOS: write prox_time failed in ioctl prox_on\n");
+		return (ret);
+	}
+	if ((ret = taos_write_byte(taos_datap->client,
+			     TAOS_TRITON_WAIT_TIME,
+			     taos_cfgp->prox_wait_time)) < 0) {
+		printk(KERN_ERR
+		       "TAOS: write wait_time failed in ioctl prox_on\n");
+		return (ret);
+	}
+	if ((ret = taos_write_byte(taos_datap->client,
+			     TAOS_TRITON_INTERRUPT,
+			     taos_cfgp->prox_intr_filter)) < 0) {
+		printk(KERN_ERR
+		       "TAOS: write interrupt failed in ioctl prox_on\n");
+		return (ret);
+	}
+	if ((ret = taos_write_byte(taos_datap->client,
+			     TAOS_TRITON_PRX_CFG,
+			     taos_cfgp->prox_config)) < 0) {
+		printk(KERN_ERR
+		       "TAOS: write prox_config failed in ioctl prox_on\n");
+		return (ret);
+	}
+	if ((ret = taos_write_byte(taos_datap->client,
+			     TAOS_TRITON_PRX_CFG,
+			     taos_cfgp->prox_config)) < 0) {
+		printk(KERN_ERR
+		       "TAOS: write prox_config failed in ioctl prox_on\n");
+		return (ret);
+	}
+	if ((ret = taos_write_byte(taos_datap->client,
+			     TAOS_TRITON_PRX_COUNT,
+			     taos_cfgp->prox_pulse_cnt)) < 0) {
+		printk(KERN_ERR
+		       "TAOS: write prox_config failed in ioctl prox_on\n");
+		return (ret);
+	}
+	if ((ret = taos_write_byte(taos_datap->client,
+			     TAOS_TRITON_GAIN, taos_cfgp->prox_gain)) < 0) {
+		printk(KERN_ERR
+		       "TAOS: write prox_config failed in ioctl prox_on\n");
+		return (ret);
+	}
+	if ((ret = taos_write_byte(taos_datap->client,
+			     TAOS_TRITON_CNTRL,
+			     TAOS_TRITON_CNTL_SENS_ENBL)) < 0) {
+		printk(KERN_ERR
+		       "TAOS: write prox_config failed in ioctl prox_on\n");
+		return (ret);
+	}
+	return 0;
+}
+
+static int sensor_off(void)
+{
+	int ret = 0;
+
+	/*turn off */
+	printk(KERN_ERR "TAOS: TAOS_IOCTL_SENSOR_OFF\n");
+	if ((ret = taos_write_byte(taos_datap->client,
+			     TAOS_TRITON_CNTRL, 0x00)) < 0) {
+		printk(KERN_ERR
+		       "TAOS: write sensor_off failed in ioctl prox_on\n");
+		return (ret);
+	}
+	return ret;
+}
+
+static int taos_als_power_on(struct taos_data *taos_datap)
+{
+	int ret = 0, i = 0;
+	u8 itime = 0, reg_val = 0, reg_cntrl = 0;
+
+	for (i = 0; i < TAOS_FILTER_DEPTH; i++)
+		lux_history[i] = -ENODATA;
+
+	/*ALS_INTERUPTER IS CLEAR */
+	if ((ret = (i2c_smbus_write_byte
+	      (taos_datap->client,
+	       (TAOS_TRITON_CMD_REG | TAOS_TRITON_CMD_SPL_FN |
+		TAOS_TRITON_CMD_ALS_INTCLR)))) < 0) {
+		printk(KERN_ERR
+		       "TAOS: i2c_smbus_write_byte failed in ioctl als_on\n");
+		return (ret);
+	}
+
+	itime = (((taos_cfgp->als_time / 50) * 18) - 1);
+	itime = (~itime);
+
+	if ((ret = taos_write_byte(taos_datap->client, TAOS_TRITON_ALS_TIME,
+			     itime)) < -1) {
+		printk(KERN_ERR "%s: write the als time is failed\n", __func__);
+		return ret;
+	}
+
+	if ((ret = taos_write_byte(taos_datap->client, TAOS_TRITON_INTERRUPT,
+			     taos_cfgp->prox_intr_filter)) < 0) {
+		printk(KERN_ERR "%s: write the als time is failed\n", __func__);
+		return ret;
+	}
+
+	if ((reg_val = taos_read_byte(taos_datap->client, TAOS_TRITON_GAIN)) < 0) {
+		printk(KERN_ERR "%s: read the als gain is failed\n", __func__);
+		return ret;
+	}
+
+	reg_val = reg_val & 0xFC;
+	reg_val = reg_val | (taos_cfgp->gain & 0x03);
+
+	if ((ret = taos_write_byte(taos_datap->client, TAOS_TRITON_GAIN,
+			     reg_val)) < 0) {
+		printk(KERN_ERR "%s: write the als gain is failed\n", __func__);
+		return ret;
+	}
+
+	if ((reg_cntrl = taos_read_byte(taos_datap->client, TAOS_TRITON_CNTRL)) < 0) {
+		printk(KERN_ERR
+		       "%s:  taos_read_byte TAOS_TRITON_CNTRL is failed\n",
+		       __func__);
+		return ret;
+	}
+
+	reg_cntrl |= (TAOS_TRITON_CNTL_ADC_ENBL | TAOS_TRITON_CNTL_PWRON |
+							TAOS_TRITON_CNTL_ALS_INT_ENBL);
+	if ((ret = taos_write_byte(taos_datap->client,
+				TAOS_TRITON_CNTRL, reg_cntrl)) < 0) {
+		printk(KERN_ERR "%s: write the als data is failed\n", __func__);
+		return ret;
+	}
+
+	taos_als_threshold_set();
+
+	ALS_ON = 1;
+	return ret;
+}
+
+static int taos_als_power_off(struct taos_data *taos_datap)
+{
+	int ret = 0;
+	u8 reg_val = 0;
+
+	if ((reg_val = taos_read_byte(taos_datap->client, TAOS_TRITON_CNTRL)) < 0) {
+		printk(KERN_ERR "TAOS: read CNTRL failed in ioctl prox_on\n");
+		return ret;
+	}
+	reg_val = reg_val & ~(1 << 1);
+	reg_val = reg_val & ~(1 << 4);
+
+	if ((ret = taos_write_byte(taos_datap->client,
+			     TAOS_TRITON_CNTRL, reg_val)) < 0) {
+		printk(KERN_ERR "TAOS: write CNTRL failed in %s\n", __func__);
+		return (ret);
+	}
+	ALS_ON = 0;
+	return (ret);
+}
+
+static int taos_ps_power_on(struct taos_data *taos_datap)
+{
+	int ret = 0;
+	u8 reg_cntrl = 0;
+
+		taos_write_byte(taos_datap->client, 0x08, taos_cfgp->prox_threshold_lo & 0x0f) ;
+		taos_write_byte(taos_datap->client, 0x09, taos_cfgp->prox_threshold_lo >> 8) ;
+		taos_write_byte(taos_datap->client, 0x0a, taos_cfgp->prox_threshold_hi & 0x0f) ;
+		taos_write_byte(taos_datap->client, 0x0b, taos_cfgp->prox_threshold_hi >> 8) ;
+	prox_on = 1;
+	if ((ret = taos_write_byte(taos_datap->client,
+			     TAOS_TRITON_PRX_TIME,
+			     taos_cfgp->prox_adc_time)) < -1) {
+		printk(KERN_ERR
+		       "%s: write the prox time is failed\n", __func__);
+		return ret;
+	}
+	if ((ret = taos_write_byte(taos_datap->client,
+			     TAOS_TRITON_WAIT_TIME,
+			     taos_cfgp->prox_wait_time)) < -1) {
+		printk(KERN_ERR
+		       "%s: write the wait time is failed\n", __func__);
+		return ret;
+	}
+	if ((ret = taos_write_byte(taos_datap->client,
+			     TAOS_TRITON_INTERRUPT,
+			     taos_cfgp->prox_intr_filter)) < -1) {
+		printk(KERN_ERR
+		       "%s: write the interrupt time is failed\n", __func__);
+		return ret;
+	}
+
+	if ((ret = taos_write_byte(taos_datap->client,
+			     TAOS_TRITON_PRX_CFG,
+			     taos_cfgp->prox_config)) < -1) {
+		printk(KERN_ERR
+		       "%s: write the prox_config is failed\n", __func__);
+		return ret;
+	}
+	if ((ret = taos_write_byte(taos_datap->client,
+			     TAOS_TRITON_PRX_COUNT,
+			     taos_cfgp->prox_pulse_cnt)) < -1) {
+		printk(KERN_ERR
+		       "%s: write the pulse count time is failed\n", __func__);
+		return ret;
+	}
+	if ((ret = taos_write_byte(taos_datap->client,
+			     TAOS_TRITON_GAIN, taos_cfgp->prox_gain)) < -1) {
+		printk(KERN_ERR
+		       "%s: write the gain time is failed\n", __func__);
+		return ret;
+	}
+	if ((reg_cntrl = taos_read_byte(taos_datap->client, TAOS_TRITON_CNTRL)) < 0) {
+		printk(KERN_ERR "TAOS: read CNTRL failed in ioctl prox_on\n");
+		return ret;
+	}
+	reg_cntrl |=
+	    TAOS_TRITON_CNTL_PROX_DET_ENBL |
+	    TAOS_TRITON_CNTL_PWRON |
+	    TAOS_TRITON_CNTL_PROX_INT_ENBL | TAOS_TRITON_CNTL_WAIT_TMR_ENBL;
+	if ((ret = (i2c_smbus_write_byte_data
+	      (taos_datap->client,
+	       (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL), reg_cntrl))) < 0) {
+		printk(KERN_ERR
+		       "TAOS: write reg_cntrl failed in ioctl prox_on\n");
+		return (ret);
+	}
+	taos_prox_threshold_set();
+	PS_ON = 1;
+
+	return ret;
+}
+
+static int taos_ps_power_off(struct taos_data *taos_datap)
+{
+	int ret = 0;
+	u8 reg_val = 0;
+
+	if ((reg_val = taos_read_byte(taos_datap->client, TAOS_TRITON_CNTRL)) < 0) {
+		printk(KERN_ERR "TAOS: read CNTRL failed in ioctl prox_on\n");
+		return ret;
+	}
+	reg_val = reg_val & ~(1 << 2);
+	reg_val = reg_val & ~(1 << 5);
+	if ((ret = taos_write_byte(taos_datap->client,
+			     TAOS_TRITON_CNTRL, reg_val)) < 0) {
+		printk(KERN_ERR "TAOS: write CNTRL failed in %s\n", __func__);
+		return (ret);
+	}
+	PS_ON = 0;
+	if(ALS_ON) {
+		taos_als_power_off(taos_datap);
+		taos_als_power_on(taos_datap);
+	}
+	return ret;
+}
+
+/*ignore the automatic calculation of threshold and set by manual*/
+#define IGNORE_THRESHOLD_CALC
+static int taos_ps_calibrate(void)
+{
+	int ret = 0, i = 0;
+	u8 reg_val = 0, reg_cntrl = 0;
+#ifndef IGNORE_THRESHOLD_CALC
+	int prox_sum = 0, prox_mean = 0, prox_max = 0;
+#endif
+
+	if ((ret = taos_write_byte(taos_datap->client,
+			     TAOS_TRITON_ALS_TIME,
+			     taos_cfgp->prox_int_time)) < -1) {
+		printk(KERN_ERR "%s: write the als time is failed\n", __func__);
+		return ret;
+	}
+	if ((ret = taos_write_byte(taos_datap->client,
+			     TAOS_TRITON_PRX_TIME,
+			     taos_cfgp->prox_adc_time)) < -1) {
+		printk(KERN_ERR
+		       "%s: write the prox time is failed\n", __func__);
+		return ret;
+	}
+	if ((ret = taos_write_byte(taos_datap->client,
+			     TAOS_TRITON_WAIT_TIME,
+			     taos_cfgp->prox_wait_time)) < -1) {
+		printk(KERN_ERR
+		       "%s: write the wait time is failed\n", __func__);
+		return ret;
+	}
+	if ((ret = taos_write_byte(taos_datap->client,
+			     TAOS_TRITON_INTERRUPT,
+			     taos_cfgp->prox_intr_filter)) < -1) {
+		printk(KERN_ERR
+		       "%s: write the interrupt time is failed\n", __func__);
+		return ret;
+	}
+	if ((ret = taos_write_byte(taos_datap->client,
+			     TAOS_TRITON_PRX_CFG,
+			     taos_cfgp->prox_config)) < -1) {
+		printk(KERN_ERR
+		       "%s: write the prox_config is failed\n", __func__);
+		return ret;
+	}
+	if ((ret = taos_write_byte(taos_datap->client,
+			     TAOS_TRITON_PRX_COUNT,
+			     taos_cfgp->prox_pulse_cnt)) < -1) {
+		printk(KERN_ERR
+		       "%s: write the pulse count time is failed\n", __func__);
+		return ret;
+	}
+	if ((ret = taos_write_byte(taos_datap->client,
+			     TAOS_TRITON_GAIN, taos_cfgp->prox_gain)) < -1) {
+		printk(KERN_ERR
+		       "%s: write the gain time is failed\n", __func__);
+		return ret;
+	}
+	if ((reg_val = taos_read_byte(taos_datap->client, TAOS_TRITON_CNTRL)) < 0) {
+		printk(KERN_ERR "TAOS: read CNTRL failed in ioctl prox_on\n");
+		return ret;
+	}
+	reg_cntrl = reg_val | (TAOS_TRITON_CNTL_PROX_DET_ENBL |
+		       TAOS_TRITON_CNTL_PWRON | TAOS_TRITON_CNTL_ADC_ENBL);
+	if ((ret = taos_write_byte(taos_datap->client,
+			     TAOS_TRITON_CNTRL, reg_cntrl)) < 0) {
+		printk(KERN_ERR
+		       "TAOS: write reg_cntrl failed in ioctl prox_on\n");
+		return (ret);
+	}
+
+#ifndef IGNORE_THRESHOLD_CALC
+	prox_sum = 0;
+	prox_max = 0;
+	for (i = 0; i < 20; i++) {
+		if ((ret = taos_prox_poll(&prox_cal_info[i])) < 0) {
+			printk(KERN_ERR
+			       "TAOS: call to prox_poll failed in ioctl prox_calibrate\n");
+			return (ret);
+		}
+		prox_sum += prox_cal_info[i].prox_data;
+		if (prox_cal_info[i].prox_data > prox_max)
+			prox_max = prox_cal_info[i].prox_data;
+		mdelay(100);
+	}
+	prox_mean = prox_sum / 20;
+	taos_cfgp->prox_threshold_hi =
+	    ((((prox_max - prox_mean) * 200) + 50) / 100) + prox_mean;
+	taos_cfgp->prox_threshold_lo =
+	    ((((prox_max - prox_mean) * 170) + 50) / 100) + prox_mean;
+	if (taos_cfgp->prox_threshold_hi < prox_threshold_hi_param)
+		taos_cfgp->prox_threshold_hi =
+		    (taos_cfgp->prox_threshold_hi +
+		     prox_threshold_hi_param) / 2;
+	if (taos_cfgp->prox_threshold_lo > prox_threshold_lo_param)
+		taos_cfgp->prox_threshold_lo =
+		    (taos_cfgp->prox_threshold_lo +
+		     prox_threshold_lo_param) / 2;
+	prox_mean = taos_cfgp->prox_threshold_hi - taos_cfgp->prox_threshold_lo;
+	if (prox_mean < 30) {
+		taos_cfgp->prox_threshold_hi += prox_mean / 2;
+		if (taos_cfgp->prox_threshold_lo > prox_mean)
+			taos_cfgp->prox_threshold_lo -= prox_mean / 2;
+	}
+	if (taos_cfgp->prox_threshold_lo > prox_threshold_lo_param * 3) {
+		taos_cfgp->prox_threshold_lo = prox_threshold_lo_param;
+		taos_cfgp->prox_threshold_hi = prox_threshold_hi_param;
+	}
+#else
+	taos_cfgp->prox_threshold_lo = prox_threshold_lo_param;
+	taos_cfgp->prox_threshold_hi = prox_threshold_hi_param;
+#endif
+
+	for (i = 0; i < sizeof(taos_triton_reg_init); i++) {
+		if (i != 11) {
+			if ((ret = taos_write_byte(taos_datap->client,
+					     TAOS_TRITON_CNTRL +
+					     i, taos_triton_reg_init[i])) < 0) {
+				printk(KERN_ERR
+				       "TAOS: write reg_init failed in ioctl\n");
+				return (ret);
+			}
+		}
+	}
+	/*printk("taos_cfgp->prox_threshold_hi = %d\n", taos_cfgp->prox_threshold_hi);*/
+	/*printk("taos_cfgp->prox_threshold_lo = %d\n", taos_cfgp->prox_threshold_lo);*/
+	return ret;
+}
+
+static int taos_als_calibrate(void)
+{
+	int ret = 0;
+	int lux_val = 0;
+	u16 gain_trim_val = 0;
+	u8 reg_val = 0;
+
+	if ((reg_val = taos_read_byte(taos_datap->client, TAOS_TRITON_CNTRL)) < 0) {
+		printk(KERN_ERR
+		       "TAOS: read TAO_TRITON_CNTRL failed in ioctl als_off\n");
+		return (ret);
+	}
+	if ((reg_val & 0x07) != 0x07) {
+		return -ENODATA;
+	}
+	if ((reg_val = taos_read_byte(taos_datap->client, TAOS_TRITON_STATUS)) < 0) {
+		printk(KERN_ERR
+		       "TAOS: read TAO_TRITON_CNTRL failed in ioctl als_off\n");
+		return (ret);
+	}
+	if ((reg_val & 0x01) != 0x01) {
+		return -ENODATA;
+	}
+	if ((lux_val = taos_get_lux()) < 0) {
+		printk(KERN_ERR
+		       "TAOS: call to lux_val() returned error %d in ioctl als_data\n",
+		       lux_val);
+		return (lux_val);
+	}
+	gain_trim_val = (u16) (((taos_cfgp->calibrate_target) * 512) / lux_val);
+	taos_cfgp->gain_trim = (int)gain_trim_val;
+	return ((int)gain_trim_val);
+}
+
+// ioctls
+static long taos_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int lux_val = 0, ret = 0, tmp = 0;
+	u8 reg_val = 0;		//, reg_cntrl = 0;
+	u8 reg_val_temp = 0;
+
+	switch (cmd) {
+	case TAOS_IOCTL_SENSOR_CHECK:
+		reg_val_temp = 0;
+		if ((reg_val_temp = taos_read_byte(taos_datap->client,
+				    TAOS_TRITON_CNTRL)) < 0) {
+			printk(KERN_ERR
+			       "TAOS: TAOS_IOCTL_SENSOR_CHECK failed\n");
+			return (ret);
+		}
+		printk
+		    ("TAOS: TAOS_IOCTL_SENSOR_CHECK,prox_adc_time,%d~\n",
+		     reg_val_temp);
+		if ((reg_val_temp & 0xFF) == 0xF)
+			return -ENODATA;
+
+		break;
+	case TAOS_IOCTL_SENSOR_CONFIG:
+		ret = copy_from_user(taos_cfgp, (struct taos_cfg *)arg,
+				     sizeof(struct taos_cfg));
+		if (ret) {
+			printk(KERN_ERR
+			       "TAOS: copy_from_user failed in ioctl config_set\n");
+			return -ENODATA;
+		}
+		break;
+	case TAOS_IOCTL_SENSOR_ON:
+		return sensor_on();
+		break;
+	case TAOS_IOCTL_SENSOR_OFF:
+		return sensor_off();
+		break;
+	case TAOS_IOCTL_ALS_ON:
+		return taos_als_power_on(taos_datap);
+		break;
+	case TAOS_IOCTL_ALS_OFF:
+		return taos_als_power_off(taos_datap);
+		break;
+	case TAOS_IOCTL_ALS_DATA:
+		if ((reg_val = taos_read_byte(taos_datap->client,
+				    TAOS_TRITON_CNTRL)) < 0) {
+			printk(KERN_ERR
+			       "TAOS: read TAO_TRITON_CNTRL failed in ioctl als_off\n");
+			return (ret);
+		}
+		if ((reg_val &
+		     (TAOS_TRITON_CNTL_ADC_ENBL | TAOS_TRITON_CNTL_PWRON))
+		    != (TAOS_TRITON_CNTL_ADC_ENBL | TAOS_TRITON_CNTL_PWRON))
+			return -ENODATA;
+		if ((reg_val = taos_read_byte(taos_datap->client,
+				    TAOS_TRITON_STATUS)) < 0) {
+			printk(KERN_ERR
+			       "TAOS: read TAO_TRITON_CNTRL failed in ioctl als_off\n");
+			return (ret);
+		}
+		if ((reg_val & TAOS_TRITON_STATUS_ADCVALID) !=
+		    TAOS_TRITON_STATUS_ADCVALID)
+			return -ENODATA;
+		if ((lux_val = taos_get_lux()) < 0)
+			printk(KERN_ERR
+			       "TAOS: call to taos_get_lux() returned error %d in ioctl als_data\n",
+			       lux_val);
+		return (lux_val);
+		break;
+	case TAOS_IOCTL_ALS_CALIBRATE:
+		return taos_als_calibrate();
+		break;
+	case TAOS_IOCTL_CONFIG_GET:
+		ret = copy_to_user((struct taos_cfg *)arg, taos_cfgp,
+				 sizeof(struct taos_cfg));
+		if (ret) {
+			printk(KERN_ERR
+			       "TAOS: copy_to_user failed in ioctl config_get\n");
+			return -ENODATA;
+		}
+		return (ret);
+		break;
+	case TAOS_IOCTL_CONFIG_SET:
+		ret = copy_from_user(taos_cfgp, (struct taos_cfg *)arg,
+				   sizeof(struct taos_cfg));
+		if (ret) {
+			printk(KERN_ERR
+			       "TAOS: copy_from_user failed in ioctl config_set\n");
+			return -ENODATA;
+		}
+		if (taos_cfgp->als_time < 50)
+			taos_cfgp->als_time = 50;
+		if (taos_cfgp->als_time > 650)
+			taos_cfgp->als_time = 650;
+		tmp = (taos_cfgp->als_time + 25) / 50;
+		taos_cfgp->als_time = tmp * 50;
+		sat_als = (256 - taos_cfgp->prox_int_time) << 10;
+		sat_prox = (256 - taos_cfgp->prox_adc_time) << 10;
+		break;
+	case TAOS_IOCTL_PROX_ON:
+		sensor_on();
+		taos_ps_calibrate();
+		return taos_ps_power_on(taos_datap);
+		break;
+	case TAOS_IOCTL_PROX_OFF:
+		return taos_ps_power_off(taos_datap);
+		break;
+	case TAOS_IOCTL_PROX_DATA:
+		if ((ret = taos_prox_poll(prox_cur_infop)) < 0) {
+			printk(KERN_ERR
+			       "TAOS: call to prox_poll failed in prox_data\n");
+			return ret;
+		}
+		ret = copy_to_user((struct taos_prox_info *)arg,
+				 prox_cur_infop, sizeof(struct taos_prox_info));
+		if (ret) {
+			printk(KERN_ERR
+			       "TAOS: copy_to_user failed in ioctl prox_data\n");
+			return -ENODATA;
+		}
+		return (ret);
+		break;
+	case TAOS_IOCTL_PROX_CALIBRATE:
+		return taos_ps_calibrate();
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+	return (ret);
+}
+
+// read/calculate lux value
+static int taos_get_lux(void)
+{
+	u16 raw_clear = 0, raw_ir = 0, raw_lux = 0;
+	u32 lux = 0;
+	u32 ratio = 0;
+	u8 dev_gain = 0;
+	u16 Tint = 0;
+	struct lux_data *p;
+	int ret = 0;
+	u8 chdata[4];
+	int tmp = 0, i = 0;
+
+	for (i = 0; i < 4; i++) {
+		if ((chdata[i] = (taos_read_byte
+		      (taos_datap->client, TAOS_TRITON_ALS_CHAN0LO + i))) < 0) {
+			printk(KERN_ERR
+			       "TAOS: read chan0lo/li failed in taos_get_lux()\n");
+			return (ret);
+		}
+		printk("--GGG--chdata is %d\n",chdata[i]);
+	}
+
+	/*if atime =100  tmp = (atime+25)/50=2.5   tine = 2.7*(256-atime)=  412.5*/
+	tmp = (taos_cfgp->als_time + 25) / 50;
+	TritonTime.numerator = 1;
+	TritonTime.denominator = tmp;
+
+	//tmp = 300*atime  400
+	tmp = 300 * taos_cfgp->als_time;
+	if (tmp > 65535)
+		tmp = 65535;
+	TritonTime.saturation = tmp;
+	raw_clear = chdata[1];
+	raw_clear <<= 8;
+	raw_clear |= chdata[0];
+	raw_ir = chdata[3];
+	raw_ir <<= 8;
+	raw_ir |= chdata[2];
+
+	raw_clear *= (taos_cfgp->scale_factor);
+	raw_ir *= (taos_cfgp->scale_factor);
+
+	if (raw_ir > raw_clear) {
+		raw_lux = raw_ir;
+		raw_ir = raw_clear;
+		raw_clear = raw_lux;
+	}
+	dev_gain = taos_triton_gain_table[taos_cfgp->gain & 0x3];
+	if (raw_clear >= lux_timep->saturation)
+		return (TAOS_MAX_LUX);
+	if (raw_ir >= lux_timep->saturation)
+		return (TAOS_MAX_LUX);
+	if (raw_clear == 0)
+		return (0);
+	if (dev_gain == 0 || dev_gain > 127) {
+		printk(KERN_ERR
+		       "TAOS: dev_gain = 0 or > 127 in taos_get_lux()\n");
+		return -1;
+	}
+	if (lux_timep->denominator == 0) {
+		printk(KERN_ERR
+		       "TAOS: lux_timep->denominator = 0 in taos_get_lux()\n");
+		return -1;
+	}
+	ratio = (raw_ir << 15) / raw_clear;
+	for (p = lux_tablep; p->ratio && p->ratio < ratio; p++) ;
+	if (!p->ratio) {
+		if (lux_history[0] < 0)
+			return 0;
+		else
+			return lux_history[0];
+	}
+	Tint = taos_cfgp->als_time;
+	raw_clear = ((raw_clear * 400 + (dev_gain >> 1)) / dev_gain +
+			(Tint >> 1)) / Tint;
+	raw_ir = ((raw_ir * 400 + (dev_gain >> 1)) / dev_gain + (Tint >> 1)) / Tint;
+	lux = ((raw_clear * (p->clear)) - (raw_ir * (p->ir)));
+	lux = (lux + 32000) / 64000;
+	if (lux > TAOS_MAX_LUX) {
+		lux = TAOS_MAX_LUX;
+	}
+	return (lux);
+}
+
+// verify device
+static int taos_device_name(unsigned char *bufp, char **device_name)
+{
+	if ((bufp[0x12] & 0xf0) == 0x00)
+		return (0);
+	if (bufp[0x10] | bufp[0x1a] | bufp[0x1b] | bufp[0x1c] | bufp[0x1d] |
+	    bufp[0x1e])
+		return (0);
+	if (bufp[0x13] & 0x0c)
+		return (0);
+	*device_name = "tmd27713";
+	return (1);
+}
+
+// proximity poll
+static int taos_prox_poll(struct taos_prox_info *prxp)
+{
+	int i = 0, ret = 0;
+	u8 chdata[6];
+	for (i = 0; i < 6; i++) {
+		chdata[i] = taos_read_byte(taos_datap->client,
+				   TAOS_TRITON_CMD_AUTO |
+				   (TAOS_TRITON_ALS_CHAN0LO + i));
+		if (chdata[i] < 0) {
+			printk("ERROR : taos_read_byte chdata[%d]\n", i);
+		}
+	}
+	prxp->prox_clear = chdata[1];
+	prxp->prox_clear <<= 8;
+	prxp->prox_clear |= chdata[0];
+	prxp->prox_data = chdata[5];
+	prxp->prox_data <<= 8;
+	prxp->prox_data |= chdata[4];
+
+	return (ret);
+}
+
+MODULE_AUTHOR("John Koshi - Surya Software");
+MODULE_DESCRIPTION("TAOS ambient light and proximity sensor driver");
+MODULE_LICENSE("GPL");
+
+module_init(taos_init);
+module_exit(taos_exit);
diff --git a/drivers/input/misc/tmd277x.c b/drivers/input/misc/tmd277x.c
new file mode 100644
index 0000000..e40be06
--- /dev/null
+++ b/drivers/input/misc/tmd277x.c
@@ -0,0 +1,1527 @@
+/* drivers/staging/taos/tmd277x.c
+ *
+ * Copyright (C) 2011-2013 Sony Ericsson Mobile Communications AB.
+ *
+ * Author: Aleksej Makarov <aleksej.makarov@sonyericsson.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ */
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/string.h>
+#include <linux/mutex.h>
+#include <linux/unistd.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/input.h>
+#include <linux/slab.h>
+#include <linux/pm.h>
+#include <linux/i2c/tmd277x.h>
+#include <linux/module.h>
+
+#ifdef CONFIG_OF
+#include <linux/of_gpio.h>
+#endif
+
+//#include <mach/regs-gpio.h>
+#include <mach/irqs.h>
+#include <linux/irq.h>
+
+enum tmd277x_regs {
+	TMD277X_ENABLE,
+	TMD277X_ALS_TIME,
+	TMD277X_PRX_TIME,
+	TMD277X_WAIT_TIME,
+	TMD277X_ALS_MINTHRESHLO,
+	TMD277X_ALS_MINTHRESHHI,
+	TMD277X_ALS_MAXTHRESHLO,
+	TMD277X_ALS_MAXTHRESHHI,
+	TMD277X_PRX_MINTHRESHLO,
+	TMD277X_PRX_MINTHRESHHI,
+	TMD277X_PRX_MAXTHRESHLO,
+	TMD277X_PRX_MAXTHRESHHI,
+	TMD277X_PERSISTENCE,
+	TMD277X_CONFIG,
+	TMD277X_PRX_PULSE_COUNT,
+	TMD277X_CONTROL,
+
+	TMD277X_REVID = 0x11,
+	TMD277X_CHIPID,
+	TMD277X_STATUS,
+	TMD277X_ALS_CHAN0LO,
+	TMD277X_ALS_CHAN0HI,
+	TMD277X_ALS_CHAN1LO,
+	TMD277X_ALS_CHAN1HI,
+	TMD277X_PRX_LO,
+	TMD277X_PRX_HI,
+
+	TMD277X_REG_PRX_OFFS = 0x1e,
+	TMD277X_REG_MAX,
+};
+
+enum tmd277x_cmd_reg {
+	TMD277X_CMD_REG           = (1 << 7),
+	TMD277X_CMD_INCR          = (0x1 << 5),
+	TMD277X_CMD_SPL_FN        = (0x3 << 5),
+	TMD277X_CMD_PROX_INT_CLR  = (0x5 << 0),
+	TMD277X_CMD_ALS_INT_CLR   = (0x6 << 0),
+};
+
+enum tmd277x_en_reg {
+	TMD277X_EN_PWR_ON   = (1 << 0),
+	TMD277X_EN_ALS      = (1 << 1),
+	TMD277X_EN_PRX      = (1 << 2),
+	TMD277X_EN_WAIT     = (1 << 3),
+	TMD277X_EN_ALS_IRQ  = (1 << 4),
+	TMD277X_EN_PRX_IRQ  = (1 << 5),
+	TMD277X_EN_SAI      = (1 << 6),
+};
+
+enum tmd277x_status {
+	TMD277X_ST_ALS_VALID  = (1 << 0),
+	TMD277X_ST_PRX_VALID  = (1 << 1),
+	TMD277X_ST_ALS_IRQ    = (1 << 4),
+	TMD277X_ST_PRX_IRQ    = (1 << 5),
+	TMD277X_ST_PRX_SAT    = (1 << 6),
+};
+
+enum {
+	TMD277X_ALS_GAIN_MASK = (3 << 0),
+	TMD277X_ALS_AGL_MASK  = (1 << 2),
+	TMD277X_ALS_AGL_SHIFT = 2,
+	TMD277X_ATIME_PER_100 = 273,
+	TMD277X_ATIME_DEFAULT_MS = 50,
+	SCALE_SHIFT = 11,
+	RATIO_SHIFT = 10,
+	MAX_ALS_VALUE = 0xffff,
+	MIN_ALS_VALUE = 10,
+	GAIN_SWITCH_LEVEL = 100,
+	GAIN_AUTO_INIT_VALUE = 16,
+};
+
+static u8 const tmd277x_ids[] = {
+	0x39,
+	0x30,
+};
+
+static char const *tmd277x_names[] = {
+	"tmd27723 / tmd27727",
+	"tmd27721 / tmd27725",
+};
+
+static u8 const restorable_regs[] = {
+	TMD277X_ALS_TIME,
+	TMD277X_PRX_TIME,
+	TMD277X_WAIT_TIME,
+	TMD277X_PERSISTENCE,
+	TMD277X_CONFIG,
+	TMD277X_PRX_PULSE_COUNT,
+	TMD277X_CONTROL,
+	TMD277X_REG_PRX_OFFS,
+};
+
+static u8 const als_gains[] = {
+	1,
+	8,
+	16,
+	120
+};
+
+struct taos_als_info {
+	int ch0;
+	int ch1;
+	u32 cpl;
+	u32 saturation;
+	int lux;
+};
+
+struct taos_prox_info {
+	int raw;
+	int detected;
+};
+
+static struct lux_segment segment_default[] = {
+	{
+		.ratio = (435 << RATIO_SHIFT) / 1000,
+		.k0 = (46516 << SCALE_SHIFT) / 1000,
+		.k1 = (95381 << SCALE_SHIFT) / 1000,
+	},
+	{
+		.ratio = (551 << RATIO_SHIFT) / 1000,
+		.k0 = (23740 << SCALE_SHIFT) / 1000,
+		.k1 = (43044 << SCALE_SHIFT) / 1000,
+	},
+};
+
+struct tmd2772_chip {
+	struct mutex lock;
+	struct i2c_client *client;
+	struct taos_prox_info prx_inf;
+	struct taos_als_info als_inf;
+	struct taos_parameters params;
+	struct tmd2772_i2c_platform_data *pdata;
+	u8 shadow[TMD277X_REG_MAX];
+	struct input_dev *p_idev;
+	struct input_dev *a_idev;
+	int in_suspend;
+	int wake_irq;
+	int irq_pending;
+	bool unpowered;
+	bool als_enabled;
+	bool prx_enabled;
+	struct lux_segment *segment;
+	int segment_num;
+	int seg_num_max;
+	bool als_gain_auto;
+};
+
+static int taos_i2c_read(struct tmd2772_chip *chip, u8 reg, u8 *val)
+{
+	int ret;
+	s32 read;
+	struct i2c_client *client = chip->client;
+
+	ret = i2c_smbus_write_byte(client, (TMD277X_CMD_REG | reg));
+	if (ret < 0) {
+		dev_err(&client->dev, "%s: failed to write register %x\n",
+				__func__, reg);
+		return ret;
+	}
+	read = i2c_smbus_read_byte(client);
+	if (read < 0) {
+		dev_err(&client->dev, "%s: failed to read from register %x\n",
+				__func__, reg);
+		return ret;
+	}
+	*val = read;
+	return read;
+}
+
+static int taos_i2c_blk_read(struct tmd2772_chip *chip,
+		u8 reg, u8 *val, int size)
+{
+	s32 ret;
+	struct i2c_client *client = chip->client;
+
+	ret =  i2c_smbus_read_i2c_block_data(client,
+			TMD277X_CMD_REG | TMD277X_CMD_INCR | reg, size, val);
+	if (ret < 0)
+		dev_err(&client->dev, "%s: failed at address %x (%d bytes)\n",
+				__func__, reg, size);
+	return ret;
+}
+
+static int taos_i2c_write(struct tmd2772_chip *chip, u8 reg, u8 val)
+{
+	int ret;
+	struct i2c_client *client = chip->client;
+
+	ret = i2c_smbus_write_byte_data(client, TMD277X_CMD_REG | reg, val);
+	if (ret < 0)
+		dev_err(&client->dev, "%s: failed to write register %x\n",
+				__func__, reg);
+	return ret;
+}
+
+static int taos_i2c_blk_write(struct tmd2772_chip *chip,
+		u8 reg, u8 *val, int size)
+{
+	s32 ret;
+	struct i2c_client *client = chip->client;
+
+	ret =  i2c_smbus_write_i2c_block_data(client,
+			TMD277X_CMD_REG | TMD277X_CMD_INCR | reg, size, val);
+	if (ret < 0)
+		dev_err(&client->dev, "%s: failed at address %x (%d bytes)\n",
+				__func__, reg, size);
+	return ret;
+}
+
+static int set_segment_table(struct tmd2772_chip *chip,
+		struct lux_segment *segment, int seg_num)
+{
+	int i;
+	struct device *dev = &chip->client->dev;
+
+	chip->seg_num_max = chip->pdata->segment_num ?
+			chip->pdata->segment_num : ARRAY_SIZE(segment_default);
+
+	if (!chip->segment) {
+		dev_dbg(dev, "%s: allocating segment table\n", __func__);
+		chip->segment = kzalloc(sizeof(*chip->segment) *
+				chip->seg_num_max, GFP_KERNEL);
+		if (!chip->segment) {
+			dev_err(dev, "%s: no memory!\n", __func__);
+			return -ENOMEM;
+		}
+	}
+	if (seg_num > chip->seg_num_max) {
+		dev_warn(dev, "%s: %d segment requested, %d applied\n",
+				__func__, seg_num, chip->seg_num_max);
+		chip->segment_num = chip->seg_num_max;
+	} else {
+		chip->segment_num = seg_num;
+	}
+	memcpy(chip->segment, segment,
+			chip->segment_num * sizeof(*chip->segment));
+	dev_dbg(dev, "%s: %d segment requested, %d applied\n", __func__,
+			seg_num, chip->seg_num_max);
+	for (i = 0; i < chip->segment_num; i++)
+		dev_dbg(dev, "segment %d: ratio %6u, k0 %6u, k1 %6u\n",
+				i, chip->segment[i].ratio,
+				chip->segment[i].k0, chip->segment[i].k1);
+	return 0;
+}
+
+static void taos_calc_cpl(struct tmd2772_chip *chip) 
+{
+	u32 cpl;
+	u32 sat;
+	u8 atime = chip->shadow[TMD277X_ALS_TIME];
+	u8 agl = (chip->shadow[TMD277X_CONFIG] & TMD277X_ALS_AGL_MASK)  
+			>> TMD277X_ALS_AGL_SHIFT;			
+
+
+	u32 time_scale = (256 - atime ) * 2730 / 200;   //2730 =2.73*1000  
+
+/*20120830 johnny
+	u32 time_scale = ((256 - atime) << SCALE_SHIFT) *		//atime = TMD277X_ALS_TIME 
+		TMD277X_ATIME_PER_100 / (TMD277X_ATIME_DEFAULT_MS * 100); // TMD277X_ATIME_PER_100 = 273,TMD277X_ATIME_DEFAULT_MS = 50
+*/
+										//time_scale = ((256-238)<<11)*273/(50*100) = 2012
+	cpl = time_scale * chip->params.als_gain;				// cpl = 2012 * 8 = 16096
+	if (agl)   							
+		cpl = cpl * 16 / 1000;						// cpl = 16096*16/1000 = 257
+	sat = min_t(u32, MAX_ALS_VALUE, (u32)(256 - atime) << 10); 	//  (256-238)<<10 = 18432,min_t(u32,X,u32,Y)
+	sat = sat * 8 / 10;					  	
+	dev_dbg(&chip->client->dev,//12
+			"%s: cpl = %u [time_scale %u, gain %u, agl %u], "
+			"saturation %u\n", __func__, cpl, time_scale,
+			chip->params.als_gain, agl, sat);
+	chip->als_inf.cpl = cpl;					//CPL = chip->als_inf.cpl
+	chip->als_inf.saturation = sat;					//sat = chip->als_inf.saturation
+}
+
+static int set_als_gain(struct tmd2772_chip *chip, int gain)
+{
+	int rc;
+	u8 ctrl_reg  = chip->shadow[TMD277X_CONTROL] & ~TMD277X_ALS_GAIN_MASK;
+
+	switch (gain) {
+	case 1:
+		ctrl_reg |= AGAIN_1;
+		break;
+	case 8:
+		ctrl_reg |= AGAIN_8;
+		break;
+	case 16:
+		ctrl_reg |= AGAIN_16;
+		break;
+	case 120:
+		ctrl_reg |= AGAIN_120;
+		break;
+	default:
+		dev_err(&chip->client->dev, "%s: wrong als gain %d\n",
+				__func__, gain);
+		return -EINVAL;
+	}
+	rc = taos_i2c_write(chip, TMD277X_CONTROL, ctrl_reg);
+	if (!rc) {
+		chip->shadow[TMD277X_CONTROL] = ctrl_reg;
+		chip->params.als_gain = gain;
+		dev_dbg(&chip->client->dev, "%s: new gain %d\n",
+				__func__, gain);
+	}
+	return rc;
+}
+
+static int taos_get_lux(struct tmd2772_chip *chip)
+{
+	unsigned i;
+	int ret = 0;
+	struct device *dev = &chip->client->dev;	
+	struct lux_segment *s = chip->segment;		
+	u32 c0 = chip->als_inf.ch0;
+	u32 c1 = chip->als_inf.ch1;
+	u32 sat = chip->als_inf.saturation;
+	u32 ratio;
+	u64 lux_0, lux_1;
+	u32 cpl = chip->als_inf.cpl;
+	u32 lux, k0 = 0, k1 = 0;
+
+	if (!chip->als_gain_auto) {  			
+									
+		if (c0 <= MIN_ALS_VALUE) {  				//MIN_ALS_VALUE = 10
+			dev_dbg(dev, "%s: darkness\n", __func__);
+			lux = 0;
+			goto exit;
+		} else if (c0 >= sat) {
+			dev_dbg(dev, "%s: saturation, keep lux\n", __func__);
+			lux = chip->als_inf.lux;
+			goto exit;
+		}
+	} else {							//chip->als_gain_auto = "AUTO"
+		u8 gain = chip->params.als_gain;			// auto gain , 1x , 16x , 120x
+		int rc = -EIO;
+
+		if (gain == 16 && c0 >= sat) {
+			rc = set_als_gain(chip, 1);
+		} else if (gain == 16 && c0 < GAIN_SWITCH_LEVEL) {	//GAIN_SWITCH_LEVEL = 100
+			rc = set_als_gain(chip, 120);
+		} else if ((gain == 120 && c0 >= sat) ||
+				(gain == 1 && c0 < GAIN_SWITCH_LEVEL)) {
+			rc = set_als_gain(chip, 16);
+		}
+		if (!rc) {							
+			dev_dbg(dev, "%s: gain adjusted, skip\n", __func__);	
+			taos_calc_cpl(chip);
+			ret = -EAGAIN;
+			lux = chip->als_inf.lux;
+			goto exit;
+		}
+
+		if (c0 <= MIN_ALS_VALUE) {
+			dev_dbg(dev, "%s: darkness\n", __func__);
+			lux = 0;
+			goto exit;
+		} else if (c0 >= sat) {
+			dev_dbg(dev, "%s: saturation, keep lux\n", __func__);
+			lux = chip->als_inf.lux;
+			goto exit;
+		}
+	}
+
+	//atime = 50ms, gain = 8x , ch0 = 3891 , ch1 = 424
+
+	ratio = (c1 << RATIO_SHIFT) / c0;						//ratio = c1 * 1024 / c0     //ratio = 111
+	for (i = 0; i < chip->segment_num; i++, s++) {
+		if (ratio <= s->ratio) {
+			dev_dbg(&chip->client->dev, "%s: ratio %u segment %u "
+					"[r %u, k0 %u, k1 %u]\n", __func__,
+					ratio, i, s->ratio, s->k0, s->k1);
+			k0 = s->k0;
+			k1 = s->k1;
+			break;
+		}
+	}
+	if (i >= chip->segment_num) {
+		dev_dbg(&chip->client->dev, "%s: ratio %u - darkness\n",
+				__func__, ratio);
+		lux = 0;
+		goto exit;
+	}
+
+	lux_0 = ( ( ( c0 * 100 ) - ( c1 * 175 ) ) * 10 ) / cpl;
+	lux_1 = ( ( ( c0 *  63 ) - ( c1 * 100 ) ) * 10 ) / cpl; 				//20120830	lux
+
+	
+	//snprintf( buf, "lux_0 = 0x%16llx , lux_1 = 0x%16llx , c0 = 0x%16llx , c1 = 0x%16llx ", lux_0 , lux_1 , c0 , c1 );
+
+	lux = max(lux_0, lux_1);							//20120830	lux
+	lux = max(lux , (u32)0);							//20120830	lux
+
+exit:
+	dev_dbg(&chip->client->dev, "%s: lux %u (%u x %u - %u x %u) / %u\n",
+		__func__, lux, k0, c0, k1, c1, cpl);
+	lux = lux / 4;
+	chip->als_inf.lux = lux;
+	return ret;
+}
+
+static int pltf_power_on(struct tmd2772_chip *chip)
+{
+	int rc = 0;
+	if (chip->pdata->platform_power) {
+		rc = chip->pdata->platform_power(&chip->client->dev,
+			POWER_ON);
+		msleep(10);
+	}
+	chip->unpowered = rc != 0;
+	return rc;
+}
+
+static int pltf_power_off(struct tmd2772_chip *chip)
+{
+	int rc = 0;
+	if (chip->pdata->platform_power) {
+		rc = chip->pdata->platform_power(&chip->client->dev,
+			POWER_OFF);
+		chip->unpowered = rc == 0;
+	} else {
+		chip->unpowered = false;
+	}
+	return rc;
+}
+
+static int taos_irq_clr(struct tmd2772_chip *chip, u8 bits)
+{
+	int ret = i2c_smbus_write_byte(chip->client, TMD277X_CMD_REG |
+			TMD277X_CMD_SPL_FN | bits);
+	if (ret < 0)
+		dev_err(&chip->client->dev, "%s: failed, bits %x\n",
+				__func__, bits);
+	return ret;
+}
+
+static void taos_get_als(struct tmd2772_chip *chip)
+{
+	u32 ch0, ch1;
+	u8 *buf = &chip->shadow[TMD277X_ALS_CHAN0LO];
+
+	ch0 = le16_to_cpup((const __le16 *)&buf[0]);
+	ch1 = le16_to_cpup((const __le16 *)&buf[2]);
+	chip->als_inf.ch0 = ch0;
+	chip->als_inf.ch1 = ch1;
+	dev_dbg(&chip->client->dev, "%s: ch0 %u, ch1 %u\n", __func__, ch0, ch1);
+}
+
+static void taos_get_prox(struct tmd2772_chip *chip)
+{
+	u8 *buf = &chip->shadow[TMD277X_PRX_LO];
+	bool d = chip->prx_inf.detected;
+
+	chip->prx_inf.raw = (buf[1] << 8) | buf[0];
+	chip->prx_inf.detected =
+			(d && (chip->prx_inf.raw > chip->params.prox_th_min)) ||
+			(!d && (chip->prx_inf.raw > chip->params.prox_th_max));
+	dev_dbg(&chip->client->dev, "%s: raw %d, detected %d\n", __func__,
+			chip->prx_inf.raw, chip->prx_inf.detected);
+}
+
+static int taos_read_all(struct tmd2772_chip *chip)
+{
+	struct i2c_client *client = chip->client;
+	s32 ret;
+
+	dev_dbg(&client->dev, "%s\n", __func__);
+	ret = taos_i2c_blk_read(chip, TMD277X_STATUS,
+			&chip->shadow[TMD277X_STATUS],
+			TMD277X_PRX_HI - TMD277X_STATUS + 1);
+	return (ret < 0) ? ret : 0;
+}
+
+static int update_prox_thresh(struct tmd2772_chip *chip, bool on_enable)
+{
+	s32 ret;
+	u8 *buf = &chip->shadow[TMD277X_PRX_MINTHRESHLO];
+	u16 from, to;
+
+	if (on_enable) {
+		/* zero gate to force irq */
+		from = to = 0;
+	} else {
+		if (chip->prx_inf.detected) {
+			from = chip->params.prox_th_min;
+			to = 0xffff;
+		} else {
+			from = 0;
+			to = chip->params.prox_th_max;
+		}
+	}
+	dev_dbg(&chip->client->dev, "%s: %u - %u\n", __func__, from, to);
+	*buf++ = from & 0xff;
+	*buf++ = from >> 8;
+	*buf++ = to & 0xff;
+	*buf++ = to >> 8;
+	ret = taos_i2c_blk_write(chip, TMD277X_PRX_MINTHRESHLO,
+			&chip->shadow[TMD277X_PRX_MINTHRESHLO],
+			TMD277X_PRX_MAXTHRESHHI - TMD277X_PRX_MINTHRESHLO + 1);
+	return (ret < 0) ? ret : 0;
+}
+
+static int update_als_thres(struct tmd2772_chip *chip, bool on_enable)
+{
+	s32 ret;
+	u8 *buf = &chip->shadow[TMD277X_ALS_MINTHRESHLO];
+	u16 gate = chip->params.als_gate;
+	u16 from, to, cur;
+
+	cur = chip->als_inf.ch0;
+	if (on_enable) {
+		/* zero gate far away form current position to force an irq */
+		from = to = cur > 0xffff / 2 ? 0 : 0xffff;
+	} else {
+		gate = cur * gate / 100;
+		if (!gate)
+			gate = 1;
+		if (cur > gate)
+			from = cur - gate;
+		else
+			from = 0;
+		if (cur < (0xffff - gate))
+			to = cur + gate;
+		else
+			to = 0xffff;
+	}
+	dev_dbg(&chip->client->dev, "%s: [%u - %u]\n", __func__, from, to);
+	*buf++ = from & 0xff;
+	*buf++ = from >> 8;
+	*buf++ = to & 0xff;
+	*buf++ = to >> 8;
+	ret = taos_i2c_blk_write(chip, TMD277X_ALS_MINTHRESHLO,
+			&chip->shadow[TMD277X_ALS_MINTHRESHLO],
+			TMD277X_ALS_MAXTHRESHHI - TMD277X_ALS_MINTHRESHLO + 1);
+	return (ret < 0) ? ret : 0;
+}
+
+static void report_prox(struct tmd2772_chip *chip)
+{
+	if (chip->p_idev) {
+		input_report_abs(chip->p_idev, ABS_DISTANCE,
+				chip->prx_inf.detected ? 0 : 1);
+		input_sync(chip->p_idev);
+	}
+}
+
+static void report_als(struct tmd2772_chip *chip)
+{
+	if (chip->a_idev) {
+		int rc = taos_get_lux(chip);
+		if (!rc) {
+			int lux = chip->als_inf.lux;
+			input_report_abs(chip->a_idev, ABS_MISC, lux);
+			input_sync(chip->a_idev);
+			update_als_thres(chip, 0);
+		} else {
+			update_als_thres(chip, 1);
+		}
+	}
+}
+
+static int taos_check_and_report(struct tmd2772_chip *chip)
+{
+	u8 status;
+
+	int ret = taos_read_all(chip);
+	if (ret)
+		goto exit_clr;
+
+	status = chip->shadow[TMD277X_STATUS];
+	dev_dbg(&chip->client->dev, "%s: status 0x%02x\n", __func__, status);
+	if ((status & (TMD277X_ST_PRX_VALID | TMD277X_ST_PRX_IRQ)) ==
+			(TMD277X_ST_PRX_VALID | TMD277X_ST_PRX_IRQ)) {
+		printk("ps\n");
+		taos_get_prox(chip);
+		report_prox(chip);
+		update_prox_thresh(chip, 0);
+	}
+
+	if ((status & (TMD277X_ST_ALS_VALID | TMD277X_ST_ALS_IRQ)) ==
+			(TMD277X_ST_ALS_VALID | TMD277X_ST_ALS_IRQ)) {
+		printk("als\n");
+		taos_get_als(chip);
+		report_als(chip);
+	}
+exit_clr:
+	taos_irq_clr(chip, TMD277X_CMD_PROX_INT_CLR | TMD277X_CMD_ALS_INT_CLR);
+	return ret;
+}
+
+static irqreturn_t taos_irq(int irq, void *handle)
+{
+	struct tmd2772_chip *chip = handle;
+	struct device *dev = &chip->client->dev;
+	mutex_lock(&chip->lock);
+	if (chip->in_suspend) {
+		dev_dbg(dev, "%s: in suspend\n", __func__);
+		chip->irq_pending = 1;
+		disable_irq_nosync(chip->client->irq);
+		goto bypass;
+	}
+	dev_dbg(dev, "%s\n", __func__);
+	(void)taos_check_and_report(chip);
+bypass:
+	mutex_unlock(&chip->lock);
+	return IRQ_HANDLED;
+}
+
+static void set_pltf_settings(struct tmd2772_chip *chip)
+{
+	struct taos_raw_settings const *s = chip->pdata->raw_settings;
+	u8 *sh = chip->shadow;
+	struct device *dev = &chip->client->dev;
+
+	if (s) {
+		dev_dbg(dev, "%s: form pltf data\n", __func__);
+		sh[TMD277X_ALS_TIME] = s->als_time;
+		sh[TMD277X_PRX_TIME] = s->prx_time;
+		sh[TMD277X_WAIT_TIME] = s->wait_time;
+		sh[TMD277X_PERSISTENCE] = s->persist;
+		sh[TMD277X_CONFIG] = s->cfg_reg;
+		sh[TMD277X_PRX_PULSE_COUNT] = s->prox_pulse_cnt;
+		sh[TMD277X_CONTROL] = s->ctrl_reg;
+		sh[TMD277X_REG_PRX_OFFS] = s->prox_offs;
+	} else {
+		dev_dbg(dev, "%s: use defaults\n", __func__);
+		sh[TMD277X_ALS_TIME] = 238; /* ~50 ms */
+		sh[TMD277X_PRX_TIME] = 255;
+		sh[TMD277X_WAIT_TIME] = 0;
+		sh[TMD277X_PERSISTENCE] = PRX_PERSIST(1) | ALS_PERSIST(3);
+		sh[TMD277X_CONFIG] = 0;
+		sh[TMD277X_PRX_PULSE_COUNT] = 12;
+		sh[TMD277X_CONTROL] = AGAIN_8 | PGAIN_4 |
+				PDIOD_CH0 | PDRIVE_30MA;
+		sh[TMD277X_REG_PRX_OFFS] = 0;
+	}
+	chip->params.als_gate = chip->pdata->parameters.als_gate;
+	chip->params.prox_th_max = chip->pdata->parameters.prox_th_max;
+	chip->params.prox_th_min = chip->pdata->parameters.prox_th_min;
+	chip->params.als_gain = chip->pdata->parameters.als_gain;
+	if (chip->pdata->parameters.als_gain) {
+		chip->params.als_gain = chip->pdata->parameters.als_gain;
+	} else {
+		chip->als_gain_auto = true;
+		chip->params.als_gain = GAIN_AUTO_INIT_VALUE;
+		dev_dbg(&chip->client->dev, "%s: auto als gain.\n", __func__);
+	}
+	(void)set_als_gain(chip, chip->params.als_gain);
+	taos_calc_cpl(chip);
+}
+
+static int flush_regs(struct tmd2772_chip *chip)
+{
+	unsigned i;
+	int rc;
+	u8 reg;
+
+	dev_dbg(&chip->client->dev, "%s\n", __func__);
+	for (i = 0; i < ARRAY_SIZE(restorable_regs); i++) {
+		reg = restorable_regs[i];
+		rc = taos_i2c_write(chip, reg, chip->shadow[reg]);
+		if (rc) {
+			dev_err(&chip->client->dev, "%s: err on reg 0x%02x\n",
+					__func__, reg);
+			break;
+		}
+	}
+	return rc;
+}
+
+static int update_enable_reg(struct tmd2772_chip *chip)
+{
+	dev_dbg(&chip->client->dev, "%s: %02x\n", __func__,
+			chip->shadow[TMD277X_ENABLE]);
+	return taos_i2c_write(chip, TMD277X_ENABLE,
+			chip->shadow[TMD277X_ENABLE]);
+}
+
+static int taos_prox_enable(struct tmd2772_chip *chip, int on)
+{
+	int rc;
+
+	dev_dbg(&chip->client->dev, "%s: on = %d\n", __func__, on);
+	if (on) {
+		taos_irq_clr(chip, TMD277X_CMD_PROX_INT_CLR);
+		update_prox_thresh(chip, 1);
+		chip->shadow[TMD277X_ENABLE] |=
+				(TMD277X_EN_PWR_ON | TMD277X_EN_PRX |
+				TMD277X_EN_PRX_IRQ);
+		rc = update_enable_reg(chip);
+		if (rc)
+			return rc;
+		msleep(3);
+	} else {
+		chip->shadow[TMD277X_ENABLE] &=
+				~(TMD277X_EN_PRX_IRQ | TMD277X_EN_PRX);
+		if (!(chip->shadow[TMD277X_ENABLE] & TMD277X_EN_ALS))
+			chip->shadow[TMD277X_ENABLE] &= ~TMD277X_EN_PWR_ON;
+		rc = update_enable_reg(chip);
+		if (rc)
+			return rc;
+		taos_irq_clr(chip, TMD277X_CMD_PROX_INT_CLR);
+	}
+	if (!rc)
+		chip->prx_enabled = on;
+	return rc;
+}
+
+static int taos_als_enable(struct tmd2772_chip *chip, int on)
+{
+	int rc;
+
+	dev_dbg(&chip->client->dev, "%s: on = %d\n", __func__, on);
+	printk("%s: on = %d\n", __func__, on);
+	if (on) {
+		taos_irq_clr(chip, TMD277X_CMD_ALS_INT_CLR);
+		update_als_thres(chip, 1);
+		chip->shadow[TMD277X_ENABLE] |=
+				(TMD277X_EN_PWR_ON | TMD277X_EN_ALS |
+				TMD277X_EN_ALS_IRQ);
+		rc = update_enable_reg(chip);
+		if (rc)
+			return rc;
+		msleep(3);
+	} else {
+		chip->shadow[TMD277X_ENABLE] &=
+				~(TMD277X_EN_ALS_IRQ | TMD277X_EN_ALS);
+		if (!(chip->shadow[TMD277X_ENABLE] & TMD277X_EN_PRX))
+			chip->shadow[TMD277X_ENABLE] &= ~TMD277X_EN_PWR_ON;
+		rc = update_enable_reg(chip);
+		if (rc)
+			return rc;
+		taos_irq_clr(chip, TMD277X_CMD_ALS_INT_CLR);
+	}
+	if (!rc)
+		chip->als_enabled = on;
+	return rc;
+}
+
+static ssize_t taos_device_als_ch0(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->als_inf.ch0);
+}
+
+static ssize_t taos_device_als_ch1(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->als_inf.ch1);
+}
+
+static ssize_t taos_device_als_cpl(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->als_inf.cpl);
+}
+
+static ssize_t taos_device_als_lux(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->als_inf.lux);
+}
+
+static ssize_t taos_lux_table_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	struct lux_segment *s = chip->segment;
+	int i, k;
+
+	for (i = k = 0; i < chip->segment_num; i++)
+		k += snprintf(buf + k, PAGE_SIZE - k, "%d:%u,%u,%u\n", i,
+				(s[i].ratio * 1000) >> RATIO_SHIFT,
+				(s[i].k0 * 1000) >> SCALE_SHIFT,
+				(s[i].k1 * 1000) >> SCALE_SHIFT);
+	return k;
+}
+
+static ssize_t taos_lux_table_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	int i;
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	u32 ratio, k0, k1;
+
+	if (4 != sscanf(buf, "%10d:%10u,%10u,%10u", &i, &ratio, &k0, &k1))
+		return -EINVAL;
+	if (i >= chip->segment_num)
+		return -EINVAL;
+	mutex_lock(&chip->lock);
+	chip->segment[i].ratio = (ratio << RATIO_SHIFT) / 1000;
+	chip->segment[i].k0 = (k0 << SCALE_SHIFT) / 1000;
+	chip->segment[i].k1 = (k1 << SCALE_SHIFT) / 1000;
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmd2772_als_enable_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->als_enabled);
+}
+
+static ssize_t tmd2772_als_enable(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	bool value;
+
+	if (strtobool(buf, &value))
+		return -EINVAL;
+
+	if (value)
+		taos_als_enable(chip,1);
+	else
+		taos_als_enable(chip,0);
+
+	return size;
+}
+
+static ssize_t tmd2772_prox_enable_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->prx_enabled);
+}
+
+static ssize_t tmd2772_prox_enable(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	bool value;
+
+	if (strtobool(buf, &value))
+		return -EINVAL;
+
+	if (value)
+		taos_prox_enable(chip,1);
+	else
+		taos_prox_enable(chip,0);
+
+	return size;
+}
+
+static ssize_t taos_als_gain_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d (%s)\n", chip->params.als_gain,
+			chip->als_gain_auto ? "auto" : "manual");
+}
+
+static ssize_t taos_als_gain_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	unsigned long gain;
+	int rc;
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+
+	rc = strict_strtoul(buf, 10, &gain);
+	if (rc)
+		return -EINVAL;
+	if (gain != 0 && gain != 1 && gain != 8 && gain != 16 && gain != 120)
+		return -EINVAL;
+	mutex_lock(&chip->lock);
+	if (gain) {
+		chip->als_gain_auto = false;
+		rc = set_als_gain(chip, gain);
+		if (!rc)
+			taos_calc_cpl(chip);
+	} else {
+		chip->als_gain_auto = true;
+	}
+	mutex_unlock(&chip->lock);
+	return rc ? rc : size;
+}
+
+static ssize_t taos_als_gate_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d (in %%)\n", chip->params.als_gate);
+}
+
+static ssize_t taos_als_gate_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	unsigned long gate;
+	int rc;
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+
+	rc = strict_strtoul(buf, 10, &gate);
+	if (rc || gate > 100)
+		return -EINVAL;
+	mutex_lock(&chip->lock);
+	chip->params.als_gate = gate;
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t taos_device_prox_raw(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	u8 *bufff;
+	int rawww;
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+
+	int ret = taos_read_all(chip);
+	if (ret)
+		goto exit_clr;
+
+	bufff = &chip->shadow[TMD277X_PRX_LO];
+
+	rawww = (bufff[1] << 8) | bufff[0];
+	return snprintf(buf, PAGE_SIZE, "%d\n", rawww);
+exit_clr:
+	taos_irq_clr(chip, TMD277X_CMD_PROX_INT_CLR | TMD277X_CMD_ALS_INT_CLR);
+	return ret;
+}
+
+static ssize_t taos_device_prx_raw(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->prx_inf.raw);
+}
+
+static ssize_t taos_device_prx_detected(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->prx_inf.detected);
+}
+
+static ssize_t read_reg(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	struct i2c_client *client = chip->client;
+
+	char *after;
+	int i;
+	u8 reg;
+
+	after = buf;
+	reg = 0x01;
+
+	for(i = 0; i < 15; i++) {
+		i2c_smbus_write_byte(client, (TMD277X_CMD_REG | reg));
+		after += sprintf(after,"0x%02x\t",i2c_smbus_read_byte(client));
+		reg++;
+	}
+	after += sprintf(after, "\n\t");
+
+	reg = 0x12;
+	for(i = 0; i < 8; i++) {
+		i2c_smbus_write_byte(client, (TMD277X_CMD_REG | reg));
+		after += sprintf(after,"0x%02x\t",i2c_smbus_read_byte(client));
+		reg++;
+	}
+	i2c_smbus_write_byte(client, (TMD277X_CMD_REG | 0x1e));
+	after += sprintf(after,"0x%02x\t",i2c_smbus_read_byte(client));
+	after += sprintf(after, "\n");
+	return (after - buf);
+}
+
+static struct device_attribute prox_attrs[] = {
+	__ATTR(prox_raw, 0444, taos_device_prox_raw, NULL),
+	__ATTR(prx_raw, 0444, taos_device_prx_raw, NULL),
+	__ATTR(prx_detect, 0444, taos_device_prx_detected, NULL),
+	__ATTR(enable_ps_sensor, 0666, tmd2772_prox_enable_show, tmd2772_prox_enable),
+};
+
+static struct device_attribute als_attrs[] = {
+	__ATTR(als_ch0, 0444, taos_device_als_ch0, NULL),
+	__ATTR(als_ch1, 0444, taos_device_als_ch1, NULL),
+	__ATTR(als_cpl, 0444, taos_device_als_cpl, NULL),
+	__ATTR(als_chlux, 0444, taos_device_als_lux, NULL),
+	__ATTR(als_gain, 0644, taos_als_gain_show, taos_als_gain_store),
+	__ATTR(als_gate, 0644, taos_als_gate_show, taos_als_gate_store),
+	__ATTR(lux_table, 0644, taos_lux_table_show, taos_lux_table_store),
+	__ATTR(enable_als_sensor, 0666, tmd2772_als_enable_show, tmd2772_als_enable),
+	__ATTR(get_reg,0644,read_reg,NULL),
+};
+
+static int add_sysfs_interfaces(struct device *dev,
+	struct device_attribute *a, int size)
+{
+	int i;
+	for (i = 0; i < size; i++)
+		if (device_create_file(dev, a + i))
+			goto undo;
+	return 0;
+undo:
+	for (; i >= 0 ; i--)
+		device_remove_file(dev, a + i);
+	dev_err(dev, "%s: failed to create sysfs interface\n", __func__);
+	return -ENODEV;
+}
+
+static void remove_sysfs_interfaces(struct device *dev,
+	struct device_attribute *a, int size)
+{
+	int i;
+	for (i = 0; i < size; i++)
+		device_remove_file(dev, a + i);
+}
+
+static int taos_get_id(struct tmd2772_chip *chip, u8 *id, u8 *rev)
+{
+	int rc = taos_i2c_read(chip, TMD277X_REVID, rev);
+	if (rc < 0)
+		return rc;
+	return taos_i2c_read(chip, TMD277X_CHIPID, id);
+}
+
+static int power_on(struct tmd2772_chip *chip)
+{
+	int rc;
+	rc = pltf_power_on(chip);
+	if (rc)
+		return rc;
+	dev_dbg(&chip->client->dev, "%s: chip was off, restoring regs\n",
+			__func__);
+	return flush_regs(chip);
+}
+#if 0
+static int prox_idev_open(struct input_dev *idev)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(&idev->dev);
+	int rc;
+	bool als = chip->a_idev && chip->a_idev->users;
+printk("%s\n",__func__);
+	dev_dbg(&idev->dev, "%s\n", __func__);
+	mutex_lock(&chip->lock);
+	if (chip->unpowered) {
+		rc = power_on(chip);
+		if (rc)
+			goto chip_on_err;
+	}
+	rc = taos_prox_enable(chip, 1);
+	if (rc && !als)
+		pltf_power_off(chip);
+chip_on_err:
+	mutex_unlock(&chip->lock);
+	return rc;
+}
+
+static void prox_idev_close(struct input_dev *idev)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(&idev->dev);
+printk("%s\n",__func__);
+	dev_dbg(&idev->dev, "%s\n", __func__);
+	mutex_lock(&chip->lock);
+	taos_prox_enable(chip, 0);
+	if (!chip->a_idev || !chip->a_idev->users)
+		pltf_power_off(chip);
+	mutex_unlock(&chip->lock);
+}
+
+static int als_idev_open(struct input_dev *idev)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(&idev->dev);
+	int rc;
+	bool prox = chip->p_idev && chip->p_idev->users;
+printk("%s\n",__func__);
+	dev_dbg(&idev->dev, "%s\n", __func__);
+	mutex_lock(&chip->lock);
+	if (chip->unpowered) {
+		rc = power_on(chip);
+		if (rc)
+			goto chip_on_err;
+	}
+	rc = taos_als_enable(chip, 1);
+	if (rc && !prox)
+		pltf_power_off(chip);
+chip_on_err:
+	mutex_unlock(&chip->lock);
+	return rc;
+}
+
+static void als_idev_close(struct input_dev *idev)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(&idev->dev);
+printk("%s\n",__func__);
+	dev_dbg(&idev->dev, "%s\n", __func__);
+	mutex_lock(&chip->lock);
+	taos_als_enable(chip, 0);
+	if (!chip->p_idev || !chip->p_idev->users)
+		pltf_power_off(chip);
+	mutex_unlock(&chip->lock);
+}
+#endif
+
+static int taos_parse_dt(struct device *dev,
+				struct tmd2772_i2c_platform_data *pdata)
+{
+	struct device_node *np = dev->of_node;
+	u32 temp_val;
+	int rc;
+
+	rc = of_property_read_u32(np, "tmd2772,int_gpio", &temp_val);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read int_gpio\n");
+		return rc;
+	} else {
+		pdata->int_gpio = (int)temp_val;
+	}
+	pdata->als_can_wake = of_property_read_bool(np, "tmd2772,als_can_wake");
+	pdata->proximity_can_wake = of_property_read_bool(np, "tmd2772,proximity_can_wake");
+	rc = of_property_read_u32(np, "tmd2772,prox_th_min", &temp_val);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read prox_th_min\n");
+		return rc;
+	} else {
+		pdata->parameters.prox_th_min = (u16)temp_val;
+	}
+	rc = of_property_read_u32(np, "tmd2772,prox_th_max", &temp_val);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read prox_th_max\n");
+		return rc;
+	} else {
+			pdata->parameters.prox_th_max = (u16)temp_val;
+		}
+	rc = of_property_read_u32(np, "tmd2772,als_gate", &temp_val);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read als_gate\n");
+		return rc;
+	} else {
+			pdata->parameters.als_gate = (u16)temp_val;
+		}
+	pdata->raw_settings = NULL;
+	return 0;
+}
+
+static int __devinit taos_probe(struct i2c_client *client,
+	const struct i2c_device_id *idp)
+{
+	int i, ret;
+	u8 id, rev;
+	struct device *dev;
+	static struct tmd2772_chip *chip;
+	struct tmd2772_i2c_platform_data *pdata;
+	bool powered = 0;
+	printk("tmd2772\n");
+	dev = &client->dev;
+	pdata = kzalloc(sizeof(struct tmd2772_i2c_platform_data), GFP_KERNEL);
+	if (!pdata) {
+		ret = -ENOMEM;
+		goto malloc_failed;
+	}
+
+	if (client->dev.of_node) {
+		memset(pdata, 0 , sizeof(struct tmd2772_i2c_platform_data));
+		ret = taos_parse_dt(&client->dev, pdata);
+		if (ret) {
+			dev_err(&client->dev,
+				"Unable to parse platfrom data err=%d\n", ret);
+			return ret;
+		}
+	}  else {
+		if (client->dev.platform_data) {
+			pdata = (struct tmd2772_i2c_platform_data *)client->dev.platform_data;
+		} else {
+			dev_err(&client->dev, "platform data is NULL. Abort.\n");
+			return -EINVAL;
+		}
+	}
+
+	pdata->prox_name = "proximity";
+	pdata->als_name = "lightsensor-level";
+	dev_info(&client->dev, "%s: client->irq = %d\n", __func__, client->irq);
+	if (!i2c_check_functionality(client->adapter,
+			I2C_FUNC_SMBUS_BYTE_DATA)) {
+		dev_err(&client->dev, "%s: i2c smbus byte data unsupported\n", __func__);
+		ret = -EOPNOTSUPP;
+		goto init_failed;
+	}
+	if (!pdata) {
+		dev_err(&client->dev, "%s: platform data required\n", __func__);
+		ret = -EINVAL;
+		goto init_failed;
+	}
+	if (!(pdata->prox_name || pdata->als_name) || client->irq < 0) {
+		dev_err(&client->dev, "%s: no reason to run.\n", __func__);
+		ret = -EINVAL;
+		goto init_failed;
+	}
+	if (pdata->platform_init) {
+		ret = pdata->platform_init(dev);
+		if (ret)
+			goto init_failed;
+	}
+	if (pdata->platform_power) {
+		ret = pdata->platform_power(dev, POWER_ON);
+		if (ret) {
+			dev_err(&client->dev, "%s: pltf power on failed\n", __func__);
+			goto pon_failed;
+		}
+		powered = true;
+		msleep(10);
+	}
+	chip = kzalloc(sizeof(struct tmd2772_chip), GFP_KERNEL);
+	if (!chip) {
+		ret = -ENOMEM;
+		goto malloc_failed;
+	}
+	chip->client = client;
+	chip->pdata = pdata;
+	i2c_set_clientdata(client, chip);
+	chip->seg_num_max = chip->pdata->segment_num ?
+			chip->pdata->segment_num : ARRAY_SIZE(segment_default);
+	if (chip->pdata->segment)
+		ret = set_segment_table(chip, chip->pdata->segment,
+			chip->pdata->segment_num);
+	else
+		ret =  set_segment_table(chip, segment_default,
+			ARRAY_SIZE(segment_default));
+	if (ret)
+		goto set_segment_failed;
+
+	ret = taos_get_id(chip, &id, &rev);
+	if (ret < 0)
+		goto id_failed;
+	for (i = 0; i < ARRAY_SIZE(tmd277x_ids); i++) {
+		if (id == tmd277x_ids[i])
+			break;
+	}
+	if (i < ARRAY_SIZE(tmd277x_names)) {
+		dev_info(&client->dev, "%s: '%s rev. %d' detected\n", __func__,
+			tmd277x_names[i], rev);
+	} else {
+		dev_err(&client->dev, "%s: not supported chip id\n", __func__);
+		ret = -EOPNOTSUPP;
+		goto id_failed;
+	}
+	mutex_init(&chip->lock);
+	set_pltf_settings(chip);
+	ret = flush_regs(chip);
+	if (ret)
+		goto flush_regs_failed;
+	if (pdata->platform_power) {
+		pdata->platform_power(dev, POWER_OFF);
+		powered = false;
+		chip->unpowered = true;
+	}
+
+	if (!pdata->prox_name)
+		goto bypass_prox_idev;
+	chip->p_idev = input_allocate_device();
+	if (!chip->p_idev) {
+		dev_err(&client->dev, "%s: no memory for input_dev '%s'\n",
+				__func__, pdata->prox_name);
+		ret = -ENODEV;
+		goto input_p_alloc_failed;
+	}
+	chip->p_idev->name = pdata->prox_name;
+	chip->p_idev->id.bustype = BUS_I2C;
+	set_bit(EV_ABS, chip->p_idev->evbit);
+	set_bit(ABS_DISTANCE, chip->p_idev->absbit);
+	input_set_abs_params(chip->p_idev, ABS_DISTANCE, 0, 1, 0, 0);
+	//chip->p_idev->open = prox_idev_open;
+	//chip->p_idev->close = prox_idev_close;
+	dev_set_drvdata(&chip->p_idev->dev, chip);
+	ret = input_register_device(chip->p_idev);
+	if (ret) {
+		input_free_device(chip->p_idev);
+		dev_err(&client->dev, "%s: cant register input '%s'\n",
+				__func__, pdata->prox_name);
+		goto input_p_alloc_failed;
+	}
+	ret = add_sysfs_interfaces(&chip->p_idev->dev,
+			prox_attrs, ARRAY_SIZE(prox_attrs));
+	if (ret)
+		goto input_p_sysfs_failed;
+bypass_prox_idev:
+	if (!pdata->als_name)
+		goto bypass_als_idev;
+	chip->a_idev = input_allocate_device();
+	if (!chip->a_idev) {
+		dev_err(&client->dev, "%s: no memory for input_dev '%s'\n",
+				__func__, pdata->als_name);
+		ret = -ENODEV;
+		goto input_a_alloc_failed;
+	}
+	chip->a_idev->name = pdata->als_name;
+	chip->a_idev->id.bustype = BUS_I2C;
+	set_bit(EV_ABS, chip->a_idev->evbit);
+	set_bit(ABS_MISC, chip->a_idev->absbit);
+	input_set_abs_params(chip->a_idev, ABS_MISC, 0, 65535, 0, 0);
+	//chip->a_idev->open = als_idev_open;
+	//chip->a_idev->close = als_idev_close;
+	dev_set_drvdata(&chip->a_idev->dev, chip);
+	ret = input_register_device(chip->a_idev);
+	if (ret) {
+		input_free_device(chip->a_idev);
+		dev_err(&client->dev, "%s: cant register input '%s'\n",
+				__func__, pdata->prox_name);
+		goto input_a_alloc_failed;
+	}
+	ret = add_sysfs_interfaces(&chip->a_idev->dev,
+			als_attrs, ARRAY_SIZE(als_attrs));
+	if (ret)
+		goto input_a_sysfs_failed;
+
+bypass_als_idev:
+printk("int_gpio=%d\n",chip->pdata->int_gpio);
+	gpio_tlmm_config(GPIO_CFG(chip->pdata->int_gpio, 0, GPIO_CFG_INPUT,
+				GPIO_CFG_PULL_UP, GPIO_CFG_8MA),
+				GPIO_CFG_ENABLE);
+	ret = request_threaded_irq(client->irq, NULL, taos_irq,
+		      IRQ_TYPE_EDGE_FALLING,
+		      "taos_irq", chip);
+	if (ret) {
+		dev_info(&client->dev, "Failed to request irq %d\n", client->irq);
+		goto irq_register_fail;
+	}
+
+	dev_info(&client->dev, "Probe ok.\n");
+	return 0;
+
+irq_register_fail:
+	if (chip->a_idev) {
+		remove_sysfs_interfaces(&chip->a_idev->dev,
+			als_attrs, ARRAY_SIZE(als_attrs));
+input_a_sysfs_failed:
+		input_unregister_device(chip->a_idev);
+	}
+input_a_alloc_failed:
+	if (chip->p_idev) {
+		remove_sysfs_interfaces(&chip->p_idev->dev,
+			prox_attrs, ARRAY_SIZE(prox_attrs));
+input_p_sysfs_failed:
+		input_unregister_device(chip->p_idev);
+	}
+input_p_alloc_failed:
+flush_regs_failed:
+id_failed:
+	kfree(chip->segment);
+set_segment_failed:
+	i2c_set_clientdata(client, NULL);
+	kfree(chip);
+malloc_failed:
+	if (powered && pdata->platform_power)
+		pdata->platform_power(dev, POWER_OFF);
+pon_failed:
+	if (pdata->platform_teardown)
+		pdata->platform_teardown(dev);
+init_failed:
+	dev_err(&client->dev, "Probe failed.\n");
+	return ret;
+}
+
+static int taos_suspend(struct device *dev)
+{
+
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+//	struct tmd2772_i2c_platform_data *pdata = dev->platform_data;
+
+	dev_dbg(dev, "%s\n", __func__);
+	mutex_lock(&chip->lock);
+	chip->in_suspend = 1;
+//	if (chip->p_idev && chip->p_idev->users) {
+		printk("proximity off1\n");
+		taos_prox_enable(chip, 0);
+//	}
+//	if (chip->a_idev && chip->a_idev->users) {
+		printk("proximity off2\n");
+		taos_als_enable(chip, 0);
+//	}
+	if (!chip->unpowered) {
+		printk("proximity off3\n");
+		pltf_power_off(chip);
+	}
+	mutex_unlock(&chip->lock);
+
+	return 0;
+}
+
+static int taos_resume(struct device *dev)
+{
+	struct tmd2772_chip *chip = dev_get_drvdata(dev);
+	bool als_on, prx_on;
+	int rc = 0;
+	mutex_lock(&chip->lock);
+	prx_on = chip->p_idev && chip->p_idev->users;
+	als_on = chip->a_idev && chip->a_idev->users;
+	chip->in_suspend = 0;
+	dev_dbg(dev, "%s: powerd %d, als: needed %d  enabled %d,"
+			" prox: needed %d  enabled %d\n", __func__,
+			!chip->unpowered, als_on, chip->als_enabled,
+			prx_on, chip->prx_enabled);
+	if (chip->wake_irq) {
+		irq_set_irq_wake(chip->client->irq, 0);
+		chip->wake_irq = 0;
+	}
+	if (chip->unpowered && (prx_on || als_on)) {
+		dev_dbg(dev, "powering on\n");
+		rc = power_on(chip);
+		if (rc)
+			goto err_power;
+	}
+	if (prx_on && !chip->prx_enabled)
+		(void)taos_prox_enable(chip, 1);
+	if (als_on && !chip->als_enabled)
+		(void)taos_als_enable(chip, 1);
+	if (chip->irq_pending) {
+		dev_dbg(dev, "%s: pending interrupt\n", __func__);
+		chip->irq_pending = 0;
+		(void)taos_check_and_report(chip);
+		enable_irq(chip->client->irq);
+	}
+err_power:
+	mutex_unlock(&chip->lock);
+
+	return 0;
+}
+
+static int __devexit taos_remove(struct i2c_client *client)
+{
+	struct tmd2772_chip *chip = i2c_get_clientdata(client);
+	free_irq(client->irq, chip);
+	if (chip->a_idev) {
+		remove_sysfs_interfaces(&chip->a_idev->dev,
+			als_attrs, ARRAY_SIZE(als_attrs));
+		input_unregister_device(chip->a_idev);
+	}
+	if (chip->p_idev) {
+		remove_sysfs_interfaces(&chip->p_idev->dev,
+			prox_attrs, ARRAY_SIZE(prox_attrs));
+		input_unregister_device(chip->p_idev);
+	}
+	if (chip->pdata->platform_teardown)
+		chip->pdata->platform_teardown(&client->dev);
+	i2c_set_clientdata(client, NULL);
+	kfree(chip->segment);
+	kfree(chip);
+	return 0;
+}
+
+static struct i2c_device_id taos_idtable[] = {
+	{ "tmd2772", 0 },
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, taos_idtable);
+
+static struct of_device_id taos_match_table[] = {
+	{ .compatible = "tmd2772,tmd2772", },
+	{ },
+};
+
+static const struct dev_pm_ops taos_pm_ops = {
+	.suspend = taos_suspend,
+	.resume  = taos_resume,
+};
+
+static struct i2c_driver taos_driver = {
+	.driver = {
+		.name = "tmd2772",
+		.pm = &taos_pm_ops,
+		.of_match_table = taos_match_table,
+	},
+	.id_table = taos_idtable,
+	.probe = taos_probe,
+	.remove = __devexit_p(taos_remove),
+};
+
+static int __init taos_init(void)
+{
+	return i2c_add_driver(&taos_driver);
+}
+
+static void __exit taos_exit(void)
+{
+	i2c_del_driver(&taos_driver);
+}
+
+module_init(taos_init);
+module_exit(taos_exit);
+
+MODULE_AUTHOR("Aleksej Makarov <aleksej.makarov@sonyericsson.com>");
+MODULE_DESCRIPTION("TAOS tmd2772 ambient light and proximity sensor driver");
+MODULE_LICENSE("GPL");
diff --git a/include/linux/i2c/tmd277x.h b/include/linux/i2c/tmd277x.h
new file mode 100644
index 0000000..b3bbd5a
--- /dev/null
+++ b/include/linux/i2c/tmd277x.h
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2010-2013 Samsung Electronics. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+#ifndef __LINUX_TAOS_H
+#define __LINUX_TAOS_H
+
+#include <linux/types.h>
+
+#ifdef __KERNEL__
+#define TAOS_OPT "taos-opt"
+#define MIN 1
+struct device;
+
+enum tmd2772_pwr_state {
+	POWER_ON,
+	POWER_OFF,
+	POWER_STANDBY,
+};
+
+enum taos_ctrl_reg {
+	AGAIN_1        = (0 << 0),
+	AGAIN_8        = (1 << 0),
+	AGAIN_16       = (2 << 0),
+	AGAIN_120      = (3 << 0),
+	PGAIN_1        = (0 << 2),
+	PGAIN_2        = (1 << 2),
+	PGAIN_4        = (2 << 2),
+	PGAIN_8        = (3 << 2),
+	PDIOD_NO       = (0 << 4),
+	PDIOD_CH0      = (1 << 4),
+	PDIOD_CH1      = (2 << 4),
+	PDIOD_DONT_USE = (3 << 4),
+	PDRIVE_120MA   = (0 << 6),
+	PDRIVE_60MA    = (1 << 6),
+	PDRIVE_30MA    = (2 << 6),
+	PDRIVE_15MA    = (3 << 6),
+};
+
+#define PRX_PERSIST(p) (((p) & 0xf) << 4)
+#define ALS_PERSIST(p) (((p) & 0xf) << 0)
+
+struct taos_raw_settings {
+	u8 als_time;
+	u8 als_gain;
+	u8 prx_time;
+	u8 wait_time;
+	u8 persist;
+	u8 cfg_reg;
+	u8 prox_pulse_cnt;
+	u8 ctrl_reg;
+	u8 prox_offs;
+};
+
+struct taos_parameters {
+	u16 prox_th_min;
+	u16 prox_th_max;
+	u16 als_gate;
+	u16 als_gain;
+};
+
+struct lux_segment {
+	u32 ratio;
+	u32 k0;
+	u32 k1;
+};
+
+struct tmd2772_i2c_platform_data {
+	/* The following callback for power events received and handled by
+	   the driver.  Currently only for SUSPEND and RESUME */
+	int (*platform_power)(struct device *dev, enum tmd2772_pwr_state state);
+	int (*platform_init)(struct device *dev);
+	void (*platform_teardown)(struct device *dev);
+	char const *prox_name;
+	char const *als_name;
+	struct taos_parameters parameters;
+	struct taos_raw_settings const *raw_settings;
+	bool proximity_can_wake;
+	bool als_can_wake;
+	struct lux_segment *segment;
+	int segment_num;
+	int int_gpio;
+};
+
+#endif /*__KERNEL__*/
+#endif
diff --git a/include/linux/taos_common.h b/include/linux/taos_common.h
new file mode 100644
index 0000000..77a7965
--- /dev/null
+++ b/include/linux/taos_common.h
@@ -0,0 +1,92 @@
+/********************************************************************************
+* Device driver for monitoring ambient light intensity (lux) and proximity
+* detection for the TAOS TSL2x7x and TMD2x7x family of devices.
+*
+* Copyright (c) 2012, TAOS Corporation.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later vers ion.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA      02110-1301, USA.
+********************************************************************************/
+
+/*******************************************************************************
+*                                                                              *
+*       File Name:      taos_common.h                                          *
+*       Description:    Common file for ioctl and configuration definitions.   *
+*       		Used by kernel driver and driver access applications.  *
+*       		Please include this file, and <sys/ioctl.h> in your    *
+*                       driver access application program source.	       *
+*       Author:         John Koshi                                             *
+*       History:        09/16/2009 - Initial creation                          *
+*       		02/07/2010 - Add proximity			       *
+*                                                                              *
+*******************************************************************************/
+// ioctl numbers
+#define TAOS_IOCTL_MAGIC		0XCF
+#define TAOS_IOCTL_ALS_ON		_IO(TAOS_IOCTL_MAGIC, 1)
+#define TAOS_IOCTL_ALS_OFF		_IO(TAOS_IOCTL_MAGIC, 2)
+#define TAOS_IOCTL_ALS_DATA		_IOR(TAOS_IOCTL_MAGIC, 3, short)
+#define TAOS_IOCTL_ALS_CALIBRATE	_IO(TAOS_IOCTL_MAGIC, 4)
+#define TAOS_IOCTL_CONFIG_GET		_IOR(TAOS_IOCTL_MAGIC, 5, struct taos_cfg)
+#define TAOS_IOCTL_CONFIG_SET		_IOW(TAOS_IOCTL_MAGIC, 6, struct taos_cfg)
+#define TAOS_IOCTL_PROX_ON		_IO(TAOS_IOCTL_MAGIC, 7)
+#define TAOS_IOCTL_PROX_OFF		_IO(TAOS_IOCTL_MAGIC, 8)
+#define TAOS_IOCTL_PROX_DATA		_IOR(TAOS_IOCTL_MAGIC, 9, struct taos_prox_info)
+#define TAOS_IOCTL_PROX_EVENT		_IO(TAOS_IOCTL_MAGIC, 10)
+#define TAOS_IOCTL_PROX_CALIBRATE	_IO(TAOS_IOCTL_MAGIC, 11)
+
+#define TAOS_IOCTL_SENSOR_ON		_IO(TAOS_IOCTL_MAGIC, 12)
+#define TAOS_IOCTL_SENSOR_OFF		_IO(TAOS_IOCTL_MAGIC, 13)
+#define TAOS_IOCTL_SENSOR_CONFIG	_IOW(TAOS_IOCTL_MAGIC, 14, struct taos_cfg)
+#define TAOS_IOCTL_SENSOR_CHECK		_IO(TAOS_IOCTL_MAGIC, 15)
+#define TAOS_IOCTL_SENSOR_test		_IO(TAOS_IOCTL_MAGIC, 16)
+
+
+// device configuration
+struct taos_cfg {
+	u32	calibrate_target;
+	u16	als_time;
+	u16	scale_factor;
+	u16	gain_trim;
+	u16	prox_threshold_hi;
+	u16	prox_threshold_lo;
+	u16	als_threshold_hi;
+	u16	als_threshold_lo;
+	u8	filter_history;
+	u8	filter_count;
+	u8	gain;
+	u8	prox_int_time;
+	u8	prox_adc_time;
+	u8	prox_wait_time;
+	u8	prox_intr_filter;
+	u8	prox_config;
+	u8	prox_pulse_cnt;
+	u8	prox_gain;
+};
+
+// proximity data
+struct taos_prox_info {
+	u16	prox_clear;
+	u16	prox_data;
+	int	prox_event;
+};
+
+struct tmd2771x_platform_data {
+	u8	pdrive;
+	u8	ppcount;
+	int	irq_gpio;
+	unsigned short real_i2c_addr;
+//	int	(*setup_resources)(void);
+//	int	(*release_resources)(void);
+};
+
-- 
1.7.8.3

