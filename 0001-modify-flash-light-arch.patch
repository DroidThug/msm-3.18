From 25f25886fbe9db78db7547b9302a7aa1cd5641ce Mon Sep 17 00:00:00 2001
From: lnxbuild <lnxbuild@localhost>
Date: Sat, 12 Oct 2013 12:14:00 +0800
Subject: [PATCH] modify flash light arch

Change-Id: I19d9ac9d6069656cb298c277f5a9d8b84ee3c86e
---
 arch/arm/boot/dts/msm8610-qrd-camera-sensor.dtsi   |   27 +-
 drivers/leds/Kconfig                               |    4 -
 drivers/leds/Makefile                              |    1 -
 drivers/leds/leds-msm-i2c-flash.c                  |  733 --------------------
 drivers/leds/leds-msm-i2c-flash.h                  |   75 --
 .../platform/msm/camera_v2/sensor/flash/Makefile   |    3 +-
 .../msm/camera_v2/sensor/flash/flash_lm3642.c      |  196 ++++++
 .../msm/camera_v2/sensor/flash/msm_led_flash.h     |    2 +
 .../camera_v2/sensor/flash/msm_led_i2c_trigger.c   |  185 +++--
 9 files changed, 292 insertions(+), 934 deletions(-)
 delete mode 100644 drivers/leds/leds-msm-i2c-flash.c
 delete mode 100644 drivers/leds/leds-msm-i2c-flash.h
 create mode 100644 drivers/media/platform/msm/camera_v2/sensor/flash/flash_lm3642.c

diff --git a/arch/arm/boot/dts/msm8610-qrd-camera-sensor.dtsi b/arch/arm/boot/dts/msm8610-qrd-camera-sensor.dtsi
index 112c6b3..5a76e18 100644
--- a/arch/arm/boot/dts/msm8610-qrd-camera-sensor.dtsi
+++ b/arch/arm/boot/dts/msm8610-qrd-camera-sensor.dtsi
@@ -11,24 +11,15 @@
  * GNU General Public License for more details.
  */
 &i2c3 {
-       flashlight: qcom,led-flash@63 {
-               cell-index = <0>;
-               reg = <0x63>;
-               qcom,slave-id = <0x63 0x00 0x0011>;
-               compatible = "qcom,led-flash";
-               linux,name = "flashlight";
-               qcom,current = <200>;
-               qcom,gpio-flash = <&msmgpio 18 0>;
-               linux,default-trigger = "flashlight-trigger";
-       };
-};
-
-/{
-       led_flash0: qcom,camera-led-flash {
-               cell-index = <0>;
-               compatible = "qcom,camera-led-flash";
-               qcom,flash-type = <1>;
-               qcom,flash-source = <&flashlight>;
+       led_flash0: qcom,led-flash@63 {
+		cell-index = <0>;
+		reg = <0x63>;
+		qcom,slave-id = <0x63 0x00 0x0011>;
+		compatible = "qcom,led-flash";
+		qcom,flash-name = "lm3642";
+		qcom,flash-type = <1>;
+		gpios = <&msmgpio 18 0>;
+		qcom,gpio-flash-en = <0>;
        };
 };
 
diff --git a/drivers/leds/Kconfig b/drivers/leds/Kconfig
index d561c6e..2e98740 100644
--- a/drivers/leds/Kconfig
+++ b/drivers/leds/Kconfig
@@ -314,10 +314,6 @@ config LEDS_QPNP
 	  To compile this driver as a module, choose M here: the module will
 	  be called leds-qpnp.
 
-config LEDS_MSM_FLASH
-	bool "Support for GPIO Flash LEDs"
-        default y
-
 config LEDS_MSM_GPIO_FLASH
 	tristate "Support for GPIO Flash LEDs"
 	depends on GPIO_MSM_V3
diff --git a/drivers/leds/Makefile b/drivers/leds/Makefile
index 9934cf3..1760a41 100644
--- a/drivers/leds/Makefile
+++ b/drivers/leds/Makefile
@@ -56,7 +56,6 @@ obj-$(CONFIG_LEDS_QCIBL)		+= leds-qci-backlight.o
 obj-$(CONFIG_LEDS_MSM_PDM)		+= leds-msm-pdm.o
 obj-$(CONFIG_LEDS_MSM_TRICOLOR)		+= leds-msm-tricolor.o
 obj-$(CONFIG_LEDS_MSM_GPIO_FLASH)	+= leds-msm-gpio-flash.o
-obj-$(CONFIG_LEDS_MSM_FLASH)		+= leds-msm-i2c-flash.o
 
 # LED SPI Drivers
 obj-$(CONFIG_LEDS_DAC124S085)		+= leds-dac124s085.o
diff --git a/drivers/leds/leds-msm-i2c-flash.c b/drivers/leds/leds-msm-i2c-flash.c
deleted file mode 100644
index ef00b68..0000000
--- a/drivers/leds/leds-msm-i2c-flash.c
+++ /dev/null
@@ -1,733 +0,0 @@
-#include <linux/i2c.h>
-#include <linux/input.h>
-#include <linux/module.h>
-#include <linux/slab.h>
-#include <linux/of_gpio.h>
-#include <linux/delay.h>
-#include <linux/leds.h>
-
-#include "leds-msm-i2c-flash.h"
-
-#define ENABLE_REGISTER 0x0A
-#define MODE_BIT_MASK 0x03
-#define MODE_BIT_STANDBY 0x00
-#define MODE_BIT_INDICATOR 0x01
-#define MODE_BIT_TORCH 0x02
-#define MODE_BIT_FLASH 0x03
-#define ENABLE_BIT_FLASH 0x20
-#define ENABLE_BIT_TORCH 0x10
-
-#define CURRENT_REGISTER 0x09
-#define CURRENT_TORCH_MASK 0x70
-#define CURRENT_TORCH_SHIFT 4
-#define CURRENT_FLASH_MASK 0x0F
-#define CURRENT_FLASH_SHIFT 0
-
-#define FLASH_FEATURE_REGISTER 0x08
-#define FLASH_TIMEOUT_MASK 0x07
-#define FLASH_TIMEOUT_SHIFT 0
-
-#define FLASH_CHIP_ID_MASK 0x07
-#define FLASH_CHIP_ID 0x0
-
-#define LED_TRIGGER_DEFAULT		"none"
-
-int turn_on_torch(struct lm3642_data* data);
-int turn_off_torch(struct lm3642_data* data);
-
-static struct lm3642_data* lm3642;
-
-static void lm3642_clear_error_flag(struct lm3642_data* data)
-{
-	int err = 0;
-    struct i2c_client* client = data->client;
-
-	err = i2c_smbus_read_byte_data(client, 0x0B);
-    if(err < 0) {
-        printk("read current register fail!\n");
-    } else {
-        printk("lm3642. [%02X] = %02X\n", 0x0B, err);
-    }
-}
-
-static int atoi(const char *psz_buf)
-{
-	const char *pch = psz_buf;
-	int ret = 0;
-
-	while (' ' == *pch)
-		pch++;
-
-	while(pch != NULL && *pch >= '0' && *pch <= '9') {
-        ret = ret * 10 + (*pch - '0');
-        pch++;
-    }
-
-	return ret;
-}
-
-int convert_flash_timeout(enum flash_timeout to) {
-    int timeout = 300;
-    if(to <= FLASH_TIMEOUT_MAX) {
-        timeout = 100 * (1 + (int)to);
-    }
-    return timeout;
-}
-
-int turn_on_torch(struct lm3642_data* data) {
-    int err = 0;
-    struct i2c_client* client = data->client;
-    struct lm3642_platform_data* pdata = data->pdata;
-
-    if(pdata->status == TORCH_ON) {
-        return 0;
-    }
-	
-	lm3642_clear_error_flag(data);
-    // Set torch mode. 
-    err = i2c_smbus_write_byte_data(client, ENABLE_REGISTER, MODE_BIT_TORCH/* | ENABLE_BIT_TORCH*/);
-    if(err < 0) {
-        printk("write i2c register failed! line: %d\n", __LINE__);
-        return err;
-    }
-
-
-    pdata->status = TORCH_ON;
-
-    return err;
-}
-
-int turn_off_torch(struct lm3642_data* data) {
-    int err = 0;
-    struct i2c_client* client = data->client;
-    struct lm3642_platform_data* pdata = data->pdata;
-
-    if(pdata->status == TORCH_OFF) {
-        return 0;
-    }
-
-	lm3642_clear_error_flag(data);
-    // Set torch mode. 
-    err = i2c_smbus_write_byte_data(client, ENABLE_REGISTER, MODE_BIT_STANDBY);
-    if(err < 0) {
-        printk("write i2c register failed! line: %d\n", __LINE__);
-        return err;
-    }
-	
-    // pull down flash pins
-    err = gpio_direction_output(pdata->flash, 0);
-    if (err) {
-        printk("%s: Failed to set gpio %d\n", __func__,
-               pdata->flash);
-        return err;
-    }
-
-    pdata->status = TORCH_OFF;
-
-    return err;
-}
-
-static int turn_on_flash(struct lm3642_data* data)
-{
-    int err = 0;
-    struct i2c_client* client = data->client;
-    struct lm3642_platform_data* pdata = data->pdata;
-
-	lm3642_clear_error_flag(data);
-    // Set flash mode and only enable strobe pin
-    err = i2c_smbus_write_byte_data(client, ENABLE_REGISTER, MODE_BIT_FLASH | ENABLE_BIT_FLASH);
-    if(err < 0) {
-        printk("write i2c register failed! line: %d\n", __LINE__);
-        return err;
-    }
-
-    err = gpio_direction_output(pdata->flash, 1);
-    if (err) {
-        printk("%s: Failed to set gpio %d\n", __func__,
-               pdata->flash);
-        return err;
-    }
-
-    return err;
-}
-
-static int turn_off_flash(struct lm3642_data* data)
-{
-    int err = 0;
-    struct i2c_client* client = data->client;
-    struct lm3642_platform_data* pdata = data->pdata;
-
-	lm3642_clear_error_flag(data);
-    // Set flash mode and only enable strobe pin
-    err = i2c_smbus_write_byte_data(client, ENABLE_REGISTER, MODE_BIT_STANDBY);
-    if(err < 0) {
-        printk("write i2c register failed! line: %d\n", __LINE__);
-        return err;
-    }
-
-    err = gpio_direction_output(pdata->flash, 0);
-    if (err) {
-        printk("%s: Failed to set gpio %d\n", __func__,
-               pdata->flash);
-        return err;
-    }
-
-    return err;
-}
-
-
-
-int trigger_flash(struct lm3642_data* data) {
-    int err = 0;
-    struct i2c_client* client = data->client;
-    struct lm3642_platform_data* pdata = data->pdata;
-
-	lm3642_clear_error_flag(data);
-    // Set flash mode and only enable strobe pin
-    err = i2c_smbus_write_byte_data(client, ENABLE_REGISTER, MODE_BIT_FLASH | ENABLE_BIT_FLASH);
-    if(err < 0) {
-        printk("write i2c register failed! line: %d\n", __LINE__);
-        return err;
-    }
-
-    err = gpio_direction_output(pdata->flash, 1);
-    if (err) {
-        printk("%s: Failed to set gpio %d\n", __func__,
-               pdata->flash);
-        return err;
-    }
-
-    msleep(convert_flash_timeout(pdata->timeout));
-
-    err = gpio_direction_output(pdata->flash, 0);
-    if (err) {
-        printk("%s: Failed to set gpio %d\n", __func__,
-               pdata->flash);
-        return err;
-    }
-
-    return err;
-}
-
-int set_flash_current(struct lm3642_data* data, enum flash_current_level i)
-{
-    int err = 0;
-    struct i2c_client* client = data->client;
-    struct lm3642_platform_data* pdata = data->pdata;
-
-    pdata->flash_current = i;
-	
-	lm3642_clear_error_flag(data);
-	
-    err = i2c_smbus_write_byte_data(client, CURRENT_REGISTER,
-        (pdata->flash_current << CURRENT_FLASH_SHIFT) | (pdata->torch_current << CURRENT_TORCH_SHIFT));
-    if(err < 0) {
-        printk("lm3642 write i2c faile\n");
-    }
-
-    return err;
-}
-
-int set_torch_current(struct lm3642_data* data, enum torch_current_level i)
-{
-    int err = 0;
-    struct i2c_client* client = data->client;
-    struct lm3642_platform_data* pdata = data->pdata;
-
-    pdata->torch_current = i;
-	
-	lm3642_clear_error_flag(data);
-	
-    err = i2c_smbus_write_byte_data(client, CURRENT_REGISTER,
-        (pdata->flash_current << CURRENT_FLASH_SHIFT) | (pdata->torch_current << CURRENT_TORCH_SHIFT));
-    if(err < 0) {
-        printk("lm3642 write i2c faile\n");
-    }
-
-    return err;
-}
-
-int set_flash_timeout(struct lm3642_data* data, enum flash_timeout to)
-{
-    int err = 0, tmp = 0;
-    struct i2c_client* client = data->client;
-    struct lm3642_platform_data* pdata = data->pdata;
-
-    pdata->timeout = to;
-
-    tmp = i2c_smbus_read_byte_data(client, FLASH_FEATURE_REGISTER);
-    if(tmp < 0) {
-        printk("%s read i2c fail\n", __func__);
-        return tmp;
-    }
-	
-	err = i2c_smbus_read_byte_data(client, 0x0B);
-    if(err < 0) {
-        printk("read current register fail!\n");
-    } else {
-        printk("lm3642. [%02X] = %02X\n", 0x0B, err);
-    }
-
-    err = i2c_smbus_write_byte_data(client, FLASH_FEATURE_REGISTER,
-        (((int)pdata->timeout << FLASH_TIMEOUT_SHIFT) & FLASH_TIMEOUT_MASK)
-        | (tmp & ~FLASH_TIMEOUT_MASK));
-    if(err < 0) {
-        printk("%s write i2c faile\n", __func__);
-    }
-
-    return err;
-}
-
-
-static ssize_t lm3642_flash_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
-{
-    struct lm3642_data* data = dev_get_drvdata(dev);
-    struct i2c_client* client = data->client;
-    int ret = 0, count = 0;;
-
-    ret = i2c_smbus_read_byte_data(client, CURRENT_REGISTER);
-    if(ret < 0) {
-        printk("read current register fail!\n");
-    } else {
-        ret = ret & CURRENT_FLASH_MASK;
-        count = sprintf(buf, "%d\n", ret);
-    }
-
-    return count;
-}
-
-static ssize_t lm3642_flash_store(struct device *dev,
-				struct device_attribute *attr,
-				const char *buf, size_t size)
-{
-    struct lm3642_data* data = dev_get_drvdata(dev);
-
-    trigger_flash(data);
-
-	return size;
-}
-
-static ssize_t lm3642_torch_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
-{
-    struct lm3642_data* data = dev_get_drvdata(dev);
-    int count = 0;
-
-	lm3642_clear_error_flag(data);
-
-    switch(data->pdata->status) {
-    case TORCH_ON:
-        count = 3; 
-        strncpy(buf, "ON\n", count);
-        break;
-    case TORCH_OFF:
-        count = 4;
-        strncpy(buf, "OFF\n", count);
-        break;
-    }
-
-    return count;
-}
-static ssize_t lm3642_torch_store(struct device *dev,
-				struct device_attribute *attr,
-				const char *buf, size_t size)
-{
-    struct lm3642_data* data = dev_get_drvdata(dev);
-
-    if(0 == strncmp("0\n", buf, 2) ) {
-        // input "0", turn off torch
-        turn_off_torch(data);
-    } else {
-        // input non-"0", 
-        turn_on_torch(data);
-    }
-
-    return size;
-}
-
-static ssize_t lm3642_torch_current_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
-{
-    char TORCH_CURRENTS[8][10] = {"48.4mA", "93.74mA", "140.63mA", "187.5mA", "234.38mA", "281.25mA", "328.13mA", "375mA"};
-    struct lm3642_data* data = dev_get_drvdata(dev);
-    struct i2c_client* client = data->client;
-    int ret = 0, count = 0;
-
-    ret = i2c_smbus_read_byte_data(client, CURRENT_REGISTER);
-    if(ret < 0) {
-        printk("read current register fail!\n");
-    } else {
-        ret = (ret & CURRENT_TORCH_MASK) >> CURRENT_TORCH_SHIFT ;
-        count = sprintf(buf, "%s\n", TORCH_CURRENTS[ret]);
-    }
-
-    return count;
-}
-
-// the input should be 1-8. 0 is NOT used since atoi would return 0 if non-numeric
-static ssize_t lm3642_torch_current_store(struct device *dev,
-				struct device_attribute *attr,
-				const char *buf, size_t size)
-{
-    struct lm3642_data* data = dev_get_drvdata(dev);
-    int ret = 0;
-
-    if(buf == NULL) {
-        printk("buf NULL\n");
-        return size;
-    }
-
-    ret = atoi(buf);
-    if(ret > (1 + (int)TORCH_I_MAX) || ret < 1) {
-        printk("invalid input: %s\n", buf);
-    } else {
-        set_torch_current(data, (enum torch_current_level) ret - 1);
-    }
-
-    return size;
-}
-
-static ssize_t lm3642_flash_current_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
-{
-    char FLASH_CURRENTS[16][16] = {"93.75mA", "187.5mA", "281.25mA", "375mA",
-        "468.75mA", "562.5mA", "656.25mA", "750mA",
-        "843.75mA", "937.5mA", "1031.25mA", "1125mA",
-        "1218.75mA", "1312.5mA", "1406.25mA", "1500mA"
-        };
-    struct lm3642_data* data = dev_get_drvdata(dev);
-    struct i2c_client* client = data->client;
-    int ret = 0, count = 0;
-
-    ret = i2c_smbus_read_byte_data(client, CURRENT_REGISTER);
-    if(ret < 0) {
-        printk("read current register fail!\n");
-    } else {
-        ret = (ret & CURRENT_FLASH_MASK) >> CURRENT_FLASH_SHIFT ;
-        count = sprintf(buf, "%s\n", FLASH_CURRENTS[ret]);
-    }
-
-    return count;
-}
-static ssize_t lm3642_flash_current_store(struct device *dev,
-				struct device_attribute *attr,
-				const char *buf, size_t size)
-{
-    struct lm3642_data* data = dev_get_drvdata(dev);
-    int ret = 0;
-
-    if(buf == NULL) {
-        printk("buf NULL. %s\n", __func__);
-        return size;
-    }
-
-    ret = atoi(buf);
-    if(ret > (1 + (int)FLASH_I_MAX) || ret < 1) {
-        printk("invalid input: %s\n", buf);
-    } else {
-        set_flash_current(data, (enum flash_current_level) ret - 1);
-    }
-
-    return size;
-}
-
-static ssize_t lm3642_flash_timeout_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
-{
-    char FLASH_TIMEOUTS[8][8] = {
-        "100ms", "200ms", "300ms", "400ms", "500ms", "600ms", "700ms", "800ms"
-        };
-    struct lm3642_data* data = dev_get_drvdata(dev);
-    struct i2c_client* client = data->client;
-    int ret = 0, count = 0;
-
-    ret = i2c_smbus_read_byte_data(client, FLASH_FEATURE_REGISTER);
-    if(ret < 0) {
-        printk("read current register fail!\n");
-    } else {
-        ret = (ret & FLASH_TIMEOUT_MASK) >> FLASH_TIMEOUT_SHIFT ;
-        count = sprintf(buf, "%s\n", FLASH_TIMEOUTS[ret]);
-    }
-
-    return count;
-}
-
-static ssize_t lm3642_flash_timeout_store(struct device *dev,
-				struct device_attribute *attr,
-				const char *buf, size_t size)
-{
-    struct lm3642_data* data = dev_get_drvdata(dev);
-    int ret = 0;
-
-    if(buf == NULL) {
-        printk("buf NULL. %s\n", __func__);
-        return size;
-    }
-
-    ret = atoi(buf);
-    if(ret > (1 + (int)FLASH_TIMEOUT_MAX) || ret < 1) {
-        printk("invalid input: %s\n", buf);
-    } else {
-        set_flash_timeout(data, (enum flash_timeout) ret - 1);
-    }
-
-    return size;
-}
-
-static void led_i2c_brightness_set_led_work(struct work_struct *work)
-{
-    if(lm3642->pdata->brightness > LED_HALF) {
-        turn_off_torch(lm3642);
-        turn_on_flash(lm3642);
-    } else if(lm3642->pdata->brightness > LED_OFF) {
-        turn_off_flash(lm3642);
-        turn_on_torch(lm3642);
-    } else {
-        turn_off_flash(lm3642);
-        turn_off_torch(lm3642);
-    }
-}
-
-static void led_i2c_brightness_set(struct led_classdev *led_cdev,
-				    enum led_brightness value)
-{
-	lm3642->pdata->brightness = value;
-	schedule_work(&lm3642->pdata->work);
-}
-
-static enum led_brightness led_i2c_brightness_get(struct led_classdev *led_cdev)
-{
-    struct lm3642_platform_data *flash_led =
-	    container_of(led_cdev, struct lm3642_platform_data, cdev);
-	return flash_led->brightness;
-}
-
-static DEVICE_ATTR(flashlight, 0664, lm3642_flash_show, lm3642_flash_store); // for test only
-static DEVICE_ATTR(torch, 0664, lm3642_torch_show, lm3642_torch_store);
-static DEVICE_ATTR(torch_current, 0664, lm3642_torch_current_show, lm3642_torch_current_store);
-static DEVICE_ATTR(flash_current, 0664, lm3642_flash_current_show, lm3642_flash_current_store);
-static DEVICE_ATTR(flash_timeout, 0664, lm3642_flash_timeout_show, lm3642_flash_timeout_store);
-
-static int __devexit lm3642_remove(struct i2c_client *client)
-{
-    struct lm3642_data* data = i2c_get_clientdata(client);
-
-    device_remove_file(&client->dev, &dev_attr_flashlight);
-	device_remove_file(&client->dev, &dev_attr_torch);
-	device_remove_file(&client->dev, &dev_attr_flash_current);
-	device_remove_file(&client->dev, &dev_attr_torch_current);
-	device_remove_file(&client->dev, &dev_attr_flash_timeout);
-
-    if (gpio_is_valid(data->pdata->flash))
-		gpio_free(data->pdata->flash);
-
-    kfree(data);
-    return 0;
-}
-
-static int lm3642_probe(struct i2c_client *client,
-			   const struct i2c_device_id *id)
-{
-    int err = 0;
-    const char *temp_str;
-    struct lm3642_platform_data *pdata;
-    struct lm3642_data* data;
-    struct device_node *node = client->dev.of_node;
-
-    if (node) {
-		pdata = devm_kzalloc(&client->dev,
-			sizeof(struct lm3642_platform_data), GFP_KERNEL);
-		if (!pdata) {
-			dev_err(&client->dev, "Failed to allocate memory\n");
-			return -ENOMEM;
-		}
-	} else {
-		pdata = client->dev.platform_data;
-    }
-
-	if (!pdata) {
-		dev_err(&client->dev, "Invalid pdata\n");
-		return -EINVAL;
-	}
-
-	INIT_WORK(&pdata->work, led_i2c_brightness_set_led_work);
-
-	pdata->brightness = 0;
-    pdata->flash_current = FLASH_I_DEFAULT;
-    pdata->torch_current = TORCH_I_DEFAULT;
-    pdata->timeout = FLASH_TIMEOUT_DEFAULT;
-    pdata->status = TORCH_OFF;
-    pdata->cdev.default_trigger = LED_TRIGGER_DEFAULT;
-
-    err = of_property_read_string(node, "linux,default-trigger", &temp_str);
-	if (!err) {
-		pdata->cdev.default_trigger = temp_str;
-    }
-
-    err = of_property_read_string(node, "linux,name", &pdata->cdev.name);
-	if (err) {
-		dev_err(&client->dev, "%s: Failed to read linux name. rc = %d\n",
-			__func__, err);
-		goto free_platform_data;
-	}
-
-    pdata->cdev.max_brightness = LED_FULL;
-	pdata->cdev.brightness_set = led_i2c_brightness_set;
-	pdata->cdev.brightness_get = led_i2c_brightness_get;
-
-    err = led_classdev_register(&client->dev, &pdata->cdev);
-	if (err) {
-		dev_err(&client->dev, "%s: Failed to register led dev. rc = %d\n",
-			__func__, err);
-		goto free_platform_data;
-	}
-
-    // Get gpio number of flash from dts(i)
-    pdata->flash = of_get_named_gpio(node, "qcom,gpio-flash", 0);
-    if (pdata->flash < 0) {
-        printk("of_get_named_gpio failed. Line: %d. %s\n", __LINE__, __func__);
-		goto free_platform_data;
-	} else {
-		err = gpio_request(pdata->flash, "FLASH_NOW");
-        printk("flash = %d\n", pdata->flash);
-		if (err) {
-            printk("gpio_request failed. Line: %d. %s\n", __LINE__, __func__);
-			goto free_platform_data;
-		}
-	}
-
-    // set gpio of flash as output. 
-	gpio_tlmm_config(GPIO_CFG(pdata->flash, 0,
-				  GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL,
-				  GPIO_CFG_2MA), GPIO_CFG_ENABLE);
-
-    err = gpio_direction_output(pdata->flash, 0);
-	if (err) {
-		printk("%s: Failed to set gpio %d\n", __func__,
-		       pdata->flash);
-		goto free_platform_data;
-	}
-
-    // Check and setup i2c client
-    if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
-		dev_err(&client->dev, "I2C not supported\n");
-		goto free_platform_data;
-	}
-
-    if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_I2C_BLOCK))
-	{
-	    dev_err(&client->dev, "%s: I2C error2!\n", __func__);
-		goto free_platform_data;
-	}
-
-	data = kzalloc(sizeof(struct lm3642_data), GFP_KERNEL);
-    if (!data) {
-		//dev_err(&client->dev, "Not enough memory\n");
-		printk("%s: Not enough memory\n", __func__);
-		goto free_platform_data;
-	}
-
-	data->client = client;
-	data->pdata = pdata;
-
-	i2c_set_clientdata(client, data);
-    lm3642 = data;
-
-    // create file sysfs
-    err = device_create_file(&client->dev, &dev_attr_flashlight);
-    if(err) {
-        goto free_data;
-    }
-
-    err = device_create_file(&client->dev, &dev_attr_torch);
-    if(err) {
-        goto free_lm3642_sys_flashlight;
-    }
-
-    err = device_create_file(&client->dev, &dev_attr_torch_current);
-    if(err) {
-        goto free_lm3642_sys_torch;
-    }
-
-    err = device_create_file(&client->dev, &dev_attr_flash_current);
-    if(err) {
-        goto free_lm3642_sys_torch_current;
-    }
-
-    err = device_create_file(&client->dev, &dev_attr_flash_timeout);
-    if(err) {
-        goto free_lm3642_sys_flash_current;
-    }
-
-    return 0;
-free_lm3642_sys_flash_current:
-    device_remove_file(&client->dev, &dev_attr_flash_current);
-free_lm3642_sys_torch_current:
-    device_remove_file(&client->dev, &dev_attr_torch_current);
-free_lm3642_sys_torch:
-    device_remove_file(&client->dev, &dev_attr_torch);
-free_lm3642_sys_flashlight:
-	device_remove_file(&client->dev, &dev_attr_flashlight);
-    printk("device_create_file failed\n");
-free_data: 
-    kfree(data);
-free_platform_data:
-    if(node) {
-        kfree(pdata);
-    }
-    return err;
-
-
-}
-
-
-static const struct i2c_device_id lm3642_id[] = {
-	{"lm3642", 0},
-	{},
-};
-
-MODULE_DEVICE_TABLE(i2c, lm3642_id);
-
-#ifdef CONFIG_OF
-static struct of_device_id lm3642_match_table[] = {
-	{ .compatible = "qcom,led-flash",},
-	{ },
-};
-#else
-#define lm3642_match_table NULL
-#endif
-
-
-static struct i2c_driver lm3642_driver = {
-	.probe = lm3642_probe,
-	.remove = __devexit_p(lm3642_remove),
-	.driver = {
-		   .name = "lm3642",
-		   .owner = THIS_MODULE,
-		   .of_match_table = lm3642_match_table,
-/* Do NOT implements PM at first. We just verify the funciton.
-#ifdef CONFIG_PM
-		   .pm = &lm3642_pm_ops,
-#endif
-*/
-	   },
-	.id_table = lm3642_id,
-};
-
-static int __init lm3642_init(void)
-{
-	return i2c_add_driver(&lm3642_driver);
-}
-
-module_init(lm3642_init);
-
-static void __exit lm3642_exit(void)
-{
-	i2c_del_driver(&lm3642_driver);
-}
-module_exit(lm3642_exit);
-
-MODULE_DESCRIPTION("For lm3642 camera flash light driver");
-MODULE_LICENSE("GPL v2");
-
diff --git a/drivers/leds/leds-msm-i2c-flash.h b/drivers/leds/leds-msm-i2c-flash.h
deleted file mode 100644
index 0a5a3d3..0000000
--- a/drivers/leds/leds-msm-i2c-flash.h
+++ /dev/null
@@ -1,75 +0,0 @@
-#ifndef __LEDS_MSM_I2C_FLASH__
-#define __LEDS_MSM_I2C_FLASH__
-
-enum torch_current_level {
-    // in the unit of mA
-    TORCH_I_48P4, //0
-    TORCH_I_93P74, // 1
-    TORCH_I_140P63, // 2
-    TORCH_I_187P5, // 3
-    TORCH_I_234P38, // 4
-    TORCH_I_281P25, // 5
-    TORCH_I_328P13, // 6
-    TORCH_I_375, //7
-    TORCH_I_MAX = TORCH_I_375,
-    TORCH_I_DEFAULT = TORCH_I_48P4,
-};
-
-enum flash_current_level {
-    // in the unit of mA
-    FLASH_I_93P75, // 0
-    FLASH_I_187P5, // 1
-    FLASH_I_281P25, // 2
-    FLASH_I_375, // 3
-    FLASH_I_468P75, // 4
-    FLASH_I_562P5, // 5
-    FLASH_I_656P25, // 6
-    FLASH_I_750, // 7
-    FLASH_I_843P75, // 8
-    FLASH_I_937P5, // 9
-    FLASH_I_1031P25, // 10
-    FLASH_I_1125, // 11
-    FLASH_I_1218P75, // 12
-    FLASH_I_1312P5, // 13
-    FLASH_I_1406P25, // 14
-    FLASH_I_1500, // 
-    FLASH_I_MAX = FLASH_I_1500,
-    FLASH_I_DEFAULT = FLASH_I_1500,
-};
-
-enum flash_timeout {
-    // in the unit of milli-second
-    FLASH_TIMEOUT_100,
-    FLASH_TIMEOUT_200,
-    FLASH_TIMEOUT_300,
-    FLASH_TIMEOUT_400,
-    FLASH_TIMEOUT_500,
-    FLASH_TIMEOUT_600,
-    FLASH_TIMEOUT_700,
-    FLASH_TIMEOUT_800,
-    FLASH_TIMEOUT_MAX = FLASH_TIMEOUT_800,
-    FLASH_TIMEOUT_DEFAULT = FLASH_TIMEOUT_300,
-};
-
-enum torch_status {
-    TORCH_ON,
-    TORCH_OFF,
-};
-
-struct lm3642_platform_data {
-    enum torch_current_level torch_current;
-    enum torch_status status;
-    int flash; // pin number
-    enum flash_current_level flash_current;
-    enum flash_timeout timeout;    
-    int brightness;
-	struct work_struct work;
-    struct led_classdev cdev;
-};
-
-struct lm3642_data {
-    struct i2c_client *client;
-    struct lm3642_platform_data *pdata;
-};
-
-#endif // end of __LEDS_MSM_I2C_FLASH__
diff --git a/drivers/media/platform/msm/camera_v2/sensor/flash/Makefile b/drivers/media/platform/msm/camera_v2/sensor/flash/Makefile
index 62102cb..e5230f8 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/flash/Makefile
+++ b/drivers/media/platform/msm/camera_v2/sensor/flash/Makefile
@@ -3,4 +3,5 @@ ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/io
 obj-$(CONFIG_MSMB_CAMERA) += msm_led_flash.o
 obj-$(CONFIG_MSMB_CAMERA) += msm_led_trigger.o
 obj-$(CONFIG_MSMB_CAMERA) += msm_led_i2c_trigger.o
-obj-$(CONFIG_MSMB_CAMERA) += adp1660.o
+#obj-$(CONFIG_MSMB_CAMERA) += adp1660.o
+obj-$(CONFIG_MSMB_CAMERA)	+= flash_lm3642.o
diff --git a/drivers/media/platform/msm/camera_v2/sensor/flash/flash_lm3642.c b/drivers/media/platform/msm/camera_v2/sensor/flash/flash_lm3642.c
new file mode 100644
index 0000000..d1df916
--- /dev/null
+++ b/drivers/media/platform/msm/camera_v2/sensor/flash/flash_lm3642.c
@@ -0,0 +1,196 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <linux/module.h>
+#include <linux/export.h>
+#include "msm_led_flash.h"
+
+#define FLASH_NAME "qcom,led-flash"
+
+//#define CONFIG_MSMB_CAMERA_DEBUG
+#ifdef CONFIG_MSMB_CAMERA_DEBUG
+#define LM3642_DBG(x...) printk(KERN_ERR "[LM3642]" x)
+#else
+#define LM3642_DBG(x...)
+#endif
+
+#define ENABLE_REGISTER 0x0A
+#define MODE_BIT_MASK 0x03
+#define MODE_BIT_STANDBY 0x00
+#define MODE_BIT_INDICATOR 0x01
+#define MODE_BIT_TORCH 0x02
+#define MODE_BIT_FLASH 0x03
+#define ENABLE_BIT_FLASH 0x20
+#define ENABLE_BIT_TORCH 0x10
+
+#define CURRENT_REGISTER 0x09
+#define CURRENT_TORCH_MASK 0x70
+#define CURRENT_TORCH_SHIFT 4
+#define CURRENT_FLASH_MASK 0x0F
+#define CURRENT_FLASH_SHIFT 0
+
+#define FLASH_FEATURE_REGISTER 0x08
+#define FLASH_TIMEOUT_MASK 0x07
+#define FLASH_TIMEOUT_SHIFT 0
+
+#define FLASH_CHIP_ID_MASK 0x07
+#define FLASH_CHIP_ID 0x0
+
+
+static struct msm_led_flash_ctrl_t fctrl;
+static struct i2c_driver lm3642_i2c_driver;
+
+static struct msm_camera_i2c_reg_array lm3642_init_array[] = {
+	{ENABLE_REGISTER, MODE_BIT_STANDBY},
+};
+
+static struct msm_camera_i2c_reg_array lm3642_off_array[] = {
+	{ENABLE_REGISTER, MODE_BIT_STANDBY},
+};
+
+static struct msm_camera_i2c_reg_array lm3642_release_array[] = {
+	{ENABLE_REGISTER, MODE_BIT_STANDBY},
+};
+
+static struct msm_camera_i2c_reg_array lm3642_low_array[] = {
+	{ENABLE_REGISTER, MODE_BIT_TORCH},
+};
+
+static struct msm_camera_i2c_reg_array lm3642_high_array[] = {
+	{ENABLE_REGISTER, MODE_BIT_FLASH | ENABLE_BIT_FLASH},
+};
+
+static void __exit msm_flash_lm3642_i2c_remove(void)
+{
+	i2c_del_driver(&lm3642_i2c_driver);
+	return;
+}
+
+static const struct of_device_id lm3642_i2c_trigger_dt_match[] = {
+	{.compatible = "qcom,led-flash"},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, lm3642_i2c_trigger_dt_match);
+
+static const struct i2c_device_id flash_i2c_id[] = {
+	{"qcom,led-flash", (kernel_ulong_t)&fctrl},
+	{ }
+};
+
+static const struct i2c_device_id lm3642_i2c_id[] = {
+	{FLASH_NAME, (kernel_ulong_t)&fctrl},
+	{ }
+};
+
+static int msm_flash_lm3642_i2c_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	LM3642_DBG("%s entry\n", __func__);
+	if (!id) {
+		pr_err("msm_flash_lm3642_i2c_probe: id is NULL");
+		id = lm3642_i2c_id;
+	}
+
+	return msm_flash_i2c_probe(client, id);
+}
+
+static struct i2c_driver lm3642_i2c_driver = {
+	.id_table = lm3642_i2c_id,
+	.probe  = msm_flash_lm3642_i2c_probe,
+	.remove = __exit_p(msm_flash_lm3642_i2c_remove),
+	.driver = {
+		.name = FLASH_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = lm3642_i2c_trigger_dt_match,
+	},
+};
+
+static int __init msm_flash_lm3642_i2c_add_driver(void)
+{
+	LM3642_DBG("%s entry\n", __func__);
+	return i2c_add_driver(&lm3642_i2c_driver);
+}
+
+static struct msm_camera_i2c_client lm3642_i2c_client = {
+	.addr_type = MSM_CAMERA_I2C_BYTE_ADDR,
+};
+
+static struct msm_camera_i2c_reg_setting lm3642_init_setting = {
+	.reg_setting = lm3642_init_array,
+	.size = ARRAY_SIZE(lm3642_init_array),
+	.addr_type = MSM_CAMERA_I2C_BYTE_ADDR,
+	.data_type = MSM_CAMERA_I2C_BYTE_DATA,
+	.delay = 0,
+};
+
+static struct msm_camera_i2c_reg_setting lm3642_off_setting = {
+	.reg_setting = lm3642_off_array,
+	.size = ARRAY_SIZE(lm3642_off_array),
+	.addr_type = MSM_CAMERA_I2C_BYTE_ADDR,
+	.data_type = MSM_CAMERA_I2C_BYTE_DATA,
+	.delay = 0,
+};
+
+static struct msm_camera_i2c_reg_setting lm3642_release_setting = {
+	.reg_setting = lm3642_release_array,
+	.size = ARRAY_SIZE(lm3642_release_array),
+	.addr_type = MSM_CAMERA_I2C_BYTE_ADDR,
+	.data_type = MSM_CAMERA_I2C_BYTE_DATA,
+	.delay = 0,
+};
+
+static struct msm_camera_i2c_reg_setting lm3642_low_setting = {
+	.reg_setting = lm3642_low_array,
+	.size = ARRAY_SIZE(lm3642_low_array),
+	.addr_type = MSM_CAMERA_I2C_BYTE_ADDR,
+	.data_type = MSM_CAMERA_I2C_BYTE_DATA,
+	.delay = 0,
+};
+
+static struct msm_camera_i2c_reg_setting lm3642_high_setting = {
+	.reg_setting = lm3642_high_array,
+	.size = ARRAY_SIZE(lm3642_high_array),
+	.addr_type = MSM_CAMERA_I2C_BYTE_ADDR,
+	.data_type = MSM_CAMERA_I2C_BYTE_DATA,
+	.delay = 0,
+};
+
+static struct msm_led_flash_reg_t lm3642_regs = {
+	.init_setting = &lm3642_init_setting,
+	.off_setting = &lm3642_off_setting,
+	.low_setting = &lm3642_low_setting,
+	.high_setting = &lm3642_high_setting,
+	.release_setting = &lm3642_release_setting,
+};
+
+static struct msm_flash_fn_t lm3642_func_tbl = {
+	.flash_get_subdev_id = msm_led_i2c_trigger_get_subdev_id,
+	.flash_led_config = msm_led_i2c_trigger_config,
+	.flash_led_init = msm_flash_led_init,
+	.flash_led_release = msm_flash_led_release,
+	.flash_led_off = msm_flash_led_off,
+	.flash_led_low = msm_flash_led_low,
+	.flash_led_high = msm_flash_led_high,
+};
+
+static struct msm_led_flash_ctrl_t fctrl = {
+	.flash_i2c_client = &lm3642_i2c_client,
+	.reg_setting = &lm3642_regs,
+	.func_tbl = &lm3642_func_tbl,
+};
+
+/*subsys_initcall(msm_flash_i2c_add_driver);*/
+module_init(msm_flash_lm3642_i2c_add_driver);
+module_exit(msm_flash_lm3642_i2c_remove);
+MODULE_DESCRIPTION("lm3642 FLASH");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/msm/camera_v2/sensor/flash/msm_led_flash.h b/drivers/media/platform/msm/camera_v2/sensor/flash/msm_led_flash.h
index 9f3a81c..9328b7c 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/flash/msm_led_flash.h
+++ b/drivers/media/platform/msm/camera_v2/sensor/flash/msm_led_flash.h
@@ -60,6 +60,8 @@ struct msm_led_flash_ctrl_t {
 	uint32_t num_sources;
 	enum msm_camera_device_type_t flash_device_type;
 	uint32_t subdev_id;
+	uint16_t flash_en;
+	uint16_t flash_now;
 };
 
 int msm_flash_i2c_probe(struct i2c_client *client,
diff --git a/drivers/media/platform/msm/camera_v2/sensor/flash/msm_led_i2c_trigger.c b/drivers/media/platform/msm/camera_v2/sensor/flash/msm_led_i2c_trigger.c
index b5afa86..dd31704 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/flash/msm_led_i2c_trigger.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/flash/msm_led_i2c_trigger.c
@@ -22,25 +22,27 @@
 
 #define FLASH_NAME "camera-led-flash"
 
-/*#define CONFIG_MSMB_CAMERA_DEBUG*/
-#undef CDBG
+//#define CONFIG_MSMB_CAMERA_DEBUG
 #ifdef CONFIG_MSMB_CAMERA_DEBUG
-#define CDBG(fmt, args...) pr_err(fmt, ##args)
+#define LM3642_DBG(x...) printk(KERN_ERR "[LM3642]" x)
 #else
-#define CDBG(fmt, args...) do { } while (0)
+#define LM3642_DBG(x...)
 #endif
 
 int32_t msm_led_i2c_trigger_get_subdev_id(struct msm_led_flash_ctrl_t *fctrl,
 	void *arg)
 {
 	uint32_t *subdev_id = (uint32_t *)arg;
+	
+	LM3642_DBG("%s entry\n", __func__);
+	
 	if (!subdev_id) {
 		pr_err("failed\n");
 		return -EINVAL;
 	}
 	*subdev_id = fctrl->subdev_id;
 
-	CDBG("subdev_id %d\n", *subdev_id);
+	LM3642_DBG("subdev_id %d\n", *subdev_id);
 	return 0;
 }
 
@@ -49,7 +51,8 @@ int32_t msm_led_i2c_trigger_config(struct msm_led_flash_ctrl_t *fctrl,
 {
 	int rc = 0;
 	struct msm_camera_led_cfg_t *cfg = (struct msm_camera_led_cfg_t *)data;
-	CDBG("called led_state %d\n", cfg->cfgtype);
+
+	LM3642_DBG("%s entry,cfg->cfgtype=%d\n", __func__,cfg->cfgtype);
 
 	if (!fctrl->func_tbl) {
 		pr_err("failed\n");
@@ -86,37 +89,16 @@ int32_t msm_led_i2c_trigger_config(struct msm_led_flash_ctrl_t *fctrl,
 		rc = -EFAULT;
 		break;
 	}
-	CDBG("flash_set_led_state: return %d\n", rc);
+	LM3642_DBG("%s leave, rc=%d\n", __func__,rc);
 	return rc;
 }
 
 int msm_flash_led_init(struct msm_led_flash_ctrl_t *fctrl)
 {
 	int rc = 0;
-	struct msm_camera_sensor_board_info *flashdata = NULL;
-	CDBG("%s:%d called\n", __func__, __LINE__);
-
-	flashdata = fctrl->flashdata;
-	if (flashdata->gpio_conf->cam_gpiomux_conf_tbl != NULL) {
-		pr_err("%s:%d mux install\n", __func__, __LINE__);
-		msm_gpiomux_install(
-			(struct msm_gpiomux_config *)
-			flashdata->gpio_conf->cam_gpiomux_conf_tbl,
-			flashdata->gpio_conf->cam_gpiomux_conf_tbl_size);
-	}
-
-	rc = msm_camera_request_gpio_table(
-		flashdata->gpio_conf->cam_gpio_req_tbl,
-		flashdata->gpio_conf->cam_gpio_req_tbl_size, 1);
-	if (rc < 0) {
-		pr_err("%s: request gpio failed\n", __func__);
-		return rc;
-	}
-	msleep(20);
-	gpio_set_value_cansleep(
-		flashdata->gpio_conf->gpio_num_info->gpio_num[0],
-		GPIO_OUT_HIGH);
+	LM3642_DBG("%s entry\n", __func__);
 
+	#if 0
 	if (fctrl->flash_i2c_client && fctrl->reg_setting) {
 		rc = fctrl->flash_i2c_client->i2c_func_tbl->i2c_write_table(
 			fctrl->flash_i2c_client,
@@ -125,47 +107,30 @@ int msm_flash_led_init(struct msm_led_flash_ctrl_t *fctrl)
 			pr_err("%s:%d failed\n", __func__, __LINE__);
 	}
 
+	gpio_direction_output(fctrl->flash_en, 0);
+	#endif
 	return rc;
 }
 
 int msm_flash_led_release(struct msm_led_flash_ctrl_t *fctrl)
 {
-	int rc = 0;
-	struct msm_camera_sensor_board_info *flashdata = NULL;
+	LM3642_DBG("%s entry\n", __func__);
+	gpio_direction_output(fctrl->flash_en, 0);
 
-	flashdata = fctrl->flashdata;
-	CDBG("%s:%d called\n", __func__, __LINE__);
-	if (!fctrl) {
-		pr_err("%s:%d fctrl NULL\n", __func__, __LINE__);
-		return -EINVAL;
-	}
-	gpio_set_value_cansleep(
-		flashdata->gpio_conf->gpio_num_info->gpio_num[0],
-		GPIO_OUT_LOW);
-	gpio_set_value_cansleep(
-		flashdata->gpio_conf->gpio_num_info->gpio_num[1],
-		GPIO_OUT_LOW);
-	rc = msm_camera_request_gpio_table(
-		flashdata->gpio_conf->cam_gpio_req_tbl,
-		flashdata->gpio_conf->cam_gpio_req_tbl_size, 0);
-	if (rc < 0) {
-		pr_err("%s: request gpio failed\n", __func__);
-		return rc;
-	}
 	return 0;
 }
 
 int msm_flash_led_off(struct msm_led_flash_ctrl_t *fctrl)
 {
 	int rc = 0;
-	struct msm_camera_sensor_board_info *flashdata = NULL;
 
-	flashdata = fctrl->flashdata;
-	CDBG("%s:%d called\n", __func__, __LINE__);
+	LM3642_DBG("%s entry\n", __func__);
+	
 	if (!fctrl) {
 		pr_err("%s:%d fctrl NULL\n", __func__, __LINE__);
 		return -EINVAL;
 	}
+	LM3642_DBG("sensor_slave_addr=%x\n", fctrl->flash_i2c_client->client->addr);
 	if (fctrl->flash_i2c_client && fctrl->reg_setting) {
 		rc = fctrl->flash_i2c_client->i2c_func_tbl->i2c_write_table(
 			fctrl->flash_i2c_client,
@@ -173,9 +138,8 @@ int msm_flash_led_off(struct msm_led_flash_ctrl_t *fctrl)
 		if (rc < 0)
 			pr_err("%s:%d failed\n", __func__, __LINE__);
 	}
-	gpio_set_value_cansleep(
-		flashdata->gpio_conf->gpio_num_info->gpio_num[1],
-		GPIO_OUT_LOW);
+	LM3642_DBG("fctrl->flash_en=%d\n", fctrl->flash_en);
+	gpio_direction_output(fctrl->flash_en, 0);
 
 	return rc;
 }
@@ -183,19 +147,12 @@ int msm_flash_led_off(struct msm_led_flash_ctrl_t *fctrl)
 int msm_flash_led_low(struct msm_led_flash_ctrl_t *fctrl)
 {
 	int rc = 0;
-	struct msm_camera_sensor_board_info *flashdata = NULL;
-	CDBG("%s:%d called\n", __func__, __LINE__);
-
-	flashdata = fctrl->flashdata;
-	gpio_set_value_cansleep(
-		flashdata->gpio_conf->gpio_num_info->gpio_num[0],
-		GPIO_OUT_HIGH);
-
-	gpio_set_value_cansleep(
-		flashdata->gpio_conf->gpio_num_info->gpio_num[1],
-		GPIO_OUT_HIGH);
-
+	
+	LM3642_DBG("%s entry,fctrl->flash_en=%d\n", __func__,fctrl->flash_en);
+	
+	gpio_direction_output(fctrl->flash_en, 1);
 
+	LM3642_DBG("sensor_slave_addr=%x\n", fctrl->flash_i2c_client->client->addr);
 	if (fctrl->flash_i2c_client && fctrl->reg_setting) {
 		rc = fctrl->flash_i2c_client->i2c_func_tbl->i2c_write_table(
 			fctrl->flash_i2c_client,
@@ -210,18 +167,12 @@ int msm_flash_led_low(struct msm_led_flash_ctrl_t *fctrl)
 int msm_flash_led_high(struct msm_led_flash_ctrl_t *fctrl)
 {
 	int rc = 0;
-	struct msm_camera_sensor_board_info *flashdata = NULL;
-	CDBG("%s:%d called\n", __func__, __LINE__);
+	
+	LM3642_DBG("%s entry,fctrl->flash_en=%d\n", __func__,fctrl->flash_en);
 
-	flashdata = fctrl->flashdata;
-	gpio_set_value_cansleep(
-		flashdata->gpio_conf->gpio_num_info->gpio_num[0],
-		GPIO_OUT_HIGH);
-
-	gpio_set_value_cansleep(
-		flashdata->gpio_conf->gpio_num_info->gpio_num[1],
-		GPIO_OUT_HIGH);
+	gpio_direction_output(fctrl->flash_en, 1);
 
+	LM3642_DBG("sensor_slave_addr=%x\n", fctrl->flash_i2c_client->client->addr);
 	if (fctrl->flash_i2c_client && fctrl->reg_setting) {
 		rc = fctrl->flash_i2c_client->i2c_func_tbl->i2c_write_table(
 			fctrl->flash_i2c_client,
@@ -233,6 +184,7 @@ int msm_flash_led_high(struct msm_led_flash_ctrl_t *fctrl)
 	return rc;
 }
 
+#if 0
 static int32_t msm_flash_init_gpio_pin_tbl(struct device_node *of_node,
 	struct msm_camera_gpio_conf *gconf, uint16_t *gpio_array,
 	uint16_t gpio_array_size)
@@ -240,6 +192,8 @@ static int32_t msm_flash_init_gpio_pin_tbl(struct device_node *of_node,
 	int32_t rc = 0;
 	int32_t val = 0;
 
+	LM3642_DBG("%s entry\n", __func__);
+
 	gconf->gpio_num_info = kzalloc(sizeof(struct msm_camera_gpio_num_info),
 		GFP_KERNEL);
 	if (!gconf->gpio_num_info) {
@@ -261,7 +215,7 @@ static int32_t msm_flash_init_gpio_pin_tbl(struct device_node *of_node,
 	/*index 0 is for qcom,gpio-flash-en */
 	gconf->gpio_num_info->gpio_num[0] =
 		gpio_array[val];
-	CDBG("%s qcom,gpio-flash-en %d\n", __func__,
+	LM3642_DBG("%s qcom,gpio-flash-en %d\n", __func__,
 		gconf->gpio_num_info->gpio_num[0]);
 
 	rc = of_property_read_u32(of_node, "qcom,gpio-flash-now", &val);
@@ -277,7 +231,7 @@ static int32_t msm_flash_init_gpio_pin_tbl(struct device_node *of_node,
 	/*index 1 is for qcom,gpio-flash-now */
 	gconf->gpio_num_info->gpio_num[1] =
 		gpio_array[val];
-	CDBG("%s qcom,gpio-flash-now %d\n", __func__,
+	LM3642_DBG("%s qcom,gpio-flash-now %d\n", __func__,
 		gconf->gpio_num_info->gpio_num[1]);
 
 	return rc;
@@ -288,6 +242,8 @@ ERROR:
 	return rc;
 }
 
+#endif
+
 static int32_t msm_led_get_dt_data(struct device_node *of_node,
 		struct msm_led_flash_ctrl_t *fctrl)
 {
@@ -300,7 +256,7 @@ static int32_t msm_led_get_dt_data(struct device_node *of_node,
 	uint16_t gpio_array_size = 0;
 	uint32_t id_info[3];
 
-	CDBG("called\n");
+	LM3642_DBG("%s entry\n", __func__);
 
 	if (!of_node) {
 		pr_err("of_node NULL\n");
@@ -330,12 +286,11 @@ static int32_t msm_led_get_dt_data(struct device_node *of_node,
 		return -EINVAL;
 	}
 
-	CDBG("subdev id %d\n", fctrl->subdev_id);
+	LM3642_DBG("subdev id %d\n", fctrl->subdev_id);
 
 	rc = of_property_read_string(of_node, "qcom,flash-name",
 		&flashdata->sensor_name);
-	CDBG("%s qcom,flash-name %s, rc %d\n", __func__,
-		flashdata->sensor_name, rc);
+	LM3642_DBG("%s qcom,flash-name %s, rc %d\n", __func__,flashdata->sensor_name, rc);
 	if (rc < 0) {
 		pr_err("%s failed %d\n", __func__, __LINE__);
 		goto ERROR1;
@@ -343,7 +298,7 @@ static int32_t msm_led_get_dt_data(struct device_node *of_node,
 
 	if (of_get_property(of_node, "qcom,flash-source", &count)) {
 		count /= sizeof(uint32_t);
-		CDBG("count %d\n", count);
+		LM3642_DBG("count %d\n", count);
 		if (count > MAX_LED_TRIGGERS) {
 			pr_err("failed\n");
 			return -EINVAL;
@@ -365,7 +320,7 @@ static int32_t msm_led_get_dt_data(struct device_node *of_node,
 				continue;
 			}
 
-			CDBG("default trigger %s\n",
+			LM3642_DBG("default trigger %s\n",
 				 fctrl->flash_trigger_name[i]);
 
 			rc = of_property_read_u32(flash_src_node,
@@ -379,7 +334,7 @@ static int32_t msm_led_get_dt_data(struct device_node *of_node,
 
 			of_node_put(flash_src_node);
 
-			CDBG("max_current[%d] %d\n",
+			LM3642_DBG("max_current[%d] %d\n",
 				i, fctrl->flash_op_current[i]);
 
 			led_trigger_register_simple(
@@ -399,7 +354,7 @@ static int32_t msm_led_get_dt_data(struct device_node *of_node,
 		gconf = flashdata->gpio_conf;
 
 		gpio_array_size = of_gpio_count(of_node);
-		CDBG("%s gpio count %d\n", __func__, gpio_array_size);
+		LM3642_DBG("%s gpio count %d\n", __func__, gpio_array_size);
 
 		if (gpio_array_size) {
 			gpio_array = kzalloc(sizeof(uint16_t) * gpio_array_size,
@@ -407,23 +362,36 @@ static int32_t msm_led_get_dt_data(struct device_node *of_node,
 			if (!gpio_array) {
 				pr_err("%s failed %d\n", __func__, __LINE__);
 				rc = -ENOMEM;
-				goto ERROR4;
+				goto ERROR1;
 			}
 			for (i = 0; i < gpio_array_size; i++) {
 				gpio_array[i] = of_get_gpio(of_node, i);
-				CDBG("%s gpio_array[%d] = %d\n", __func__, i,
+				LM3642_DBG("%s gpio_array[%d] = %d\n", __func__, i,
 					gpio_array[i]);
 			}
 
+			fctrl->flash_en = gpio_array[0];
+			gpio_tlmm_config(GPIO_CFG(fctrl->flash_en, 0,
+				  GPIO_CFG_OUTPUT, GPIO_CFG_NO_PULL,
+				  GPIO_CFG_2MA), GPIO_CFG_ENABLE);
+			gpio_direction_output(fctrl->flash_en, 0);
+
+			#if 0
 			rc = msm_sensor_get_dt_gpio_req_tbl(of_node, gconf,
 				gpio_array, gpio_array_size);
+
+			LM3642_DBG("msm_sensor_get_dt_gpio_req_tbl rc =%d\n",rc);
+						
 			if (rc < 0) {
 				pr_err("%s failed %d\n", __func__, __LINE__);
 				goto ERROR4;
 			}
-
+			
 			rc = msm_sensor_get_dt_gpio_set_tbl(of_node, gconf,
 				gpio_array, gpio_array_size);
+			
+			LM3642_DBG("msm_sensor_get_dt_gpio_set_tbl rc=%d\n",rc);
+			
 			if (rc < 0) {
 				pr_err("%s failed %d\n", __func__, __LINE__);
 				goto ERROR5;
@@ -431,21 +399,27 @@ static int32_t msm_led_get_dt_data(struct device_node *of_node,
 
 			rc = msm_flash_init_gpio_pin_tbl(of_node, gconf,
 				gpio_array, gpio_array_size);
+			
+			LM3642_DBG("msm_flash_init_gpio_pin_tbl rc=%d\n",rc);
+			
 			if (rc < 0) {
 				pr_err("%s failed %d\n", __func__, __LINE__);
 				goto ERROR6;
 			}
+			#endif
 		}
 
 		flashdata->slave_info =
 			kzalloc(sizeof(struct msm_camera_slave_info),
 				GFP_KERNEL);
 		if (!flashdata->slave_info) {
-			pr_err("%s failed %d\n", __func__, __LINE__);
+			LM3642_DBG("%s failed %d\n", __func__, __LINE__);
 			rc = -ENOMEM;
 			goto ERROR8;
 		}
 
+		LM3642_DBG("%s slave_info get\n", __func__);
+		
 		rc = of_property_read_u32_array(of_node, "qcom,slave-id",
 			id_info, 3);
 		if (rc < 0) {
@@ -456,18 +430,14 @@ static int32_t msm_led_get_dt_data(struct device_node *of_node,
 		fctrl->flashdata->slave_info->sensor_id_reg_addr = id_info[1];
 		fctrl->flashdata->slave_info->sensor_id = id_info[2];
 
+		LM3642_DBG("sensor_slave_addr=%x,sensor_id_reg_addr=%x,sensor_id=%x\n", id_info[0],id_info[1],id_info[2]);
+
 		kfree(gpio_array);
 		return rc;
 ERROR9:
 		kfree(fctrl->flashdata->slave_info);
 ERROR8:
 		kfree(fctrl->flashdata->gpio_conf->gpio_num_info);
-ERROR6:
-		kfree(gconf->cam_gpio_set_tbl);
-ERROR5:
-		kfree(gconf->cam_gpio_req_tbl);
-ERROR4:
-		kfree(gconf);
 ERROR1:
 		kfree(fctrl->flashdata);
 		kfree(gpio_array);
@@ -491,8 +461,16 @@ int msm_flash_i2c_probe(struct i2c_client *client,
 	int rc = 0;
 	struct msm_led_flash_ctrl_t *fctrl = NULL;
 
+	LM3642_DBG("%s entry\n", __func__);
+	
 	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
-		pr_err("i2c_check_functionality failed\n");
+		pr_err("i2c_check_functionality failed I2C_FUNC_I2C\n");
+		goto probe_failure;
+	}
+
+    if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_I2C_BLOCK))
+	{
+	    pr_err("i2c_check_functionality failed I2C_FUNC_SMBUS_I2C_BLOCK\n");
 		goto probe_failure;
 	}
 
@@ -511,6 +489,7 @@ int msm_flash_i2c_probe(struct i2c_client *client,
 		pr_err("%s failed line %d\n", __func__, __LINE__);
 		return rc;
 	}
+	
 	if (fctrl->flash_i2c_client != NULL) {
 		fctrl->flash_i2c_client->client = client;
 		if (fctrl->flashdata->slave_info->sensor_slave_addr)
@@ -524,15 +503,17 @@ int msm_flash_i2c_probe(struct i2c_client *client,
 		return rc;
 	}
 
+	fctrl->flash_i2c_client->client->addr = fctrl->flash_i2c_client->client->addr<<1;
+
 	if (!fctrl->flash_i2c_client->i2c_func_tbl)
 		fctrl->flash_i2c_client->i2c_func_tbl =
 			&msm_sensor_qup_func_tbl;
 
 	rc = msm_led_i2c_flash_create_v4lsubdev(fctrl);
-	CDBG("%s:%d probe success\n", __func__, __LINE__);
+	LM3642_DBG("sensor_slave_addr=%x\n", fctrl->flash_i2c_client->client->addr);
 	return 0;
 
 probe_failure:
-	CDBG("%s:%d probe failed\n", __func__, __LINE__);
+	LM3642_DBG("%s:%d probe failed\n", __func__, __LINE__);
 	return rc;
 }
-- 
1.7.9.5

