/* Ubicom32 opcode support.  -*- C -*-
   Copyright (C) 2000, 2001, 2002 Red Hat, Inc.
   This file is part of CGEN.  */

/* This file is an addendum to ubicom32.cpu.  Heavy use of C code isn't
   appropriate in .cpu files, so it resides here.  This especially applies
   to assembly/disassembly where parsing/printing can be quite involved.
   Such things aren't really part of the specification of the cpu, per se,
   so .cpu files provide the general framework and .opc files handle the
   nitty-gritty details as necessary.

   Each section is delimited with start and end markers.

   <arch>-opc.h additions use: "-- opc.h"
   <arch>-opc.c additions use: "-- opc.c"
   <arch>-asm.c additions use: "-- asm.c"
   <arch>-dis.c additions use: "-- dis.c"
   <arch>-ibd.h additions use: "-- ibd.h"
*/

/* -- opc.h */

/* Check applicability of instructions against machines.  */
#define CGEN_VALIDATE_INSN_SUPPORTED
extern int ubicom32_cgen_insn_supported
  PARAMS ((CGEN_CPU_DESC, const CGEN_INSN *));

/* Allows reason codes to be output when assembler errors occur.  */
#define CGEN_VERBOSE_ASSEMBLER_ERRORS

/* Override disassembly hashing */

#define CGEN_DIS_HASH_SIZE 32
#define CGEN_DIS_HASH(buf,value) ubicom32_dis_hash(buf,value)

#define CGEN_ASM_HASH_SIZE 509
#define CGEN_ASM_HASH(insn) ubicom32_asm_hash(insn)

extern unsigned int ubicom32_dis_hash (const char *buf, CGEN_INSN_INT value);
extern unsigned int ubicom32_asm_hash (const char *insn);

/* Structure used to map between directly addressable registers and
   their human-readable names.  Used by both the assembler and the
   disassembler.
*/
struct ubicom32_cgen_data_space_map {
	long address;
	char *name;
        int  type;
};

extern struct ubicom32_cgen_data_space_map ubicom32_cgen_data_space_map_mars[];
extern struct ubicom32_cgen_data_space_map ubicom32_cgen_data_space_map_mercury[];
extern struct ubicom32_cgen_data_space_map ubicom32_cgen_data_space_map_jupiter[];

#define A0_ADDRESS 0x80
#define A1_ADDRESS (A0_ADDRESS + 4)
#define A2_ADDRESS (A0_ADDRESS + 8)
#define A3_ADDRESS (A0_ADDRESS + 12)
#define A4_ADDRESS (A0_ADDRESS + 16)
#define A5_ADDRESS (A0_ADDRESS + 20)
#define A6_ADDRESS (A0_ADDRESS + 24)
#define A7_ADDRESS (A0_ADDRESS + 28)

/* XXX */
typedef unsigned char UQI;


/* -- opc.c */
#include "safe-ctype.h"

unsigned int
ubicom32_dis_hash (const char *buf, CGEN_INSN_INT value ATTRIBUTE_UNUSED)
{
  unsigned int hash = (*buf >> 3);
  hash &= 0x1f;
  hash = (hash == 0x1d) ? 0x1c : hash;
  return hash % CGEN_DIS_HASH_SIZE;
}


/* A better hash function for instruction mnemonics. */
unsigned int
ubicom32_asm_hash (const char* insn)
{
  unsigned int hash;
  const char* m = insn;

  /* for certain instructions, the variations are coded as operands
     and so only the mnemonic will have been used to seed the hash table.
     Examples of this are the jmp family and the int instruction.
     If we suspect we may have these instructions, just use the first 3 chars.
   */
  if (*m == 'j' || *m == 'i' || *m=='m')
    {
      int i = 0;
      for (hash = 0; *m && !ISSPACE(*m) && i < 3; m++, ++i)
        hash = (hash * 23) ^ (0x1F & TOLOWER(*m));
    }
  else
    {
      for (hash = 0; *m && !ISSPACE(*m); m++)
        hash = (hash * 23) ^ (0x1F & TOLOWER(*m));
    }

  /* printf ("%s %d\n", insn, (hash % CGEN_ASM_HASH_SIZE)); */

  return hash % CGEN_ASM_HASH_SIZE;
}

/* Special check to ensure that instruction exists for given machine. */
int
ubicom32_cgen_insn_supported (CGEN_CPU_DESC cd,
			  const CGEN_INSN *insn)
{
  int machs = CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_MACH);

  /* No mach attribute?  Assume it's supported for all machs.  */
  if (machs == 0)
    return 1;
  
  return ((machs & cd->machs) != 0);
}

/* -- asm.c */

/* Directly addressable registers on the UBICOM32.
 */

#define RW  0  /* read/write */
#define RO  1  /* read-only  */
#define WO  2  /* write-only */

struct ubicom32_cgen_data_space_map ubicom32_cgen_data_space_map_mercury[] = {
	{ 0x0,		"d0", RW, },	/* data registers */
	/* d1, d2 and d3 are later */
	{ 0x10,		"d4", RW, },
	{ 0x14,		"d5", RW, },
	{ 0x18,		"d6", RW, },
	{ 0x1c,		"d7", RW, },
	{ 0x20,		"d8", RW, },
	{ 0x24,		"d9", RW, },
	{ 0x28,		"d10", RW, },
	{ 0x2c,		"d11", RW, },
	{ 0x30,		"d12", RW, },
	{ 0x34,		"d13", RW, },
	{ 0x38,		"d14", RW, },
	{ 0x3c,		"d15", RW, },
	{ 0x4,		"d1", RW, },	/* put them here where they work */
	{ 0x8,		"d2", RW, },
	{ 0xc,		"d3", RW, },
	{ A0_ADDRESS,	"a0", RW, },	/* address registers */
	{ A1_ADDRESS,	"a1", RW, },
	{ A2_ADDRESS,   "a2", RW, },
	{ A3_ADDRESS,	"a3", RW, },
	{ A4_ADDRESS,	"a4", RW, },
	{ A5_ADDRESS,	"a5", RW, },
	{ A6_ADDRESS,	"a6", RW, },
	{ A7_ADDRESS,	"sp", RW, },	/* sp is a7; first so we use it */
	{ A7_ADDRESS,	"a7", RW, },
	{ 0xa0,		"mac_hi", RW, },
	{ 0xa4,		"mac_lo", RW, },
	{ 0xa8,         "mac_rc16", RW, },
	{ 0xac,         "source3", RW, },
	{ 0xac,         "source_3", RW, },
	{ 0xb0,         "context_cnt", RO,},
	{ 0xb0,         "inst_cnt", RO,},
	{ 0xb4,		"csr", RW, },
	{ 0xb8,         "rosr", RO, },
	{ 0xbc,		"iread_data", RW, },
	{ 0xc0,		"int_mask0", RW, },
	{ 0xc4,		"int_mask1", RW, },
	/* 0xc8 - 0xcf reserved for future interrupt masks */
	{ 0xd0,         "pc", RW, },
	/* 0xd4 - ff reserved */
	{ 0x100,        "chip_id", RO, },
	{ 0x104,	"int_stat0", RO, },
	{ 0x108,	"int_stat1", RO, },
	/* 0x10c - 0x113 reserved for future interrupt masks */
	{ 0x114,        "int_set0", WO, },
	{ 0x118,        "int_set1", WO, },
        /* 0x11c - 0x123 reserved for future interrupt set */
	{ 0x124,        "int_clr0", WO, },
        { 0x128,        "int_clr1", WO, },
        /* 0x13c - 0x133 reserved for future interrupt clear */
	{ 0x134,	"global_ctrl", RW, },
	{ 0x13c,        "mt_active_set", WO, },
	{ 0x140,        "mt_active_clr", WO, },
	{ 0x138,        "mt_active", RO, },
	{ 0x148,        "mt_dbg_active_set", WO, },
	{ 0x144,        "mt_dbg_active", RO, },
	{ 0x14C,        "mt_en", RW, },
	{ 0x150,        "mt_hpri", RW, }, 
	{ 0x150,        "mt_pri", RW, }, 
	{ 0x154,        "mt_hrt", RW, },
	{ 0x154,        "mt_sched", RW, },
	{ 0x15C,        "mt_break_clr", WO, },
	{ 0x158,        "mt_break", RO, },
	{ 0x160,        "mt_single_step", RW, },
	{ 0x164,        "mt_min_delay_en", RW, },
	{ 0x164,        "mt_min_del_en", RW, },

	{ 0x16c,        "perr_addr", RO, },
	{ 0x178,        "dcapt_tnum", RO, },
	{ 0x174,        "dcapt_pc", RO, },
	{ 0x170,        "dcapt", RW, },
	/* 0x17c - 0x1ff reserved */
	{ 0x17c,        "mt_dbg_active_clr", WO, },
	{ 0x180,        "scratchpad0", RW, },
	{ 0x184,        "scratchpad1", RW, },
	{ 0x188,        "scratchpad2", RW, },
	{ 0x18c,        "scratchpad3", RW, },

	{ 0x0,		0, RW, },
};

struct ubicom32_cgen_data_space_map ubicom32_cgen_data_space_map_mars[] = {
	{ 0x0,		"d0", RW, },	/* data registers */
	/* d1, d2 and d3 are later */
	{ 0x10,		"d4", RW, },
	{ 0x14,		"d5", RW, },
	{ 0x18,		"d6", RW, },
	{ 0x1c,		"d7", RW, },
	{ 0x20,		"d8", RW, },
	{ 0x24,		"d9", RW, },
	{ 0x28,		"d10", RW, },
	{ 0x2c,		"d11", RW, },
	{ 0x30,		"d12", RW, },
	{ 0x34,		"d13", RW, },
	{ 0x38,		"d14", RW, },
	{ 0x3c,		"d15", RW, },
	{ 0x4,		"d1", RW, },	/* put them here where they work */
	{ 0x8,		"d2", RW, },
	{ 0xc,		"d3", RW, },
	{ A0_ADDRESS,	"a0", RW, },	/* address registers */
	{ A1_ADDRESS,	"a1", RW, },
	{ A2_ADDRESS,   "a2", RW, },
	{ A3_ADDRESS,	"a3", RW, },
	{ A4_ADDRESS,	"a4", RW, },
	{ A5_ADDRESS,	"a5", RW, },
	{ A6_ADDRESS,	"a6", RW, },
	{ A7_ADDRESS,	"sp", RW, },	/* sp is a7; first so we use it */
	{ A7_ADDRESS,	"a7", RW, },
	{ 0xa0,		"mac_hi", RW, },
	{ 0xa0,		"acc0_hi", RW, }, /* mac_hi and mac_lo are also known as acc0_hi and acc0_lo */
	{ 0xa4,		"mac_lo", RW, },
	{ 0xa4,		"acc0_lo", RW, },
	{ 0xa8,         "mac_rc16", RW, },
	{ 0xac,         "source3", RW, },
	{ 0xac,         "source_3", RW, },
	{ 0xb0,         "context_cnt", RO,},
	{ 0xb0,         "inst_cnt", RO,},
	{ 0xb4,		"csr", RW, },
	{ 0xb8,         "rosr", RO, },
	{ 0xbc,		"iread_data", RW, },
	{ 0xc0,		"int_mask0", RW, },
	{ 0xc4,		"int_mask1", RW, },
	/* 0xc8 - 0xcf reserved for future interrupt masks */
	{ 0xd0,         "pc", RW, },
	{ 0xd4,         "trap_cause", RW, },
	{ 0xd8,		"acc1_hi", RW, }, /* Defines for acc1 */
	{ 0xdc,		"acc1_lo", RW, },
	{ 0xe0,		"previous_pc", RO, },
	{ 0xe4,		"ucsr", RW, },

	/* 0xe8 - ff reserved */
	{ 0x100,        "chip_id", RO, },
	{ 0x104,	"int_stat0", RO, },
	{ 0x108,	"int_stat1", RO, },
	/* 0x10c - 0x113 reserved for future interrupt masks */
	{ 0x114,        "int_set0", WO, },
	{ 0x118,        "int_set1", WO, },
        /* 0x11c - 0x123 reserved for future interrupt set */
	{ 0x124,        "int_clr0", WO, },
        { 0x128,        "int_clr1", WO, },
        /* 0x130 - 0x133 reserved for future interrupt clear */
	{ 0x134,	"global_ctrl", RW, },
	{ 0x13c,        "mt_active_set", WO, },
	{ 0x140,        "mt_active_clr", WO, },
	{ 0x138,        "mt_active", RO, },
	{ 0x148,        "mt_dbg_active_set", WO, },
	{ 0x144,        "mt_dbg_active", RO, },
	{ 0x14C,        "mt_en", RW, },
	{ 0x150,        "mt_hpri", RW, }, 
	{ 0x150,        "mt_pri", RW, }, 
	{ 0x154,        "mt_hrt", RW, },
	{ 0x154,        "mt_sched", RW, },
	{ 0x15C,        "mt_break_clr", WO, },
	{ 0x158,        "mt_break", RO, },
	{ 0x160,        "mt_single_step", RW, },
	{ 0x164,        "mt_min_delay_en", RW, },
	{ 0x164,        "mt_min_del_en", RW, },
	{ 0x168,        "mt_break_set", WO, },
	/* 0x16c - 0x16f reserved */
	{ 0x170,        "dcapt", RW, },
	/* 0x174 - 0x17b reserved */
	{ 0x17c,        "mt_dbg_active_clr", WO, },
	{ 0x180,        "scratchpad0", RW, },
	{ 0x184,        "scratchpad1", RW, },
	{ 0x188,        "scratchpad2", RW, },
	{ 0x18c,        "scratchpad3", RW, },
	{ 0x190,        "scratchpad4", RW, },
	{ 0x194,        "scratchpad5", RW, },
	{ 0x198,        "scratchpad6", RW, },

	/* 0x19c - 0x19f Reserved */
	{ 0x1a0,        "chip_cfg", RW, },
	{ 0x1a4,        "mt_i_blocked", RO, },
	{ 0x1a8,	"mt_d_blocked", RO, },
	{ 0x1ac,	"mt_i_blocked_set", WO},
	{ 0x1b0, 	"mt_d_blocked_set", WO},
	{ 0x1b4,	"mt_blocked_clr", WO},
	{ 0x1b8,        "mt_trap_en", RW, },
	{ 0x1bc,        "mt_trap", RO, },
	{ 0x1c0,        "mt_trap_set", WO, },
	{ 0x1c4,        "mt_trap_clr", WO, },
	{ 0x1c8,        "sep", RW, },
	/* 0x1cc-0x1FF Reserved */
 	{ 0x200,	"i_range0_hi", RW},
	{ 0x204,	"i_range1_hi", RW},
	{ 0x208,	"i_range2_hi", RW},
	{ 0x20c,	"i_range3_hi", RW},

	/* 0x210-0x21f Reserved */
 	{ 0x220,	"i_range0_lo", RW},
	{ 0x224,	"i_range1_lo", RW},
	{ 0x228,	"i_range2_lo", RW},
	{ 0x22c,	"i_range3_lo", RW},

	/* 0x230-0x23f Reserved */
 	{ 0x240,	"i_range0_en", RW},
	{ 0x244,	"i_range1_en", RW},
	{ 0x248,	"i_range2_en", RW},
	{ 0x24c,	"i_range3_en", RW},

	/* 0x250-0x25f Reserved */
 	{ 0x260,	"d_range0_hi", RW},
	{ 0x264,	"d_range1_hi", RW},
	{ 0x268,	"d_range2_hi", RW},
	{ 0x26c,	"d_range3_hi", RW},
	{ 0x270,	"d_range4_hi", RW},

	/* 0x274-0x27f Reserved */
 	{ 0x280,	"d_range0_lo", RW},
	{ 0x284,	"d_range1_lo", RW},
	{ 0x288,	"d_range2_lo", RW},
	{ 0x28c,	"d_range3_lo", RW},
	{ 0x290,	"d_range4_lo", RW},

	/* 0x294-0x29f Reserved */
 	{ 0x2a0,	"d_range0_en", RW},
	{ 0x2a4,	"d_range1_en", RW},
	{ 0x2a8,	"d_range2_en", RW},
	{ 0x2ac,	"d_range3_en", RW},
	{ 0x2b0,	"d_range4_en", RW},

	/* 0x2b4-0x3ff Reserved */

	{ 0x0,		0, RW, },
};

struct ubicom32_cgen_data_space_map ubicom32_cgen_data_space_map_jupiter[] = {
	{ 0x0,		"d0", RW, },	/* data registers */
	/* d1, d2 and d3 are later */
	{ 0x10,		"d4", RW, },
	{ 0x14,		"d5", RW, },
	{ 0x18,		"d6", RW, },
	{ 0x1c,		"d7", RW, },
	{ 0x20,		"d8", RW, },
	{ 0x24,		"d9", RW, },
	{ 0x28,		"d10", RW, },
	{ 0x2c,		"d11", RW, },
	{ 0x30,		"d12", RW, },
	{ 0x34,		"d13", RW, },
	{ 0x38,		"d14", RW, },
	{ 0x3c,		"d15", RW, },
	{ 0x4,		"d1", RW, },	/* put them here where they work */
	{ 0x8,		"d2", RW, },
	{ 0xc,		"d3", RW, },
	{ A0_ADDRESS,	"a0", RW, },	/* address registers */
	{ A1_ADDRESS,	"a1", RW, },
	{ A2_ADDRESS,   "a2", RW, },
	{ A3_ADDRESS,	"a3", RW, },
	{ A4_ADDRESS,	"a4", RW, },
	{ A5_ADDRESS,	"a5", RW, },
	{ A6_ADDRESS,	"a6", RW, },
	{ A7_ADDRESS,	"sp", RW, },	/* sp is a7; first so we use it */
	{ A7_ADDRESS,	"a7", RW, },
	{ 0xa0,		"mac_hi", RW, },
	{ 0xa0,		"acc0_hi", RW, }, /* mac_hi and mac_lo are also known as acc0_hi and acc0_lo */
	{ 0xa4,		"mac_lo", RW, },
	{ 0xa4,		"acc0_lo", RW, },
	{ 0xa8,         "mac_rc16", RW, },
	{ 0xac,         "source3", RW, },
	{ 0xac,         "source_3", RW, },
	{ 0xb0,         "context_cnt", RO,},
	{ 0xb0,         "inst_cnt", RO,},
	{ 0xb4,		"csr", RW, },
	{ 0xb8,         "rosr", RO, },
	{ 0xbc,		"iread_data", RW, },
	{ 0xc0,		"int_mask0", RW, },
	{ 0xc4,		"int_mask1", RW, },
	{ 0xc8,		"int_mask2", RW, },
	/* 0xcc - 0xcf reserved for future interrupt masks */
	{ 0xd0,         "pc", RW, },
	{ 0xd4,         "trap_cause", RW, },
	{ 0xd8,		"acc1_hi", RW, }, /* Defines for acc1 */
	{ 0xdc,		"acc1_lo", RW, },
	{ 0xe0,		"previous_pc", RO, },
	{ 0xe4,		"ucsr", RW, },

	/* 0xe8 - ff reserved */
	{ 0x100,        "chip_id", RO, },
	{ 0x104,	"int_stat0", RO, },
	{ 0x108,	"int_stat1", RO, },
	{ 0x10c,	"int_stat2", RO, },
	/* 0x110 - 0x113 reserved for future interrupt masks */
	{ 0x114,        "int_set0", WO, },
	{ 0x118,        "int_set1", WO, },
	{ 0x11c,        "int_set2", WO, },
        /* 0x120 - 0x123 reserved for future interrupt set */
	{ 0x124,        "int_clr0", WO, },
        { 0x128,        "int_clr1", WO, },
        { 0x12c,        "int_clr2", WO, },
        /* 0x130 - 0x133 reserved for future interrupt clear */
	{ 0x134,	"global_ctrl", RW, },
	{ 0x13c,        "mt_active_set", WO, },
	{ 0x140,        "mt_active_clr", WO, },
	{ 0x138,        "mt_active", RO, },
	{ 0x148,        "mt_dbg_active_set", WO, },
	{ 0x144,        "mt_dbg_active", RO, },
	{ 0x14C,        "mt_en", RW, },
	{ 0x150,        "mt_hpri", RW, }, 
	{ 0x150,        "mt_pri", RW, }, 
	{ 0x154,        "mt_hrt", RW, },
	{ 0x154,        "mt_sched", RW, },
	{ 0x15C,        "mt_break_clr", WO, },
	{ 0x158,        "mt_break", RO, },
	{ 0x160,        "mt_single_step", RW, },
	{ 0x164,        "mt_min_delay_en", RW, },
	{ 0x164,        "mt_min_del_en", RW, },
	{ 0x168,        "mt_break_set", WO, },
	{ 0x16c,        "mt_fp_flush", WO, },
	{ 0x170,        "dcapt", RW, },
	{ 0x174,	"mt_fp_blocked", RO, },
	{ 0x178,	"mt_fp_blocked_set", WO},
	{ 0x17c,        "mt_dbg_active_clr", WO, },
	{ 0x180,        "scratchpad0", RW, },
	{ 0x184,        "scratchpad1", RW, },
	{ 0x188,        "scratchpad2", RW, },
	{ 0x18c,        "scratchpad3", RW, },
	{ 0x190,        "scratchpad4", RW, },
	{ 0x194,        "scratchpad5", RW, },
	{ 0x198,        "scratchpad6", RW, },

	/* 0x19c - 0x19f Reserved */
	{ 0x1a0,        "chip_cfg", RW, },
	{ 0x1a4,        "mt_i_blocked", RO, },
	{ 0x1a8,	"mt_d_blocked", RO, },
	{ 0x1ac,	"mt_i_blocked_set", WO},
	{ 0x1b0, 	"mt_d_blocked_set", WO},
	{ 0x1b4,	"mt_blocked_clr", WO},
	{ 0x1b8,        "mt_trap_en", RW, },
	{ 0x1bc,        "mt_trap", RO, },
	{ 0x1c0,        "mt_trap_set", WO, },
	{ 0x1c4,        "mt_trap_clr", WO, },
	{ 0x1c8,        "sep", RW, },
	{ 0x1cc,        "mt_btb_en", RW, },
	{ 0x1d0,        "btb_ctrl", RW, },
	{ 0x1d4,        "tnum", RO, },

	/* 0x1d8-0x1FF Reserved */
 	{ 0x200,	"i_range0_hi", RW},
	{ 0x204,	"i_range1_hi", RW},
	{ 0x208,	"i_range2_hi", RW},
	{ 0x20c,	"i_range3_hi", RW},

	/* 0x210-0x21f Reserved */
 	{ 0x220,	"i_range0_lo", RW},
	{ 0x224,	"i_range1_lo", RW},
	{ 0x228,	"i_range2_lo", RW},
	{ 0x22c,	"i_range3_lo", RW},

	/* 0x230-0x23f Reserved */
 	{ 0x240,	"i_range0_en", RW},
	{ 0x244,	"i_range1_en", RW},
	{ 0x248,	"i_range2_en", RW},
	{ 0x24c,	"i_range3_en", RW},

	/* 0x250-0x25f Reserved */
 	{ 0x260,	"d_range0_hi", RW},
	{ 0x264,	"d_range1_hi", RW},
	{ 0x268,	"d_range2_hi", RW},
	{ 0x26c,	"d_range3_hi", RW},
	{ 0x270,	"d_range4_hi", RW},
	{ 0x274,	"d_range5_hi", RW},

	/* 0x278-0x27f Reserved */
 	{ 0x280,	"d_range0_lo", RW},
	{ 0x284,	"d_range1_lo", RW},
	{ 0x288,	"d_range2_lo", RW},
	{ 0x28c,	"d_range3_lo", RW},
	{ 0x290,	"d_range4_lo", RW},
	{ 0x294,	"d_range5_lo", RW},

	/* 0x298-0x29f Reserved */
 	{ 0x2a0,	"d_range0_en", RW},
	{ 0x2a4,	"d_range1_en", RW},
	{ 0x2a8,	"d_range2_en", RW},
	{ 0x2ac,	"d_range3_en", RW},
	{ 0x2b0,	"d_range4_en", RW},
	{ 0x2b4,	"d_range5_en", RW},

	/* 0x2b8-0x2bf Reserved */
 	{ 0x2c0,	"i_range0_user_en", RW},
	{ 0x2c4,	"i_range1_user_en", RW},
	{ 0x2c8,	"i_range2_user_en", RW},
	{ 0x2cc,	"i_range3_user_en", RW},

	/* 0x2d0 - 0x2df Reserved */
 	{ 0x2e0,	"d_range0_user_en", RW},
	{ 0x2e4,	"d_range1_user_en", RW},
	{ 0x2e8,	"d_range2_user_en", RW},
	{ 0x2ec,	"d_range3_user_en", RW},
	{ 0x2f0,	"d_range4_user_en", RW},
	{ 0x2f4,	"d_range5_user_en", RW},

	/* 0x2f8 - 0x3ff Reserved */
	{ 0x0,		0, RW, },
};

/* t_is_set will be 1 if .t is set for the madd.2 and msub.2 instructions */
static unsigned char t_is_set =0;

static const char *
parse_t_is_set_for_addsub (
			   CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
			   const char **strp,
			   CGEN_KEYWORD *keyword_table,
			   long *valuep)
{
  const char *errmsg;

  t_is_set = 0;

  errmsg = cgen_parse_keyword (cd, strp, keyword_table, valuep);
  if (errmsg)
    {
      t_is_set = 0;

      return errmsg;
    }

  if((int)*valuep)
     t_is_set = 1;

  return NULL;
}

char myerrmsg[128];

/* 
 * If accumulator is selected for madd.2 and msub.2 instructions then
 * the T bit should not be selected. Flag an assembler error in those
 * cases.
 */
static const char *
parse_acc_for_addsub (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
		      const char **strp,
		      CGEN_KEYWORD *keyword_table,
		      long *valuep)
{
  const char *errmsg;

  errmsg = cgen_parse_keyword (cd, strp, keyword_table, valuep);
  if (errmsg)
    {
      t_is_set = 0;

      return errmsg;
    }

  
  if(t_is_set)
    {
      /* This is erroneous. */
      sprintf(myerrmsg, "Extenstion \".t\" is illegal when using acc%d as Source 2 register.", (int)*valuep);
      t_is_set=0;
      return (myerrmsg);
    }

  t_is_set=0;
  return NULL;
}

/*
 * For dsp madd/msub cases if S2 is a data register then t_is_set flag should be set to zero.
 */
static const char *
parse_dr_for_addsub (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
		     const char **strp,
		     CGEN_KEYWORD *keyword_table,
		     long *valuep)
{
  const char *errmsg;

  errmsg = cgen_parse_keyword (cd, strp, keyword_table, valuep);
  if (errmsg)
    {
      t_is_set = 0;

      return errmsg;
    }
  t_is_set=0;
  return NULL;
}

static const char *
parse_bit5 (CGEN_CPU_DESC cd,
	    const char **strp,
	    int opindex,
	    long *valuep)
{
  const char *errmsg;
  char mode = 0;
  long count = 0;
  unsigned long value;

  if (strncmp (*strp, "%bit", 4) == 0)
    {
      *strp += 4;
      mode = 1;
    }
  else if (strncmp (*strp, "%msbbit", 7) == 0)
    {
      *strp += 7;
      mode = 2;
    }
  else if (strncmp (*strp, "%lsbbit", 7) == 0)
    {
      *strp += 7;
      mode = 3;
    }

  errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, valuep);
  if (errmsg) {
    return errmsg;
  }

  if (mode) {
    value = (unsigned long) *valuep;
    if (value == 0) {
      errmsg = _("Attempt to find bit index of 0");
      return errmsg;
    }
    
    if (mode == 1) {
      count = 31;
      while ((value & 0x80000000) == 0) {
        count--;
        value <<= 1;
      }
      if ((value & 0x7FFFFFFF) != 0) {
        errmsg = _("More than one bit set in bitmask");
        return errmsg;
      }
    } else if (mode == 2) {
      count = 31;
      while ((value & 0x80000000) == 0) {
        count--;
        value <<= 1;
      }
    } else if (mode == 3) {
      count = 0;
      while ((value & 0x00000001) == 0) {
        count++;
        value >>= 1;
      }
    }
    
    *valuep = count;
  }

  return errmsg;
}

/*
 * For dsp madd/msub cases if S2 is a #bit5 then t_is_set flag should be set to zero.
 */
static const char *
parse_bit5_for_addsub (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
		       const char **strp,
		       int opindex,
		       long *valuep)
{
  const char *errmsg;

  errmsg = parse_bit5(cd, strp, opindex, valuep);
  if (errmsg)
    {
      t_is_set = 0;

      return errmsg;
    }
  t_is_set=0;
  return NULL;
}

/* Parse signed 4 bit immediate value, being careful (hacky) to avoid
   eating a `++' that might be present */
static const char *
parse_imm4 (CGEN_CPU_DESC cd,
	    const char **strp,
	    int opindex,
	    long *valuep,
	    int size)
{
  const char *errmsg;
  char *plusplus;
  long value;

  plusplus = strstr(*strp, "++");
  if (plusplus)
    *plusplus = 0;
  errmsg = cgen_parse_signed_integer (cd, strp, opindex, &value);
  if (plusplus)
    *plusplus = '+';

  if (errmsg == NULL)
    {
      if ((size == 2 && (value % 2)) ||
          (size == 4 && (value % 4)))
	errmsg = _("unaligned increment");
      else if ((size == 1 && (value < -8 || value > 7)) ||
          (size == 2 && (value < -16 || value > 15)) ||
          (size == 4 && (value < -32 || value > 31)))
	errmsg = _("out of bounds increment");
      else
        *valuep = value;
    }
  return errmsg;
}

/* as above, for single byte addresses */
static const char *
parse_imm4_1 (CGEN_CPU_DESC cd,
	      const char **strp,
	      int opindex,
	      long *valuep)
{
  return parse_imm4 (cd, strp, opindex, valuep, 1);
}

/* as above, for half-word addresses */
static const char *
parse_imm4_2 (CGEN_CPU_DESC cd,
	      const char **strp,
	      int opindex,
	      long *valuep)
{
  return parse_imm4 (cd, strp, opindex, valuep, 2);
}

/* as above, for word addresses */
static const char *
parse_imm4_4 (CGEN_CPU_DESC cd,
	      const char **strp,
	      int opindex,
	      long *valuep)
{
  return parse_imm4 (cd, strp, opindex, valuep, 4);
}

/* Parse a direct address.  This can be either `$xx' or a Register
   Mnemonic.
 */
static const char *
parse_direct_addr (CGEN_CPU_DESC cd,
		   const char **strp,
		   int opindex,
		   long *valuep,
		   int isdest)
{
  const char *errmsg = NULL;
  bfd_vma value;
  struct ubicom32_cgen_data_space_map *cur;
  size_t len;

  if(cd->machs & (1<<MACH_IP3035))
    {
      /* cpu is mercury */
      cur = ubicom32_cgen_data_space_map_mercury;
    }

  if((cd->machs & (1<<MACH_UBICOM32DSP)) || (cd->machs & (1<<MACH_UBICOM32_VER4)))
    {
      /* cpu is mars/ares */
      cur = ubicom32_cgen_data_space_map_mars;
    }

  if(cd->machs & (1<<MACH_UBICOM32_VER5))
    {
      /* cpu is jupiter */
      cur = ubicom32_cgen_data_space_map_jupiter;
    }

  /* First, try to look for the literal register name. */
  for (; cur->name; cur++)
    if (strncasecmp(cur->name, *strp, (len = strlen(cur->name))) == 0 &&
        !ISALNUM((*strp)[len]) && (*strp)[len] != '_' )
      {
	*strp += len;
        /* fail if specifying a read-only register as a destination */
	if (isdest && cur->type == RO)
	  return _("attempt to write to read-only register");
	
	/* fail if specifying a write-only register as a source */
	if ((isdest==0) && cur->type == WO)
	  return _("attempt to read a write-only register");
	value = cur->address;
	errmsg = NULL;
	break;
      }
  
  /* Not found: try parsing it as a literal */
  if (cur->name == NULL)
    {
      char *plusplus;
      if (**strp == '(')
	{
	  return _("parentheses are reserved for indirect addressing");
	}

      if (strncasecmp(*strp, "%f", 2) == 0)
	{
	  *valuep = 0;
	  return NULL;
	}

      /* we want to avoid parsing a negative post-increment expression as a numeric
	 expression because the parser assumes zeroes exist between the pluses and
	 issues an extraneous warning message. */
      plusplus = strstr(*strp, "++");
      if (plusplus)
	*plusplus = 0;
      errmsg = cgen_parse_signed_integer (cd, strp, opindex, &value);
      if (plusplus)
	*plusplus = '+';

      if (errmsg)
	return errmsg;
    }

  value &= 0x3ff;
  *valuep = value;
  return errmsg;
}

static const char *
parse_d_direct_addr (CGEN_CPU_DESC cd,
		     const char **strp,
		     int opindex,
		     long *valuep)
{
  return parse_direct_addr (cd, strp, opindex, valuep, 1);
}

static const char *
parse_s1_direct_addr (CGEN_CPU_DESC cd,
		      const char **strp,
		      int opindex,
		      long *valuep)
{
  return parse_direct_addr (cd, strp, opindex, valuep, 0);
}

/* support for source-1 and destination operand 7-bit immediates for indirect addressing */
static const char *imm7_1_rangemsg = "7-bit byte immediate value out of range";
static const char *imm7_2_rangemsg = "7-bit halfword immediate value out of range";
static const char *imm7_4_rangemsg = "7-bit word immediate value out of range";
static const char *imm7_pdec_rangemsg = "Pdec offset out of range. Allowed range is >=4 and <=512.";
static const char *imm7_2_maskmsg = "7-bit halfword immediate not a multiple of 2";
static const char *imm7_4_maskmsg = "7-bit word immediate not a multiple of 4";

/* Parse 7-bit immediates, allow %lo() operator */
static const char *
parse_imm7_basic (CGEN_CPU_DESC cd,
		  const char **strp,
		  int opindex,
		  unsigned long *valuep,
		  const char *rangemsg,
		  const char *maskmsg,
		  bfd_vma max,
		  int mask,
		  int reloc)
{
  const char *errmsg;
  enum cgen_parse_operand_result result_type = CGEN_PARSE_OPERAND_RESULT_NUMBER;
  bfd_vma value;
  int newreloc;

  /* in this case we want low 7-bits to accompany the 24-bit immediate of a moveai instruction */
  if (strncasecmp (*strp, "%lo(", 4) == 0)
    {
      *strp += 4;
      errmsg = cgen_parse_address (cd, strp, opindex, reloc,
				   &result_type, &value);
      if (**strp != ')')
	return _("missing `)'");
      ++*strp;
      if (errmsg == NULL
  	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	value &= 0x7f;  /* always want 7 bits, regardless of imm7 type */
      *valuep = value;
      return errmsg;
    }
  else if (strncasecmp (*strp, "%got_lo(", strlen("%got_lo(")) == 0)
    {
      *strp += strlen("%got_lo(");

      /* Switch the relocation to the GOT relocation. */
      switch(reloc)
	{
	case BFD_RELOC_UBICOM32_LO7_S:
	  reloc = BFD_RELOC_UBICOM32_GOT_LO7_S;
	  break;
	case BFD_RELOC_UBICOM32_LO7_2_S:
	  reloc = BFD_RELOC_UBICOM32_GOT_LO7_2_S;
	  break;
	case BFD_RELOC_UBICOM32_LO7_4_S:
	  reloc = BFD_RELOC_UBICOM32_GOT_LO7_4_S;
	  break;
	case BFD_RELOC_UBICOM32_LO7_D:
	  reloc = BFD_RELOC_UBICOM32_GOT_LO7_D;
	  break;
	case BFD_RELOC_UBICOM32_LO7_2_D:
	  reloc = BFD_RELOC_UBICOM32_GOT_LO7_2_D;
	  break;
	case BFD_RELOC_UBICOM32_LO7_4_D:
	  reloc = BFD_RELOC_UBICOM32_GOT_LO7_4_D;
	  break;
	}
      errmsg = cgen_parse_address (cd, strp, opindex, reloc,
				   &result_type, &value);
      if (**strp != ')')
	return _("missing `)'");
      ++*strp;
      if (errmsg == NULL
  	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	value &= 0x7f;  /* always want 7 bits, regardless of imm7 type */
      *valuep = value;
      return errmsg;
    }
  else if (strncasecmp (*strp, "%funcdesc_got_lo(", strlen("%funcdesc_got_lo(")) == 0)
    {
      *strp += strlen("%funcdesc_got_lo(");

      /* Switch the relocation to the GOT relocation. */
      switch(reloc)
	{
	case BFD_RELOC_UBICOM32_LO7_S:
	  reloc = BFD_RELOC_UBICOM32_FUNCDESC_GOT_LO7_S;
	  break;
	case BFD_RELOC_UBICOM32_LO7_2_S:
	  reloc = BFD_RELOC_UBICOM32_FUNCDESC_GOT_LO7_2_S;
	  break;
	case BFD_RELOC_UBICOM32_LO7_4_S:
	  reloc = BFD_RELOC_UBICOM32_FUNCDESC_GOT_LO7_4_S;
	  break;
	case BFD_RELOC_UBICOM32_LO7_D:
	  reloc = BFD_RELOC_UBICOM32_FUNCDESC_GOT_LO7_D;
	  break;
	case BFD_RELOC_UBICOM32_LO7_2_D:
	  reloc = BFD_RELOC_UBICOM32_FUNCDESC_GOT_LO7_2_D;
	  break;
	case BFD_RELOC_UBICOM32_LO7_4_D:
	  reloc = BFD_RELOC_UBICOM32_FUNCDESC_GOT_LO7_4_D;
	  break;
	}
      errmsg = cgen_parse_address (cd, strp, opindex, reloc,
				   &result_type, &value);
      if (**strp != ')')
	return _("missing `)'");
      ++*strp;
      if (errmsg == NULL
  	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	value &= 0x7f;  /* always want 7 bits, regardless of imm7 type */
      *valuep = value;
      return errmsg;
    }
  else
    {
      if (**strp == '(')
	{
	  return _("parentheses are reserved for indirect addressing");
	}

      errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, &value);
    }

  if (errmsg == NULL)
    {
      if (value > max)
	return rangemsg;
      if (value & mask)
	return maskmsg;
    }

  *valuep = value & max;
  return errmsg;
}

/* Parse 7-bit immediates, allow %lo() operator */
static const char *
parse_imm7_pdec (CGEN_CPU_DESC cd,
		 const char **strp,
		 int opindex,
		 unsigned long *valuep,
		 const char *rangemsg,
		 const char *maskmsg,
		 int reloc)
{
  const char *errmsg;
  enum cgen_parse_operand_result result_type = CGEN_PARSE_OPERAND_RESULT_NUMBER;
  bfd_vma value;

  /* in this case we want low 7-bits to accompany the 24-bit immediate of a moveai instruction */
  if (strncasecmp (*strp, "%lo(", 4) == 0)
    {
      *strp += 4;
      errmsg = cgen_parse_address (cd, strp, opindex, reloc,
				   &result_type, &value);
      if (**strp != ')')
	return _("missing `)'");
      ++*strp;
      if (errmsg == NULL
  	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	value &= 0x7f;  /* always want 7 bits, regardless of imm7 type */
      *valuep = value;
      return errmsg;
    }
  else
    {
      if (**strp == '(')
	{
	  return _("parentheses are reserved for indirect addressing");
	}

      errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, &value);
    }

  if (errmsg == NULL)
    {
      if (((long)value > 512) || ((long)value < 4))
	return rangemsg;
      if (value & 0x3)
	return maskmsg;
    }

  *valuep = value;
  return errmsg;
}

/* single byte imm7 */
static const char *
parse_imm7_1_s (CGEN_CPU_DESC cd,
		const char **strp,
		int opindex,
		unsigned long *valuep)
{
  return parse_imm7_basic (cd, strp, opindex, valuep, _(imm7_1_rangemsg),
			   NULL, 0x7f, 0, BFD_RELOC_UBICOM32_LO7_S);
}

/* halfword imm7 */
static const char *
parse_imm7_2_s (CGEN_CPU_DESC cd,
		const char **strp,
		int opindex,
		unsigned long *valuep)
{
  return parse_imm7_basic (cd, strp, opindex, valuep, 
			   _(imm7_2_rangemsg),
			   _(imm7_2_maskmsg),
			   0xfe, 0x1, BFD_RELOC_UBICOM32_LO7_2_S);
}

/* word imm7 */
static const char *
parse_imm7_4_s (CGEN_CPU_DESC cd,
		const char **strp,
		int opindex,
		unsigned long *valuep)
{
  return parse_imm7_basic (cd, strp, opindex, valuep, 
			   _(imm7_4_rangemsg),
			   _(imm7_4_maskmsg),
			   0x1fc, 0x3, BFD_RELOC_UBICOM32_LO7_4_S);
}

/* word imm7 */
static const char *
parse_pdec_imm7_4_s (CGEN_CPU_DESC cd,
		     const char **strp,
		     int opindex,
		     unsigned long *valuep)
{
  unsigned long value;
  const char *errmsg = parse_imm7_pdec (cd, strp, opindex, &value, 
					_(imm7_pdec_rangemsg),
					_(imm7_4_maskmsg),
					BFD_RELOC_UBICOM32_LO7_4_S);

  if(errmsg == NULL)
    {
      /* at this point we have a valid value. Take the 2's comp and truncate to 7 bits */
      if(value == 0)
	return _("Offset for PDEC source cannot be 0");

      value = ~value;
      value ++;
      value &= 0x1fc;
      *valuep = value;
    }

  return errmsg;
}

/* single byte dest imm7 */
static const char *
parse_imm7_1_d (CGEN_CPU_DESC cd,
		const char **strp,
		int opindex,
		unsigned long *valuep)
{
  return parse_imm7_basic (cd, strp, opindex, valuep, _(imm7_1_rangemsg),
			   NULL, 0x7f, 0, BFD_RELOC_UBICOM32_LO7_D);
}

/* halfword dest imm7 */
static const char *
parse_imm7_2_d (CGEN_CPU_DESC cd,
		const char **strp,
		int opindex,
		unsigned long *valuep)
{
  return parse_imm7_basic (cd, strp, opindex, valuep, 
			   _(imm7_2_rangemsg),
			   _(imm7_2_maskmsg),
			   0xfe, 0x1, BFD_RELOC_UBICOM32_LO7_2_D);
}

/* word dest imm7 */
static const char *
parse_imm7_4_d (CGEN_CPU_DESC cd,
		const char **strp,
		int opindex,
		unsigned long *valuep)
{
  return parse_imm7_basic (cd, strp, opindex, valuep, 
			   _(imm7_4_rangemsg),
			   _(imm7_4_maskmsg),
			   0x1fc, 0x3, BFD_RELOC_UBICOM32_LO7_4_D);
}

/* Parse 16-bit immediate, allow %hi() or %lo() operators */
static const char *
parse_imm16 (CGEN_CPU_DESC cd,
	     const char **strp,
	     int opindex,
	     unsigned long *valuep)
{
  const char *errmsg;
  enum cgen_parse_operand_result result_type = CGEN_PARSE_OPERAND_RESULT_NUMBER;
  bfd_vma value;

  if (strncasecmp (*strp, "%hi(", 4) == 0)
    {
      *strp += 4;
      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_HI16,
				   &result_type, &value);
      if (**strp != ')')
	return _("missing `)'");
      ++*strp;
      if (errmsg == NULL
  	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	value >>= 16;
      *valuep = value;
      return errmsg;
    }
  else if (strncasecmp (*strp, "%got_hi(", strlen("%got_hi(")) == 0)
    {
      *strp += strlen("%got_hi(");
      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_UBICOM32_GOT_HI,
				   &result_type, &value);
      if (**strp != ')')
	return _("missing `)'");
      ++*strp;
      if (errmsg == NULL
  	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	value >>= 16;
      *valuep = value;
      return errmsg;
    }
  else if ((strncasecmp (*strp, "%funcdesc_got_hi(", strlen("%funcdesc_got_hi(")) == 0)
	   || (strncasecmp (*strp, "%got_funcdesc_hi(", strlen("%got_funcdesc_hi(")) == 0))
    {
      *strp += strlen("%funcdesc_got_hi(");
      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_UBICOM32_FUNCDESC_GOT_HI,
				   &result_type, &value);
      if (**strp != ')')
	return _("missing `)'");
      ++*strp;
      if (errmsg == NULL
  	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	value >>= 16;
      *valuep = value;
      return errmsg;
    }
  else if (strncasecmp (*strp, "%lo(", 4) == 0)
    {
      *strp += 4;
      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_LO16,
				   &result_type, &value);
      if (**strp != ')')
	return _("missing `)'");
      ++*strp;
      if (errmsg == NULL
  	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	value &= 0xffff;
      *valuep = value;
      return errmsg;
    }
  else if (strncasecmp (*strp, "%got_lo(", strlen("%got_lo(")) == 0)
    {
      *strp += strlen("%got_lo(");
      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_UBICOM32_GOT_LO,
				   &result_type, &value);
      if (**strp != ')')
	return _("missing `)'");
      ++*strp;
      if (errmsg == NULL
  	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	value &= 0xffff;
      *valuep = value;
      return errmsg;
    }
  else if ((strncasecmp (*strp, "%funcdesc_got_lo(", strlen("%funcdesc_got_lo(")) == 0)
	   || (strncasecmp (*strp, "%got_funcdesc_lo(", strlen("%got_funcdesc_lo(")) == 0))
    {
      *strp += strlen("%funcdesc_got_lo(");
      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_UBICOM32_FUNCDESC_GOT_LO,
				   &result_type, &value);
      if (**strp != ')')
	return _("missing `)'");
      ++*strp;
      if (errmsg == NULL
  	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	value &= 0xffff;
      *valuep = value;
      return errmsg;
    }
  else
    {
      errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, &value);
    }

  if (errmsg == NULL
      && ((long)value > 65535 || (long)value < -32768))
    return _("16-bit immediate value out of range");

  *valuep = value & 0xffff;
  return errmsg;
}

/* Parse 24-bit immediate for moveai instruction and allow %hi() operator */
static const char *
parse_imm24 (CGEN_CPU_DESC cd,
	     const char **strp,
	     int opindex,
	     unsigned long *valuep)
{
  const char *errmsg;
  enum cgen_parse_operand_result result_type = CGEN_PARSE_OPERAND_RESULT_NUMBER;
  bfd_vma value;

  if (strncasecmp (*strp, "%hi(", 4) == 0)
    {
      *strp += 4;
      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_UBICOM32_HI24,
				   &result_type, &value);
      if (**strp != ')')
	return _("missing `)'");
      ++*strp;
      if (errmsg == NULL
  	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	value >>= 7;
      *valuep = value;
      return errmsg;
    }
  else if (strncasecmp (*strp, "%got_hi(", strlen("%got_hi(")) == 0)
    {
      *strp += strlen("%got_hi(");
      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_UBICOM32_GOT_HI24,
				   &result_type, &value);
      if (**strp != ')')
	return _("missing `)'");
      ++*strp;
      if (errmsg == NULL
  	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	value >>= 7;
      *valuep = value;
      return errmsg;
    }
  else if (strncasecmp (*strp, "%funcdesc_got_hi(", strlen("%funcdesc_got_hi(")) == 0)
    {
      *strp += strlen("%funcdesc_got_hi(");
      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_UBICOM32_FUNCDESC_GOT_HI24,
				   &result_type, &value);
      if (**strp != ')')
	return _("missing `)'");
      ++*strp;
      if (errmsg == NULL
  	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	value >>= 7;
      *valuep = value;
      return errmsg;
    }
  else
    {
      errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, &value);
    }

  if (errmsg == NULL
      && ((long)value > 16777215 || (long)value < 0))
    return _("24-bit immediate value out of range");

  *valuep = value;
  return errmsg;
}

/* Parse 24-bit immediate for moveai instruction and allow %hi() operator */
static const char *
parse_imm25 (CGEN_CPU_DESC cd,
	     const char **strp,
	     int opindex,
	     unsigned long *valuep)
{
  const char *errmsg;
  enum cgen_parse_operand_result result_type = CGEN_PARSE_OPERAND_RESULT_NUMBER;
  bfd_vma value;

  if (strncasecmp (*strp, "%hi(", 4) == 0)
    {
      *strp += 4;
      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_UBICOM32_HI24,
				   &result_type, &value);
      if (**strp != ')')
	return _("missing `)'");
      ++*strp;
      if (errmsg == NULL
  	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	value >>= 7;
      *valuep = value;
      return errmsg;
    }
  else if (strncasecmp (*strp, "%got_hi(", strlen("%got_hi(")) == 0)
    {
      *strp += strlen("%got_hi(");
      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_UBICOM32_GOT_HI24,
				   &result_type, &value);
      if (**strp != ')')
	return _("missing `)'");
      ++*strp;
      if (errmsg == NULL
  	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	value >>= 7;
      *valuep = value;
      return errmsg;
    }
  else if (strncasecmp (*strp, "%funcdesc_got_hi(", strlen("%funcdesc_got_hi(")) == 0)
    {
      *strp += strlen("%funcdesc_got_hi(");
      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_UBICOM32_FUNCDESC_GOT_HI24,
				   &result_type, &value);
      if (**strp != ')')
	return _("missing `)'");
      ++*strp;
      if (errmsg == NULL
  	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	value >>= 7;
      *valuep = value;
      return errmsg;
    }
  else
    {
      errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, &value);
    }

  if (errmsg == NULL
      && ((long)value > 33554431 || (long)value < 0))
    return _("24-bit immediate value out of range");

  *valuep = value;
  return errmsg;
}

static const char *
parse_offset21 (CGEN_CPU_DESC cd,
		const char **strp,
		int opindex,
		int reloc ATTRIBUTE_UNUSED,
		enum cgen_parse_operand_result *type_addr ATTRIBUTE_UNUSED, 
		unsigned long *valuep)
{
  const char *errmsg;
  enum cgen_parse_operand_result result_type = CGEN_PARSE_OPERAND_RESULT_NUMBER;
  bfd_vma value;

  if (**strp == '#')
    {
      ++*strp;
      errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, &value);
    }
  else
    errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_UBICOM32_21_PCREL,
			       &result_type, &value);

  if (errmsg == NULL && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
    {
      /* we treat jmp #constant as being jump to pc + constant * 4 */
      if ((long)value > 1048575 || (long)value < -1048576)
        return _("21-bit relative offset out of range");
    }

  *valuep = value & 0x7fffff; /* address is actually 23 bits before shift */
  return errmsg;
}

static const char *
parse_offset16 (CGEN_CPU_DESC cd,
		const char **strp,
		int opindex,
		unsigned long *valuep)
{
  const char *errmsg;
  enum cgen_parse_operand_result result_type = CGEN_PARSE_OPERAND_RESULT_NUMBER;
  bfd_vma value;

  /* in this case we want low 7-bits to accompany the 24-bit immediate of a moveai instruction */
  if (strncasecmp (*strp, "%lo(", 4) == 0)
    {
      *strp += 4;
      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_UBICOM32_LO7_CALLI,
				   &result_type, &value);
      if (errmsg != NULL)
        return errmsg;

      if (**strp != ')')
	return _("missing `)'");
      ++*strp;

      if (result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
        *valuep = value & 0x7c;

      return NULL;
    }

  if (strncasecmp (*strp, "%got_lo(", strlen("%got_lo(")) == 0)
    {
      *strp += strlen("%got_lo(");
      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_UBICOM32_GOT_LO7_CALLI,
				   &result_type, &value);
      if (errmsg != NULL)
        return errmsg;

      if (**strp != ')')
	return _("missing `)'");
      ++*strp;

      if (result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
        *valuep = value & 0x7c;

      return NULL;
    }

  if (strncasecmp (*strp, "%funcdesc_got_lo(", strlen("%funcdesc_got_lo(")) == 0)
    {
      *strp += strlen("%funcdesc_got_lo(");
      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_UBICOM32_FUNCDESC_GOT_LO7_CALLI,
				   &result_type, &value);
      if (errmsg != NULL)
        return errmsg;

      if (**strp != ')')
	return _("missing `)'");
      ++*strp;

      if (result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
        *valuep = value & 0x7c;

      return NULL;
    }

  if (strncasecmp (*strp, "%lo18(", 6) == 0)
    {
      *strp += 6;
      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_UBICOM32_LO16_CALLI,
				   &result_type, &value);
      if (errmsg != NULL)
        return errmsg;

      if (**strp != ')')
	return _("missing `)'");
      ++*strp;

      if (result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
        *valuep = value & 0x0003fffc;

      return NULL;
    }

  errmsg = cgen_parse_signed_integer (cd, strp, opindex, &value);
  if (errmsg != NULL)
    return errmsg;

  /* ensure calli constant within limits and is multiple of 4 */
  if (value & 0x3)
    return _("calli offset must be multiple of 4");

  if ((long)value > 131071 || (long)value < -131072)
    return _("16-bit calli offset out of range");

  *valuep = value & 0x0003fffc; /* address is actually 18 bits before shift */
  return NULL;
}

static const char *
parse_leai_offset16 (CGEN_CPU_DESC cd,
		const char **strp,
		int opindex,
		unsigned long *valuep)
{
  const char *errmsg;
  enum cgen_parse_operand_result result_type = CGEN_PARSE_OPERAND_RESULT_NUMBER;
  bfd_vma value;

  /* in this case we want low 7-bits to accompany the 24-bit immediate of a moveai instruction */
  if (strncasecmp (*strp, "%lo(", 4) == 0)
    {
      *strp += 4;
      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_UBICOM32_LO_LEAI,
				   &result_type, &value);
      if (errmsg != NULL)
        return errmsg;

      if (**strp != ')')
	return _("missing `)'");
      ++*strp;

      if (result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
        *valuep = value & 0xffff;

      return NULL;
    }

  if (strncasecmp (*strp, "%got_lo(", strlen("%got_lo(")) == 0)
    {
      *strp += strlen("%got_lo(");
      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_UBICOM32_GOT_LO_LEAI,
				   &result_type, &value);
      if (errmsg != NULL)
        return errmsg;

      if (**strp != ')')
	return _("missing `)'");
      ++*strp;

      if (result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
        *valuep = value & 0xffff;

      return NULL;
    }

  if (strncasecmp (*strp, "%funcdesc_got_lo(", strlen("%funcdesc_got_lo(")) == 0)
    {
      *strp += strlen("%funcdesc_got_lo(");
      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_UBICOM32_FUNCDESC_GOT_LO_LEAI,
				   &result_type, &value);
      if (errmsg != NULL)
        return errmsg;

      if (**strp != ')')
	return _("missing `)'");
      ++*strp;

      if (result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
        *valuep = value & 0xffff;

      return NULL;
    }

  if (strncasecmp (*strp, "%lo18(", 6) == 0)
    {
      *strp += 6;
      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_UBICOM32_LO16_LEAI,
				   &result_type, &value);
      if (errmsg != NULL)
        return errmsg;

      if (**strp != ')')
	return _("missing `)'");
      ++*strp;

      if (result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
        *valuep = value & 0x0003fffc;

      return NULL;
    }

  errmsg = cgen_parse_signed_integer (cd, strp, opindex, &value);
  if (errmsg != NULL)
    return errmsg;

  /* ensure calli constant within limits and is multiple of 4 */
  if (value & 0x3)
    return _("leai offset must be multiple of 4");

  if ((long)value > 131071 || (long)value < -131072)
    return _("16-bit leai offset out of range");

  *valuep = value & 0x0003fffc; /* address is actually 18 bits before shift */
  return NULL;
}

static const char *
parse_imm8 (CGEN_CPU_DESC cd,
	    const char **strp,
	    int opindex,
	    unsigned long *valuep)
{
  const char *errmsg;
  bfd_vma value;
  int no_sign = 0;

  if (**strp == '0' && TOUPPER(*(*strp+1)) == 'X')
    no_sign = 1;

  errmsg = cgen_parse_signed_integer (cd, strp, opindex, &value);

  if (errmsg == NULL)
    {
      if ((no_sign && ((long)value > 255)) || 
	  (!no_sign && (((long)value > 127) || ((long)value < -128))))
        return _("8-bit immediate value out of range");
    }

  *valuep = value & 0xff;
  return errmsg;
}

/* -- dis.c */

static int
ubicom32_internal_print_insn (CGEN_CPU_DESC cd, bfd_vma pc, disassemble_info *info)
{
  if ((info)->mach <= bfd_mach_ubicom32ver4)
    (cd)->machs |= (1 << MACH_UBICOM32_OLDMOVEAI);
  else if ((info)->mach == bfd_mach_ubicom32ver5)
    {
      (cd)->machs |= (1 << MACH_UBICOM32_NEWMOVEAI);
      (cd)->machs |= (1 << MACH_UBICOM32DSP);
      (cd)->machs |= (1 << MACH_UBICOM32_VER4);
    }

  return default_print_insn (cd, pc, info);
}


#define CGEN_PRINT_INSN  ubicom32_internal_print_insn

/* Output a signed 4 bit integer */
static void
print_imm4 (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
	    PTR dis_info,
	    long value,
	    unsigned int attrs ATTRIBUTE_UNUSED,
	    bfd_vma pc ATTRIBUTE_UNUSED,
	    int length ATTRIBUTE_UNUSED)
{
  disassemble_info *info = (disassemble_info *) dis_info;
  (*info->fprintf_func) (info->stream, "%d", (int)value);
}

/* Output an unsigned 7-bit integer */
static void
print_imm7 (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
	    PTR dis_info,
	    long value,
	    unsigned int attrs ATTRIBUTE_UNUSED,
	    bfd_vma pc ATTRIBUTE_UNUSED,
	    int length ATTRIBUTE_UNUSED)
{
  disassemble_info *info = (disassemble_info *) dis_info;
  if (value != 0)
    (*info->fprintf_func) (info->stream, "%ld", value);
}

/* Output an unsigned 7-bit integer */
static void
print_pdec_imm7 (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
		 PTR dis_info,
		 long value,
		 unsigned int attrs ATTRIBUTE_UNUSED,
		 bfd_vma pc ATTRIBUTE_UNUSED,
		 int length ATTRIBUTE_UNUSED)
{
  disassemble_info *info = (disassemble_info *) dis_info;
  if (value != 0)
    {
      value = ~value;
      value ++;
      value &= 0x1fc;
      (*info->fprintf_func) (info->stream, "%ld", value);
    }
  else
    {
      (*info->fprintf_func) (info->stream, "%d", 512);
    }
}

/* Output either a register or a 11bit literal immediate value */
static void
print_direct_addr (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
		   PTR dis_info,
		   long value,
		   unsigned int attrs ATTRIBUTE_UNUSED,
		   bfd_vma pc ATTRIBUTE_UNUSED,
		   int length ATTRIBUTE_UNUSED)
{
  disassemble_info *info = (disassemble_info *) dis_info;
  struct ubicom32_cgen_data_space_map *cur;

  if(cd->machs & (1<<MACH_IP3035))
    {
      /* cpu is mercury */
      cur = ubicom32_cgen_data_space_map_mercury;
    }

  if((cd->machs & (1<<MACH_UBICOM32DSP)) || (cd->machs & (1<<MACH_UBICOM32_VER4)))
    {
      /* cpu is mars/ares */
      cur = ubicom32_cgen_data_space_map_mars;
    }

  if(cd->machs & (1<<MACH_UBICOM32_VER5))
    {
      /* cpu is jupiter */
      cur = ubicom32_cgen_data_space_map_jupiter;
    }

  //if (value > 0x3ff)
    /* XXX: some warning? */ ;
  value &= 0x3ff;
  for (; cur->name; cur++)
    if (value == cur->address)
      {
        (*info->fprintf_func) (info->stream, "%s", cur->name);
        return;
      }
  (*info->fprintf_func) (info->stream, "#%lx", value);
}

static void
print_imm24 (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
	     PTR dis_info,
	     long value,
	     unsigned int attrs ATTRIBUTE_UNUSED,
	     bfd_vma pc ATTRIBUTE_UNUSED,
	     int length ATTRIBUTE_UNUSED)
{
  disassemble_info *info = (disassemble_info *) dis_info;
  (*info->fprintf_func) (info->stream, "%%hi(0x%08lx)", value << 7);
}

static void
print_imm25 (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
	     PTR dis_info,
	     long value,
	     unsigned int attrs ATTRIBUTE_UNUSED,
	     bfd_vma pc ATTRIBUTE_UNUSED,
	     int length ATTRIBUTE_UNUSED)
{
  disassemble_info *info = (disassemble_info *) dis_info;
  (*info->fprintf_func) (info->stream, "%%hi(0x%08lx)", value << 7);
}

/* -- */

