From 479be673951799d79d8f70b3df0b1dd6bde05f0e Mon Sep 17 00:00:00 2001
From: lnxbuild <lnxbuild@localhost>
Date: Fri, 5 Jul 2013 17:20:33 +0800
Subject: [PATCH] add TMD27713 sensor hal support

Change-Id: I6a9783beaa836dc8eadbb4cfca14c2f21c814aab
---
 Android.mk    |    4 +-
 TmdSensor.cpp |  160 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 TmdSensor.h   |   36 +++++++++++++
 sensors.cpp   |   54 +++++++++++++++++++
 sensors.h     |    4 ++
 taos_common.h |   92 +++++++++++++++++++++++++++++++++
 6 files changed, 348 insertions(+), 2 deletions(-)
 create mode 100644 TmdSensor.cpp
 create mode 100644 TmdSensor.h
 create mode 100644 taos_common.h

diff --git a/Android.mk b/Android.mk
index d291326..ef03643 100644
--- a/Android.mk
+++ b/Android.mk
@@ -19,11 +19,11 @@ ifeq ($(call is-board-platform,msm8960),true)
   LOCAL_CFLAGS += -DTARGET_8930
 endif
 
+LOCAL_CFLAGS += -DTMD27713_SENSOR
 LOCAL_SRC_FILES :=	\
 		sensors.cpp 			\
 		SensorBase.cpp			\
-		LightSensor.cpp			\
-		ProximitySensor.cpp		\
+		TmdSensor.cpp			\
 		AkmSensor.cpp			\
 		Accelerometer.cpp				\
 		Mpu3050.cpp				\
diff --git a/TmdSensor.cpp b/TmdSensor.cpp
new file mode 100644
index 0000000..0ab229a
--- /dev/null
+++ b/TmdSensor.cpp
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <fcntl.h>
+#include <errno.h>
+#include <math.h>
+#include <poll.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <sys/select.h>
+#include "TmdSensor.h"
+#include "taos_common.h"
+#include <cutils/log.h>
+
+/*****************************************************************************/
+
+TmdSensor::TmdSensor(): SensorBase("/dev/tmd27713", "tmd27713"),
+	mAlsEnabled(0),
+	mProxEnabled(0),
+	mInputReader(32),
+	mHasPendingEvent(false)
+{
+	open_device();
+	if (data_fd >= 0) {
+		ioctl(dev_fd, TAOS_IOCTL_SENSOR_ON, 0);
+		ioctl(dev_fd, TAOS_IOCTL_PROX_CALIBRATE, 0);
+		ioctl(dev_fd, TAOS_IOCTL_ALS_CALIBRATE, 0);
+	}
+}
+
+TmdSensor::~TmdSensor(){
+	ioctl(dev_fd, TAOS_IOCTL_SENSOR_OFF, 0);
+}
+
+int TmdSensor::setInitialState() {
+	struct input_absinfo absinfo;
+    if (!ioctl(data_fd, EVIOCGABS(EVENT_TYPE_PROXIMITY), &absinfo)) {
+        // make sure to report an event immediately
+        mHasPendingEvent = true;
+        mPendingEvent.distance = indexToValue(absinfo.value);
+    }
+	return 0;
+}
+
+int TmdSensor::enable(int32_t handle, int enabled) {
+	int flags = enabled ? 1 : 0;
+	int err = 0;
+
+	if ((handle == SENSORS_LIGHT_HANDLE) && (flags != mAlsEnabled)) {
+		mAlsEnabled = flags;
+		if (flags == 1) {
+			ioctl(dev_fd,TAOS_IOCTL_ALS_ON,0);
+		} else {
+			ioctl(dev_fd,TAOS_IOCTL_ALS_OFF,0);
+		}
+	}
+	if ((handle == SENSORS_PROXIMITY_HANDLE) && (flags != mProxEnabled)) {
+		mProxEnabled = flags;
+		if (flags == 1) {
+			ioctl(dev_fd,TAOS_IOCTL_PROX_ON,0);
+		} else {
+			ioctl(dev_fd,TAOS_IOCTL_PROX_OFF,0);
+		}
+	}
+	return err;
+}
+
+bool TmdSensor::hasPendingEvents() const {
+	return mHasPendingEvent;
+}
+
+int TmdSensor::readEvents(sensors_event_t* data, int count)
+{
+	if (count < 1)
+		return -EINVAL;
+
+	ssize_t n = mInputReader.fill(data_fd);
+	if (n < 0)
+		return n;
+
+	int numEventReceived = 0;
+	input_event const* event;
+
+	while (count && mInputReader.readEvent(&event))
+		{
+		int type = event->type;
+		if (type == EV_ABS) {
+			processEvent(event->code, event->value);
+		} else if (type == EV_SYN) {
+			int64_t time = timevalToNano(event->time);
+			mPendingEvent.timestamp = time;
+			*data++ = mPendingEvent;
+			count--;
+			numEventReceived++;
+		} else {
+			ALOGE("tmd27711 Sensor: unknown event (type=%d, code=%d)",
+				type, event->code);
+			}
+			mInputReader.next();
+		}
+	return numEventReceived;
+}
+
+void TmdSensor::processEvent(int code, int value)
+{
+	switch (code) {
+		case ABS_DISTANCE:
+			mPendingEvent.version = sizeof(sensors_event_t);
+			mPendingEvent.sensor = SENSORS_PROXIMITY_HANDLE;
+			mPendingEvent.type = SENSOR_TYPE_PROXIMITY;
+			memset(mPendingEvent.data, 0, sizeof(mPendingEvent.data));
+			mPendingEvent.distance = (value > 0)? 5:0;
+			break;
+		case ABS_MISC:
+			mPendingEvent.version = sizeof(sensors_event_t);
+			mPendingEvent.sensor = SENSORS_LIGHT_HANDLE;
+			mPendingEvent.type = SENSOR_TYPE_LIGHT;
+			memset(mPendingEvent.data, 0, sizeof(mPendingEvent.data));
+			mPendingEvent.light = value;
+			break;
+		default:
+			break;
+		}
+
+}
+int TmdSensor::getFd() const
+{
+	return data_fd;
+}
+/*
+int TmdSensor::getEnable(int32_t handle) {
+	int en = 0;
+	if(handle == ID_L)
+		en = mAlsEnabled;
+	if(handle == ID_P)
+		en = mProxEnabled;
+	return en;
+}
+*/
+int TmdSensor::setDelay(int32_t handle, int64_t ns) {
+	return 0;
+};
+
+float TmdSensor::indexToValue(size_t index) const
+{
+    return index * PROXIMITY_THRESHOLD_GP2A;
+}
diff --git a/TmdSensor.h b/TmdSensor.h
new file mode 100644
index 0000000..c62de9c
--- /dev/null
+++ b/TmdSensor.h
@@ -0,0 +1,36 @@
+#include <stdint.h>
+#include <errno.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+#include "sensors.h"
+#include "SensorBase.h"
+#include "InputEventReader.h"
+
+/*****************************************************************************/
+
+struct input_event;
+
+class TmdSensor : public SensorBase {
+public:
+	TmdSensor();
+	virtual ~TmdSensor();
+
+	virtual int enable(int32_t handle, int enabled);
+	virtual int readEvents(sensors_event_t* data, int count);
+	virtual bool hasPendingEvents(void) const;
+	void processEvent(int code, int value);
+	int setInitialState(void);
+	int getFd() const;
+	virtual int setDelay(int32_t handle, int64_t ns);
+//	virtual int getEnable(int32_t handle);		//rockie
+	float indexToValue(size_t index) const;
+
+	int mAlsEnabled;
+	int mProxEnabled;
+	bool mHasPendingEvent;
+private:
+	InputEventCircularReader mInputReader;
+	sensors_event_t mPendingEvent;
+};
+/*****************************************************************************/
diff --git a/sensors.cpp b/sensors.cpp
index 9becc12..c5d331b 100644
--- a/sensors.cpp
+++ b/sensors.cpp
@@ -30,8 +30,12 @@
 
 #include "sensors.h"
 #include "AccelSensor.h"
+#if defined TMD27713_SENSOR
+#include "TmdSensor.h"
+#else
 #include "LightSensor.h"
 #include "ProximitySensor.h"
+#endif
 #include "AkmSensor.h"
 #include "GyroSensor.h"
 #include "PressureSensor.h"
@@ -82,6 +86,32 @@ static const struct sensor_t sSensorList[] = {
 		{ }
 	},
 
+#if defined TMD27713_SENSOR
+	{
+		"TMD27713 proximity sensor",
+		"TAOS",
+		1,
+		SENSORS_PROXIMITY_HANDLE,
+		SENSOR_TYPE_PROXIMITY,
+		5.0f,
+		1.0f,
+		0.5f,
+		0,
+		{ }
+	},
+	{
+		"TMD27713 light sensor",
+		"TAOS",
+		1,
+		SENSORS_LIGHT_HANDLE,
+		SENSOR_TYPE_LIGHT,
+		10000.0f,
+		1.0f,
+		0.5f,
+		0,
+		{ }
+	},
+#else
 	/* light sensor name */
 	{
 		"TSL27713FN",
@@ -109,6 +139,7 @@ static const struct sensor_t sSensorList[] = {
 		0,
 		{ }
 	},
+#endif
 
 	/* gyro scope */
 	{
@@ -179,12 +210,20 @@ struct sensors_poll_context_t {
 
 private:
 	enum {
+#if defined TMD27713_SENSOR
+		tmd	     		= 0,
+        compass         = 1,
+        gyro            = 2,
+        accel           = 3,
+        pressure        = 4,
+#else
 		light			= 0,
 		proximity		= 1,
 		compass			= 2,
 		gyro			= 3,
 		accel			= 4,
 		pressure		= 5,
+#endif
 		numSensorDrivers,
 		numFds,
 	};
@@ -203,9 +242,17 @@ private:
 			case SENSORS_ORIENTATION_HANDLE:
 				return compass;
 			case SENSORS_PROXIMITY_HANDLE:
+#if defined TMD27713_SENSOR
+				return tmd;
+#else
 				return proximity;
+#endif
 			case SENSORS_LIGHT_HANDLE:
+#if defined TMD27713_SENSOR
+				return tmd;
+#else
 				return light;
+#endif
 			case SENSORS_GYROSCOPE_HANDLE:
 				return gyro;
 			case SENSORS_PRESSURE_HANDLE:
@@ -219,6 +266,12 @@ private:
 
 sensors_poll_context_t::sensors_poll_context_t()
 {
+#if defined TMD27713_SENSOR
+    mSensors[tmd] = new TmdSensor();
+    mPollFds[tmd].fd = mSensors[tmd]->getFd();
+    mPollFds[tmd].events = POLLIN;
+    mPollFds[tmd].revents = 0;
+#else
 	mSensors[light] = new LightSensor();
 	mPollFds[light].fd = mSensors[light]->getFd();
 	mPollFds[light].events = POLLIN;
@@ -228,6 +281,7 @@ sensors_poll_context_t::sensors_poll_context_t()
 	mPollFds[proximity].fd = mSensors[proximity]->getFd();
 	mPollFds[proximity].events = POLLIN;
 	mPollFds[proximity].revents = 0;
+#endif
 
 	mSensors[compass] = new AkmSensor();
 	mPollFds[compass].fd = mSensors[compass]->getFd();
diff --git a/sensors.h b/sensors.h
index b2210e1..a414746 100644
--- a/sensors.h
+++ b/sensors.h
@@ -31,6 +31,10 @@ __BEGIN_DECLS
 
 /*****************************************************************************/
 
+#define PROXIMITY_THRESHOLD_GP2A  5.0f
+#define EVENT_TYPE_PROXIMITY        ABS_DISTANCE
+#define EVENT_TYPE_LIGHT            ABS_MISC
+
 #define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
 
 #define SENSORS_ACCELERATION_HANDLE		0
diff --git a/taos_common.h b/taos_common.h
new file mode 100644
index 0000000..6e0b00f
--- /dev/null
+++ b/taos_common.h
@@ -0,0 +1,92 @@
+/********************************************************************************
+* Device driver for monitoring ambient light intensity (lux) and proximity
+* detection for the TAOS TSL2x7x and TMD2x7x family of devices.
+*
+* Copyright (c) 2012, TAOS Corporation.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later vers ion.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA      02110-1301, USA.
+********************************************************************************/
+
+/*******************************************************************************
+*                                                                              *
+*       File Name:      taos_common.h                                          *
+*       Description:    Common file for ioctl and configuration definitions.   *
+*       		Used by kernel driver and driver access applications.  *
+*       		Please include this file, and <sys/ioctl.h> in your    *
+*                       driver access application program source.	       *
+*       Author:         John Koshi                                             *
+*       History:        09/16/2009 - Initial creation                          *
+*       		02/07/2010 - Add proximity			       *
+*                                                                              *
+*******************************************************************************/
+//#include <sys/types.h>
+// ioctl numbers
+#define TAOS_IOCTL_MAGIC		0XCF
+#define TAOS_IOCTL_ALS_ON		_IO(TAOS_IOCTL_MAGIC, 1)
+#define TAOS_IOCTL_ALS_OFF		_IO(TAOS_IOCTL_MAGIC, 2)
+#define TAOS_IOCTL_ALS_DATA		_IOR(TAOS_IOCTL_MAGIC, 3, short)
+#define TAOS_IOCTL_ALS_CALIBRATE	_IO(TAOS_IOCTL_MAGIC, 4)
+#define TAOS_IOCTL_CONFIG_GET		_IOR(TAOS_IOCTL_MAGIC, 5, struct taos_cfg)
+#define TAOS_IOCTL_CONFIG_SET		_IOW(TAOS_IOCTL_MAGIC, 6, struct taos_cfg)
+#define TAOS_IOCTL_PROX_ON		_IO(TAOS_IOCTL_MAGIC, 7)
+#define TAOS_IOCTL_PROX_OFF		_IO(TAOS_IOCTL_MAGIC, 8)
+#define TAOS_IOCTL_PROX_DATA		_IOR(TAOS_IOCTL_MAGIC, 9, struct taos_prox_info)
+#define TAOS_IOCTL_PROX_EVENT		_IO(TAOS_IOCTL_MAGIC, 10)
+#define TAOS_IOCTL_PROX_CALIBRATE	_IO(TAOS_IOCTL_MAGIC, 11)
+
+#define TAOS_IOCTL_SENSOR_ON		_IO(TAOS_IOCTL_MAGIC, 12)
+#define TAOS_IOCTL_SENSOR_OFF		_IO(TAOS_IOCTL_MAGIC, 13)
+#define TAOS_IOCTL_SENSOR_CONFIG	_IOW(TAOS_IOCTL_MAGIC, 14, struct taos_cfg)
+#define TAOS_IOCTL_SENSOR_CHECK		_IO(TAOS_IOCTL_MAGIC, 15)
+#define TAOS_IOCTL_SENSOR_test		_IO(TAOS_IOCTL_MAGIC, 16)
+
+/*
+// device configuration
+struct taos_cfg {
+	u32	calibrate_target;
+	u16	als_time;
+	u16	scale_factor;
+	u16	gain_trim;
+	u16	prox_threshold_hi;
+	u16	prox_threshold_lo;
+	u16	als_threshold_hi;
+	u16	als_threshold_lo;
+	u8	filter_history;
+	u8	filter_count;
+	u8	gain;
+	u8	prox_int_time;
+	u8	prox_adc_time;
+	u8	prox_wait_time;
+	u8	prox_intr_filter;
+	u8	prox_config;
+	u8	prox_pulse_cnt;
+	u8	prox_gain;
+};
+
+// proximity data
+struct taos_prox_info {
+	u16	prox_clear;
+	u16	prox_data;
+	int	prox_event;
+};
+
+struct tmd2771x_platform_data {
+	u8	pdrive;
+	u8	ppcount;
+	int	irq_gpio;
+	int	(*setup_resources)(void);
+	int	(*release_resources)(void);
+};
+*/
-- 
1.7.8.3

