From 2e62a95d8578e7583466e534787c97a7bd7bc9e5 Mon Sep 17 00:00:00 2001
From: lnxbuild <lnxbuild@localhost>
Date: Thu, 1 Aug 2013 15:46:25 +0800
Subject: [PATCH 2/3] add Gsensor HAL support

Change-Id: I16f4a570f3a117cd9a28ff27707994f79ff8b139
---
 Android.mk       |    3 +-
 KionixSensor.cpp |  270 ++++++++++++++++++++++++++++++++++++++++++++++++++++++
 KionixSensor.h   |   66 +++++++++++++
 sensors.cpp      |   23 +++++
 4 files changed, 361 insertions(+), 1 deletions(-)
 create mode 100644 KionixSensor.cpp
 create mode 100644 KionixSensor.h

diff --git a/Android.mk b/Android.mk
index ef03643..a3c7e34 100644
--- a/Android.mk
+++ b/Android.mk
@@ -20,12 +20,13 @@ ifeq ($(call is-board-platform,msm8960),true)
 endif
 
 LOCAL_CFLAGS += -DTMD27713_SENSOR
+LOCAL_CFLAGS += -DKX023_SENSOR
 LOCAL_SRC_FILES :=	\
 		sensors.cpp 			\
 		SensorBase.cpp			\
 		TmdSensor.cpp			\
 		AkmSensor.cpp			\
-		Accelerometer.cpp				\
+		KionixSensor.cpp 		\
 		Mpu3050.cpp				\
 		Bmp180.cpp				\
 		InputEventReader.cpp
diff --git a/KionixSensor.cpp b/KionixSensor.cpp
new file mode 100644
index 0000000..cce504f
--- /dev/null
+++ b/KionixSensor.cpp
@@ -0,0 +1,270 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <fcntl.h>
+#include <errno.h>
+#include <math.h>
+#include <poll.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <sys/select.h>
+
+#include <cutils/log.h>
+
+#include "KionixSensor.h"
+
+#define	EVENT_TYPE_ACCEL_X	ABS_X
+#define	EVENT_TYPE_ACCEL_Y	ABS_Y
+#define	EVENT_TYPE_ACCEL_Z	ABS_Z
+
+#define	ID_A	SENSORS_ACCELERATION_HANDLE
+#define	ID_M	SENSORS_MAGNETIC_FIELD_HANDLE
+
+#ifndef ID_M
+#define ID_M 100
+#endif
+#ifndef ID_O
+#define ID_O 101
+#endif
+
+/*****************************************************************************/
+#define KIONIX_ENABLE_BITMASK_A 0x01 /* logical driver for accelerometer */
+#define KIONIX_ENABLE_BITMASK_M 0x02 /* logical driver for magnetic field sensor */
+#define KIONIX_ENABLE_BITMASK_O 0x04 /* logical driver for orientation sensor */
+/*****************************************************************************/
+#define KIONIX_UNIT_CONVERSION(value) ((value) * GRAVITY_EARTH / (1024.0f))
+/*****************************************************************************/
+
+KionixSensor::KionixSensor()
+: SensorBase(NULL, "kionix_accel"),
+      mEnabled(0),
+      mInputReader(8),
+      mHasPendingEvent(false)
+{
+    mPendingEvent.version = sizeof(sensors_event_t);
+    mPendingEvent.sensor = ID_A;
+    mPendingEvent.type = SENSOR_TYPE_ACCELEROMETER;
+    mPendingEvent.acceleration.status = SENSOR_STATUS_ACCURACY_HIGH;
+    memset(mPendingEvent.data, 0, sizeof(mPendingEvent.data));
+
+    if (data_fd) {
+        strcpy(input_sysfs_path, "/sys/class/input/");
+        strcat(input_sysfs_path, input_name);
+        strcat(input_sysfs_path, "/device/");
+        input_sysfs_path_len = strlen(input_sysfs_path);
+    }
+
+    for (int i=0 ; i<3 ; ++i)
+        mDelay[i] = 200000000; // 200 ms by default
+}
+
+KionixSensor::~KionixSensor() {
+    if (mEnabled) {
+        enable(ID_A, 0);
+        enable(ID_M, 0);
+        enable(ID_O, 0);
+    }
+}
+
+int KionixSensor::enable(int32_t handle, int en)
+{
+    uint32_t mask;
+
+    switch (handle) {
+    case ID_A:
+        mask = KIONIX_ENABLE_BITMASK_A;
+        break;
+    case ID_M:
+        mask = KIONIX_ENABLE_BITMASK_M;
+        break;
+    case ID_O:
+        mask = KIONIX_ENABLE_BITMASK_O;
+        break;
+    default:
+        ALOGE("Unknown handle is passed to KionixSensor.");
+        return -EINVAL;
+    }
+
+	int err = 0;
+    uint32_t newState  = (mEnabled & ~mask) | (en ? mask : 0);
+
+    if (mEnabled != newState) {
+        if (newState && !mEnabled)
+            err = enable_sensor();
+        else if (!newState)
+            err = disable_sensor();
+        ALOGE_IF(err, "Could not change sensor state \"%d -> %d\" (%s).", mEnabled, newState, strerror(-err));
+        if (!err) {
+            mEnabled = newState;
+            update_delay();
+        }
+    }
+
+    return err;
+}
+
+int KionixSensor::setDelay(int32_t handle, int64_t ns)
+{
+    if (ns < 0)
+        return -EINVAL;
+
+    int index = -1;
+    switch (handle) {
+    case ID_A:
+        index = Accel;
+        break;
+    case ID_M:
+        index = Mag;
+        break;
+    case ID_O:
+        index = Ori;
+        break;
+    default:
+        ALOGE("Unknown handle(%d).", handle);
+        return -EINVAL;
+    }
+
+    mDelay[index] = ns;
+    return update_delay();
+}
+
+int KionixSensor::update_delay()
+{
+	int fd;
+
+    if (mEnabled) {
+        int64_t wanted = 0x7FFFFFFF;
+        for (int i=0 ; i<numChannels ; ++i) {
+            if (0 != (mEnabled & (1<<i))) {
+                int64_t const ns = mDelay[i];
+                wanted = (wanted) < ns ? wanted : ns;
+            }
+        }
+        strcpy(&input_sysfs_path[input_sysfs_path_len], "device/delay");
+        fd = open(input_sysfs_path, O_WRONLY);
+        if (fd >= 0) {
+            char buf[10];
+            sprintf(buf, "%d", (int)(wanted/1000000));
+            write(fd, buf, strlen(buf)+1);
+            close(fd);
+            return 0;
+        }
+
+        return -1;
+    }
+    return 0;
+}
+
+bool KionixSensor::hasPendingEvents() const {
+    return mHasPendingEvent;
+}
+
+int KionixSensor::readEvents(sensors_event_t* data, int count)
+{
+    if (count < 1)
+        return -EINVAL;
+
+    if (mHasPendingEvent) {
+        mHasPendingEvent = false;
+        mPendingEvent.timestamp = getTimestamp();
+        *data = mPendingEvent;
+        return mEnabled ? 1 : 0;
+    }
+
+    ssize_t n = mInputReader.fill(data_fd);
+    if (n < 0)
+        return n;
+
+    int numEventReceived = 0;
+    input_event const* event;
+
+    while (count && mInputReader.readEvent(&event)) {
+        int type = event->type;
+        if (type == EV_ABS) {
+            switch (event->code) {
+                case EVENT_TYPE_ACCEL_X:
+                    mPendingEvent.acceleration.x = KIONIX_UNIT_CONVERSION(event->value);
+                    break;
+                case EVENT_TYPE_ACCEL_Y:
+                    mPendingEvent.acceleration.y = KIONIX_UNIT_CONVERSION(event->value);
+                    break;
+                case EVENT_TYPE_ACCEL_Z:
+                    mPendingEvent.acceleration.z = KIONIX_UNIT_CONVERSION(event->value);
+                    break;
+            }
+        } else if (type == EV_SYN) {
+            mPendingEvent.timestamp = timevalToNano(event->time);
+            if (mEnabled) {
+                *data++ = mPendingEvent;
+                count--;
+                numEventReceived++;
+            }
+        } else {
+            ALOGE("KionixSensor: unknown event (type=%d, code=%d)",
+                    type, event->code);
+        }
+        mInputReader.next();
+    }
+
+    return numEventReceived;
+}
+
+int KionixSensor::enable_sensor() {
+    int fd;
+    int newState = 1;
+
+	strcpy(&input_sysfs_path[input_sysfs_path_len], "device/enable");
+    fd = open(input_sysfs_path, O_WRONLY);
+    if (fd >= 0) {
+        char buf[2];
+        sprintf(buf, "%d", newState);
+        write(fd, buf, strlen(buf)+1);
+        close(fd);
+        return 0;
+    }
+    return -1;
+}
+
+int KionixSensor::disable_sensor() {
+    int fd;
+    int newState = 0;
+
+	strcpy(&input_sysfs_path[input_sysfs_path_len], "device/enable");
+    fd = open(input_sysfs_path, O_WRONLY);
+    if (fd >= 0) {
+        char buf[2];
+        sprintf(buf, "%d", newState);
+        write(fd, buf, strlen(buf)+1);
+        close(fd);
+        return 0;
+    }
+    return -1;
+}
+/*
+bool KionixSensor::isEnabled(int32_t handle) {
+	switch (handle) {
+	case ID_A:
+		return (0 != (mEnabled & KIONIX_ENABLE_BITMASK_A)) ? true : false;
+	case ID_M:
+		return (0 != (mEnabled & KIONIX_ENABLE_BITMASK_M)) ? true : false;
+	case ID_O:
+		return (0 != (mEnabled & KIONIX_ENABLE_BITMASK_O)) ? true : false;
+	default:
+		LOGE("Unknown handle(%d).", handle);
+		return false;
+	}
+}
+*/
diff --git a/KionixSensor.h b/KionixSensor.h
new file mode 100644
index 0000000..b25fd77
--- /dev/null
+++ b/KionixSensor.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_KIONIX_SENSOR_H
+#define ANDROID_KIONIX_SENSOR_H
+
+#include <stdint.h>
+#include <errno.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+#include "sensors.h"
+#include "SensorBase.h"
+#include "InputEventReader.h"
+
+/*****************************************************************************/
+
+struct input_event;
+
+class KionixSensor : public SensorBase {
+public:
+            KionixSensor();
+    virtual ~KionixSensor();
+    virtual int setDelay(int32_t handle, int64_t ns);
+    virtual int enable(int32_t handle, int enabled);
+    virtual int readEvents(sensors_event_t* data, int count);
+    virtual bool hasPendingEvents() const;
+//    virtual bool isEnabled(int32_t handle);
+
+private:
+    enum {
+        Accel = 0,
+        Mag,
+        Ori,
+        numChannels
+    };
+    uint32_t mEnabled;
+    InputEventCircularReader mInputReader;
+    sensors_event_t mPendingEvent;
+    bool mHasPendingEvent;
+    int64_t mDelay[numChannels];
+    char input_sysfs_path[PATH_MAX];
+    int input_sysfs_path_len;
+
+	int enable_sensor();
+	int disable_sensor();
+
+	int update_delay();
+};
+
+/*****************************************************************************/
+
+#endif  // ANDROID_KIONIX_SENSOR_H
diff --git a/sensors.cpp b/sensors.cpp
index c5d331b..471004b 100644
--- a/sensors.cpp
+++ b/sensors.cpp
@@ -29,7 +29,11 @@
 #include <utils/Log.h>
 
 #include "sensors.h"
+#ifdef KX023_SENSOR
+#include "KionixSensor.h"
+#else
 #include "AccelSensor.h"
+#endif
 #if defined TMD27713_SENSOR
 #include "TmdSensor.h"
 #else
@@ -44,6 +48,20 @@
 
 /* The SENSORS Module */
 static const struct sensor_t sSensorList[] = {
+#ifdef KX023_SENSOR
+{
+		"KX023-1025 3-axis Accelerometer",
+		"KIONIX",
+		1,
+		SENSORS_ACCELERATION_HANDLE,
+		SENSOR_TYPE_ACCELEROMETER,
+		4.0f*9.81f,
+		(4.0f*9.81f)/1024.0f,
+		0.2f,
+		0,
+		{ }
+	},
+#else
 	/* Accelerometer */
 	{
 		"accelerometer",
@@ -57,6 +75,7 @@ static const struct sensor_t sSensorList[] = {
 		2000,	/* microseconds */
 		{ }
 	},
+#endif
 
 	/* magnetic field sensor */
 	{
@@ -293,7 +312,11 @@ sensors_poll_context_t::sensors_poll_context_t()
 	mPollFds[gyro].events = POLLIN;
 	mPollFds[gyro].revents = 0;
 
+#ifdef KX023_SENSOR
+	mSensors[accel] = new KionixSensor();
+#else
 	mSensors[accel] = new AccelSensor();
+#endif
 	mPollFds[accel].fd = mSensors[accel]->getFd();
 	mPollFds[accel].events = POLLIN;
 	mPollFds[accel].revents = 0;
-- 
1.7.8.3

